{"pages":[{"title":"About me","text":"QQ：616651408","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"2016个人年终总结","text":"不知不觉窗外的圣诞树又亮起了灯光，猛然惊觉新的一年即将来临。这一年收获了很多，成长了很多，同时也胖了很多。 生活这一年找到了可以相伴一生的那个人，也有了属于我们两个人的家，所以这一年包括以后的每一年都会过的很幸福。 高中时代的好友三毛子也成功晋级为父亲角色，布拉克在我不停的劝导下也成功走上了程序员这条不归路，郭永康也在今天(2016.12.28)步入了婚姻的坟墓。 大学时代的基友们也相继成为工程师，今年也全部在帝都团聚了。 可能是长大了，经常会想起父亲逐渐变多的白头发，母亲越来越多的皱纹和没完没了的唠叨。他们一样也是我努力的动力。 工作年初进入了一家创业公司，第一次一个人从零开始负责一个Android项目，虽然很艰辛，但是从中收获了很多，我始终相信只要付出了终究会有回报的。 我比较喜欢新的技术，随着项目的迭代，MVP、MVVM、Rxjava、Dagger2、单元测试、Retrofit、Freeline也不断的在项目中得到了实践。也逐渐的觉得自己知识的欠缺，觉得该沉下心来学习了，买了三本书重构改善既有代码的设计、代码整洁之道、Effective Java，可惜的是三本都没有看完，这不是一个好的结果。 近期公司移动端项目被叫停，虽然万般不舍，终究还是没有办法，现在负责微信小程序的开发，接触了一点前端的东西，感觉还是挺有意思的。 不过也对自己的方向有点迷茫，我想成为一专多长的技术型人才，现在最欠缺也是最想学的是后台服务器方面的东西，同时也不想放弃Android，这个问题困扰了很多天，还是没有一个完美的解决方案。 目前的打算是早晚坐地铁的时间看一些前端的东西，晚上空闲时间看后台服务器方面的，至于Android只能到有项目的时候再重新捡起来，但是出现了吸引我的新技术依然会立即在我个人项目中尝试。 坚持在新的一年里，有几件事是要坚持做下去的。 宠媳妇 写博客 阅读 锻炼","link":"/2016/12/29/2016%E4%B8%AA%E4%BA%BA%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"title":"Homebrew使用介绍","text":"Homebrew可以很好的下载并管理Mac上软件包，使软件包的管理清晰、灵活了很多。 安装一行代码即可安装： 1$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;检测是否安装成功： 1$ brew 配置想要酣畅淋漓的使用Homebrew，第一件事应该是配置国内的镜像源，推荐清华镜像、中科大镜像这两个镜像，不过中科大brew.git镜像地址多写了一个冒号，直接CV大法会报错，去掉就好了。个人实测清华镜像稍微快点。 清华镜像设置(逐条CV大法即可)： 1234567891011121314//替换brew.git$ cd &quot;$(brew --repo)&quot; $ git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git//替换homebrew-core.git$ cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;$ git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git//替换Homebrew Bottles源，使用zsh的同学替换.bash_profile为.zshrc$ echo &apos;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles&apos; &gt;&gt; ~/.bash_profilesource ~/.bash_profile//更新$ brew update 最好把brew.git、homebrew-core.git、Homebrew Bottles这三个的源都替换掉。 命令行操作查找： 1$ brew search &lt;package_name&gt;安装： 1$ brew install &lt;package_name&gt;卸载： 1$ brew uninstall &lt;package_name&gt;查看所有安装的包： 12$ brew list$ brew list --version //包括包版本查看包详情： 1$ brew info &lt;package_name&gt;查看包依赖关系： 1$ brew deps &lt;package_name&gt;查看需要更新的包： 1$ brew outdated更新brew： 1$ brew update更新包： 12$ brew upgrade //更新全部包$ brew upgrade &lt;package_name&gt; //更新指定包清理旧版本的包缓存： 1$ brew cleanup","link":"/2017/01/18/Homebrew%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"},{"title":"Docker学习笔记","text":"Docker相对于传统意义上的虚拟机最大的区别就在于传统虚拟机是虚拟出一套硬件后，再在上面运行一个完整的操作系统，再把需要运行的应用装在操作系统中运行。Docker在宿主的内核中运行应用进程，没有自己的内核，没有虚拟硬件，比起传统虚拟机更加轻快。 安装一行代码就可完成安装： 12$ curl -sSL https://get.daocloud.io/docker | sh $ curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 启动 DockerUbuntu 12.04/14.04、Debian 7 Wheezy： 1$ sudo service docker startUbuntu 16.04、Debian 8 Jessie/Stretch： 12$ sudo systemctl enable docker$ sudo systemctl start docker 建立用户组默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。 建立 docker 组： 1$ sudo groupadd docker 将当前用户加入 docker 组： 1$ sudo usermod -aG docker $USER Docker基本概念 镜像：操作系统 容器：容器是独立运行的一个或一组应用，以及它们的运行态环境，镜像和容器的关系就像是面向对象中的类和实例 仓库：镜像需要存储和分发，仓库用来存储镜像 Docker Registry一个Docker Registry中可以包含多个仓库 Docker Hub最常使用的 Registry 公开服务是官方的 Docker Hub，这也是默认的 Registry。 Docker Registry 公开服务国内访问Registry 公开服务会有些慢（原因你懂得），国内云服务商提供了针对 Docker Hub 的镜像服务（Registry Mirror），这些镜像服务被称为加速器，常见的有 阿里云加速器、DaoCloud 加速器、灵雀云加速器等。 配置如下： 国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 时速云镜像仓库、网易云镜像服务、DaoCloud 镜像市场、阿里云镜像库等。 镜像获取镜像12$ docker pull [选项][Docker Registry地址]&lt;仓库名&gt;:&lt;标签&gt;例如：$ docker pull ubuntu Docker Registry地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]，默认地址是 Docker Hub。 仓库名：如之前所说，这里的仓库名是两段式名称，既 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。 运行镜像有个镜像就可以以这个镜像运行一个容器，以上面ubuntu为例运行一个容器。 1$ docker run -it --rm ubuntu bash docker run ：就是运行容器的命令 -it ：其实是两个参数，-i：交互式操作，-t ：终端 --rm ：容器退出后随之将其删除 ubuntu ：用 ubuntu 镜像为基础来启动容器 bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash 1$ docker run -d -p 22 -p 80:8080 ubuntu/kevin /usr/sbin/sshd -D -d ：容器后台运行 -p ：指定端口设置 -p 80:8080 ：端口映射，省略80表示把容器端口8080映射到一个动态端口 /usr/sbin/sshd ：启动 ssh 服务 -D ：容器长时间运行 注： exit：退出容器 docker 容器有一个运行机制，当容器内没有前台运行进程时就会自动退出，所以会有一些容器，比如 Pyton、Java，如果不运行一个进程就会立即退出，所有在 run 的时候需要加上 -it 参数保证容器不会自动退出 列出镜像列出下载的镜像用docker images命令。 列表中的镜像体积综合并非实际硬盘消耗，由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。 虚悬镜像镜像既没有仓库名，也没有标签，均为 &lt;none&gt;。此类镜像为虚悬镜像(dangling image) ，下面命令专门显示此类镜像 1$ docker images -f dangling=true 这类镜像已经失去了存在的价值，可以随意删除，删除命令如下 1$ docker rmi $(docker images -q -f dangling=true) 中间层镜像为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 docker images 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。 1$ docker images -a 列出部分镜像根据仓库名列出镜像 1$ docker image ubuntu 根据仓库名和标签 1$ docker images ubunut:16.04 除此以外，docker images 还支持强大的过滤器参数 --filter，或者简写 -f。希望看到在nginx之后建立的镜像，可以用下面的命令 1$ docker images -f since=nginx 希望看到nginx之前建立的镜像，since换成before 保存镜像可用下面命令保存镜像 12$ docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]例如：docker commit -m &quot;commit message&quot; CONTAINER -m：保存commit信息 删除镜像可用下面命令删除镜像 1$ docker rmi [OPTIONS] IMAGE [IMAGE...] 导出镜像1$ docker save ubunut:16.04 &gt; ubunut.tar 导入镜像1$ docker load &lt; ubunut.tar 容器启动所需主要命令为docker run 1$ sudo docker run -u root --name kevin -i -t --restart always ubuntu /bin/bash -u：以 root 用户运行，防止权限不足 --name：为容器指定名称 -i ：保证容器中STDIN是开启的 -t ：为创建的容器分配一个伪tty终端，这样容器才能提供一个交互式shell --restart ：配置重启策略，默认是 no no ：不重启 on-failure ：容器退出状态非0重启 always ：始终重启docker start命令直接将一个已经终止的容器启动 如果没有进程在前台运行，容器会自动结束，为了避免这个问题 -it 参数是必要的 后台运行更多的时候，需要让 Docker在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现。 获取容器的输出信息，可以通过 docker logs 命令。 查看日志1$ docker logs -f -t --since=&quot;2020-04-31&quot; --tail=10 edu_web_1 –since：此参数指定了输出日志开始日期，即只输出指定日期之后的日志 -f：查看实时日志 -t：查看日志产生的日期 -tail=10：查看最后的10条日志 edu_web_1：容器名称 启动并进入大多数情况，我们需要启动并且直接进入到容器里面。 1$ docker run -it 容器名 bash 终止可用 docker stop [OPTIONS] CONTAINER [CONTAINER...] 来终止一个运行中的容器。 注：此命令后面是CONTAINER ID或者NAME参数，可用docker ps查看 此外，当Docker容器中指定的应用终结时，容器也自动终止。 例如对于上一章节中只启动了一个终端的容器，用户通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止。 终止状态的容器可以用 docker ps -a 命令看到。 1$ docker rm $(docker ps -qa --no-trunc --filter &quot;status=exited&quot;) # 删除所有已退出容器 查看容器进程1$ docker top [CONTAINER] 进入容器在使用 -d 参数时，容器启动后会进入后台。 某些时候需要进入容器进行操作 可用docker attach [OPTIONS] CONTAINER命令进入 更新容器有时需要在启动容器后增加一些配置参数，比如给容器添加重启： 1$ docker update --restart=always CONTAINER_NAME 导出容器可用 docker export 命令。 1$ docker export ubuntu:kevin &gt; latest.tar 导入容器可用 docker improt 命令。 注：用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。 删除容器可用 docker rm 来删除一个处于终止状态的容器 用 docker ps -a 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用 docker rm $(docker ps -a -q) 可以全部清理掉。 仓库仓库（Repository）是集中存放镜像的地方。 搜索用户无需登录即可通过 docker search 命令来查找官方仓库中的镜像，并利用 docker pull 命令来将它下载到本地。 另外，查找的时候通过 -s N 参数可以指定仅显示评价为 N 星以上的镜像（已经过时，不推荐使用），最新版本使用 --filter过滤查找。 利用下面命令下载到本地 1$ sudo docker pull centos 数据管理容器中管理数据主要有两种方式： 数据卷（Data volumes） 数据卷容器（Data volume containers） 数据卷数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性： 数据卷可以在容器之间共享和重用 对数据卷的修改会立马生效 对数据卷的更新，不会影响镜像 数据卷默认会一直存在，即使容器被删除 注意：数据卷的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的数据卷。 容器和主机之间拷贝数据拷贝容器文件到主机 123$ docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH例如：docker cp CONTAINER:/usr/local/tomcat/webapps/ROOT/index.html index.html 拷贝主机文件到容器 123$ docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH例如：docker cp index.html CONTAINER:/usr/local/tomcat/webapps/ROOT/index.html 网络网络模式 12345# host模式$ docker run -d --net=host ubuntu:14.04 tail -f /dev/null# bridge模式$ docker run -d -P --net=bridge nginx:1.9.1 Docker Machine 是一个 docker 管理工具，主要解决两个问题： docker 只能运行在 Linux 上 docker 只能管理运行本机的 docker 镜像 由于之前配置了 使用Docker Machine管理阿里云ECS ，Docker Machine使用一直不成功，报错信息如下： 1Error setting machine configuration from flags provided: --engine-install-url cannot be used with the virtualbox driver, use --virtualbox-boot2docker-url instead原因在于配置了阿里的一些参数，其中包括了MACHINE_DOCKER_INSTALL_URL，这个是报错的主要原因，查了半天的资料终于爬出坑了 1234567891011121314151617181920212223242526272829303132333435363738# 列出所有 docker 主机$ docker-machine ls# 查看 docker 主机参数$ docker-machine env defaultexport DOCKER_TLS_VERIFY=&quot;1&quot;export DOCKER_HOST=&quot;tcp://192.168.99.100:2376&quot;export DOCKER_CERT_PATH=&quot;/Users/Kevin/.docker/machine/machines/default&quot;export DOCKER_MACHINE_NAME=&quot;default&quot;# Run this command to configure your shell:# eval $(docker-machine env default)# 查看主机参数后，已经有很明显的提示告诉你怎么配置shell$ eval $(docker-machine env default)# 执行过后是不是没发现有什么变化，执行下面命令可以查看出区别$ docker version# 本地 docker 主机Client: Version: 17.03.1-ce API version: 1.27 Go version: go1.7.5 Git commit: c6d412e Built: Tue Mar 28 00:40:02 2017 OS/Arch: darwin/amd64# 连接的 docker 主机Server: Version: 17.05.0-ce API version: 1.29 (minimum version 1.12) Go version: go1.7.5 Git commit: 89658be Built: Thu May 4 21:43:09 2017 OS/Arch: linux/amd64 Experimental: false # 不想关闭终端设置本地 docker$ eval $(docker-machine env -u) 如果想要导入已有 Docker 主机到 docker-machine，需要配置 SSH 免密登录才能进行下一步，SSH 的配置网上教程有很多，不再赘述，Machine 所支持的驱动，下面是关于 Generic 驱动的一个例子： 1docker-machine create --driver generic --generic-ip-address=1.1.1.1 --generic-ssh-key ~/.ssh/id_rsa_ali [name] —generic-ip-address：指定远程 Docker 主机 IP —generic-ssh-key：SSH 密钥 —engine-storage-driver：指定Docker Engine使用的存储驱动程序为overlay name：在 docker-machine 中的名字，自定义 Error creating machine: Error checking the host: Error checking and/or regenerating the certs: There was an error validating certificates for host “0.0.0.0:2376”: tls: DialWithDialer timed out 如果遇到上面的错误，优先排查服务器 2376 端口是否可以正常访问，阿里云新买的服务器需要配置安全组规则才能正常访问这个端口 mount 本地磁盘docker machine下如果需要mount本地磁盘，需要用到sshfs，macOS 可以使用brew安装： 12$ brew cask install osxfuse$ brew install sshfs接着需要把远程主机的上的目录映射到本机： 123456$ mkdir foo$ docker-machine ssh dev mkdir foo$ docker-machine mount dev:/home/docker/foo foo$ touch foo/bar$ docker-machine ssh dev ls foobar这样就把远程主机的目录映射到了本机，本机操作该目录同样会同步到远程主机上： 1234567$ eval $(docker-machine env dev)$ docker run -v /home/docker/foo:/tmp/foo busybox ls /tmp/foobar$ touch foo/baz$ docker run -v /home/docker/foo:/tmp/foo busybox ls /tmp/foobarbaz Push本地镜像到DockerHub首先镜像名称格式需要是DockerHubName/RepositoryName，例如kevinlovedev/tomcat，可用docker commit命令保存镜像，/前面是DockerHub昵称，/后面是DockerHub仓库名。 保存镜像成功之后，需要用docker login命令登陆到DockerHub。 最后用docker push命令提交本地镜像到DockerHub仓库。 DockerfileMAINTAINER：设置该镜像的作者。语法如下： 1MAINTAINER kevin &quot;kevinlovemail@gmail.com&quot; build使用了 docker build 命令进行镜像构建。其格式为： 12$ docker build -t ubuntu:kevin .$ docker build -t ubuntu:kevin -f myDockerfile -t 指定了最终镜像的名称 ubuntu:kevin-f 指定构建文件 常用MySQL1$ docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -p 3306:3306 -d mysql --default-authentication-plugin=mysql_native_password--default-authentication-plugin=mysql_native_password 是为了避免客户端不支持默认加密方式 caching_sha2_password，不加出现以下报错： 1mysql 2059 - Authentication plugin &apos;caching_sha2_password&apos; cannot be loaded: dlopen(../Frameworks/caching_sha2_password.so, 2): image not found 删除无用资源docker 提供了删除无用资源的指令： 1$ docker system prune [OPTIONS] 常见问题无法删除一1Error response from daemon: conflict: unable to delete e4b9e4f71238 (must be forced) - image is being used by stopped container 1e359ad4363d该容器是终止状态，需要将此容器从终止状态删除，然后再删除镜像 12$ docker rm 1e359ad4363d # 删除终止容器$ docker rmi e4b9e4f71238 # 删除镜像 无法删除二1Error response from daemon: conflict: unable to delete 1dc4f730b414 (cannot be forced) - image has dependent child images 先删除依赖，如果 IMAGE ID 相同的话，根据 TAG 删除 1$ docker rm REPOSITORY:TAG # 根据TAG删除容器 无法删除三1Error response from daemon: Driver overlay failed to remove root filesystem 1dc4f730b414... device or rresource busy 在 CentOS 环境下重启 Docker 服务即可： 1$ sudo service docker restart 语法错误1Error response from daemon: Unknown instruction: RUNCMD can’t initialize iptables1can&apos;t initialize iptables table `filter&apos;: Permission denied (you must be root)启动容器时加入参数 --privileged=true WARNING: IPv4 forwarding is disabled. Networking will not work.需要开启 IPv4 转发 12345# 检测是否开启了 ipv4 转发$ sysctl net.ipv4.ip_forward# net.ipv4.ip_forward = 0 0：关闭 1：开启# 检测是否能连接到外网$ docker run busybox ping lovedev.org Dockerfile 中 apt-get update 特别慢在京东云上一个用 Dockerfile 构建一个镜像，一个问题困扰了很久，就是 apt-get update 的时候要么失败，要么很久很久都没有反应，换成国内镜像也有同样的问题，在网上看到文章说是 Docker 网卡的 MTU 值和宿主机网卡的 MTU 不一致导致的，不得不说京东云客服还是很给力的，修改一致后恢复正常 容器自动退出的解决办法Docker容器后台运行,就必须有一个前台进程.容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的在启动脚本里面增加一个执行进程： 1tail -f /dev/null如果是别人的镜像你不想修改： 1234# 用-dit参数docker run -dit --name ubuntu2 ubuntu# 或者增加运行指令docker run -d --name ubuntu ubuntu /bin/bash -c &quot;tail -f /dev/null&quot; 参考资料 Docker容器中用户权限管理","link":"/2016/12/09/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Http缓存机制","text":"Android本地持久化和性能优化离不开Http缓存，但是你真的了解其中的机制吗？ 缓存体系分为三部分 缓存存储策略 缓存过期策略 缓存对比策略 缓存存储策略Cache-Control请求头里面有五个值 Public Private no-cache max-age no-store 它们指明响应内容是否可以被客户端存储。前四个都会缓存文件数据，no-cache可理解为不建议使用本地缓存，但依然会缓存数据到本地。no-store不会缓存数据到本地。 数据被缓存到本地以后，再次请求不能保证直接读取本地缓存数据，因为不能保证本地数据是否可用，还需要一套鉴别机制确认才可以。 缓存过期策略验证本地缓存数据是否已过期，决定客户端是否可以直接加载本地缓存展示，而不去请求网络。 Expires指明缓存数据有效的绝对时间，客户端会在这个时间后作废缓存数据，在这个时间段内缓存数据都是有效的。 Http缓存头设计不规范导致Cache-Control头中的no-cache和max-age就是特例。它们既包括缓存策略也包含过期策略。 1234Cache-Control: max-age相当于Cache-Control: public/privateExpires: 当前客户端时间 + max-age 123Cache-Control: no-cache相当于Cache-Control: max-age = 0Tip： Cache-Control中配置的缓存策略优先级要高于Expires 缓存数据被标记已过期不代表从本地删除，某些情况还会用到。 如果没有提供缓存过期策略的情况下，浏览器遵循一个启发式缓存过期策略，根据响应头中2个时间字段Date和Last-Modified之间的的时间差值，取其值的10%作为缓存时间周期。 缓存对比策略将本地缓存数据标示发给服务器，服务器根据标示判断本地缓存数据是否仍有效。 接收到服务器首次响应时需要输出Last-modified和ETags的头信息导客户端。 客户端检测到数据过期或者请求数据的行为后，重新发起一个Http请求到服务器，服务器不会立即返回数据，先会查看请求头中有没有携带标示If-Modified-Since或If-None-Match，如果标示仍有效，返回304状态码通知客户端可以直接加载本地缓存展示。 至此就能明白上面说的本地缓存数据即便过期，也不等于从此没用的道理了。","link":"/2016/12/28/Http%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"},{"title":"Javadoc","text":"Javadoc 是从源代码中的 doc 注释生成 HTML 格式的 API 文档的工具 Andorid Studio中自带了一部分 Javadoc tags，但是有些时候可能满足不了需求，或者想用一些自定义的 tags。这时候就需要自己定义 tags 了。 下面先介绍一下自带 tags： Tag Description @author 文件作者 @param 参数 @return 返回值 @throw 抛出的异常 @see 参考其他 API {@link} 同上 {@linkplain} 同上 @deprecated 不推荐使用 @since JDK版本 @version 当前版本 {@link} 参考其他类或方法 {@code} 注释中写入代码 {@link} 和 @see 区别： @see 只能放开每行开头，{@link} 可以方法任意位置@see 会在 JavaDoc 里面生成一个 另请参阅： 的字段 示例代码： 1234567891011121314151617181920212223/** * javaDoc 测试1 * @author Kevin * @date 2017/5/22 */public class JavaDocTest1 { /** * 测试方法2 * &lt;br&gt;&lt;/br&gt; * 我是@link：{@link JavaDocTest2} * &lt;br&gt;&lt;/br&gt; * 我是@code：{@code name} * * @param name 名字 * @return 名字字符串 * @throws NullPointerException 空指针异常 * @see JavaDocTest2 */ public String test2(String name) throws NullPointerException { return null; }}生成的 Javadoc： 在 Andorid Studio 中 Tools -&gt; Generate Javadoc 可以生成 Javadoc 需要在 Other command line arguments： 选项中配置 -encoding utf-8 -charset utf-8 -tag ，否则生成的中文文档的汉字为乱码 如果要自定义 tag，拿我文件中的 @date 来说，则需要在 Other command line arguments： 中配置 -tag date:a:&quot;日期：&quot; ，否则生成的文档中没有该 tag 的信息","link":"/2017/05/22/Javadoc/"},{"title":"Java中的引用","text":"Java中有四大引用： 强引用(Reference) 软引用(SoftReference) 弱引用(WeakReference) 虚引用(PhantomReference) 想要更好的了解四大引用，需要先了解一下JVM的垃圾回收(Garbage Collection，缩写GC)机制 JVM的垃圾回收机制回收一个对象的标准：是否还有对象引用变量引用该对象 可以把JVM内存中对象引用理解成一成有向图，把引用变量、对象当作有向图的顶点，有向边总是从引用端指向被引用的Java对象 Java对象都是由线程创建出来的，因此可以把线程对象当成有向图的起始顶点 对于单线程程序，只有一个main线程，该图就是以main进程为顶点的有向图，main顶点可达的对象都是处于可达状态，GC不会回收它们；如果在这个有向图中的对象处于不可达状态，GC认为此对象不再被引用，就会回收此对象 根据有向图中，可以分为三种不同的状态： 可达状态：对象创建后，有一个以上引用变量引用它，有向图中从顶点可导航到该对象，它就处于可达状态 可恢复状态：程序中对象不再有任何引用变量引用它，它先进入可恢复状态，有向图中从顶点不可导航到该对象，在GC回收该对象占用内存之前，系统会调用可恢复状态对象的finalize()方法进行资源清理，如果习题系统在调用finalize()方法重新让一个以上引用变量引用该对象，此对象会再次变为可达对象。否则进入不可达状态 不可达状态：对象的所有引用都被切断，系统调用所有对象的finalize()方法依然没有使该对象变成可达状态。该对象将永久性的失去引用，变为不可达状态。此状态下GC才会真正回收该对象 对于GC来说，判断一个对象是否可以被回收的标准就是该对象是否还被引用。为了更好的管理对象的引用，从JDK1.2开始，java在java.lang.ref包下新增了3个类： SoftReference 、 WeakReference 、 PhantomReference 强引用java中最常见的引用，创建一个对象，把该对象赋给一个引用变量，该引用变量就是强引用。强引用处于可达状态，即使系统内存空间非常存紧张，该对象永远也不会被用到，也不可能被GC回收，因此强引用是造成内存泄漏的主要原因之一。 软引用软引用通过 SoftReference 类实现，当对象只具有软引用时，系统内存空间不足时，GC将会回收该对象；系统内容空间充足时，GC不会回收该对象。 可以使用以下命令强制设置堆内存来测试软引用是否被回收： 1$ java-Xmx2m-Xms2m Filename 弱引用弱引用通过 WeakReference 类实现，弱引用和软引用相似，不过弱引用所引用对象生存期更短。当GC运行时，不管系统内存空间是否紧张，都会回收该对象占用的内存。 以下代码很好说明了弱引用回收时机： 1234567891011121314import java.lang.ref.WeakReference;public class Main { public static void main(String[] args) { String str = new String(&quot;Kevin&quot;); WeakReference&lt;String&gt; weakReference = new WeakReference&lt;String&gt;(str); str = null; System.out.println(weakReference.get()); //第一次打印 System.gc(); System.runFinalization(); System.out.println(weakReference.get()); //第二次打印 }} 第一次打印的结果是 Kevin 第一次打印的结果是 null 弱引用具有很大的不确定性，每次GC运行时都会回收弱引用所引用的对象，然而GC的运行并不受人为的控制，程序中要获取弱引用所引用的对象，要小心 NullPointerException 异常，要想获取已经被释放的对象，必须重新创建该对象 一般情况程序很少会直接使用单个 WeakReference 引用对象，当有大量对象需要使用弱引用来引用时，可以考虑使用 WeakHashMap 来保存 虚引用虚引用通过 PhantomReference 类实现，又时候也被叫做幻象引用，它类似没有引用，对对象本身没有太大影响 软引用和弱引用可以单独使用，但虚引用不能，因为单独使用虚引用没有意义。虚引用主要作用是为了跟踪对象被垃圾回收的状态，程序可以通过检查与虚引用关联的引用队列中是否已经包含指定的虚引用，了解所引用对象是否即将被回收 引用队列由 java.lang.ref.ReferenceQueue 类表示，它用于保存被回收后对象的引用。当软引用，弱引用和引用队列联合使用时，系统回收被引用的对象之后，会把回收对象对应的引用添加到关联的引用队列中。与软引用和弱引用不同的是，虚引用必须和引用队列 ReferenceQueue 联合使用，在对象被释放之前，会把它对应的虚引用添加到它关联的引用队列中，使对象被回收前可以做操作。","link":"/2017/03/23/Java%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/"},{"title":"Markdown简单语法说明","text":"Markdown：一种简单易学功能强大、任何文本编辑器都可以编写的标记语言。目前 github、Stackoverflow 等网站都支持这种格式。 标题Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。 类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如： 12345This is an H1=============This is an H2------------- 任何数量的 = 和 - 都可以有效果，要写在文章的最开头才会有效果。 类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如： 12345# 这是 H1## 这是 H2###### 这是 H6 区块引用引用别人文字的时候，这个格式就显得非常必要。Markdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing. Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ： 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ： 12345 This is the first level of quoting.&gt;&gt; &gt; This is nested blockquote.&gt;&gt; Back to the first level. 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： 12345678&gt; ## 这是一个标题。&gt; &gt; 1. 这是第一行列表项。&gt; 2. 这是第二行列表项。&gt; &gt; 给出一些例子代码：&gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); 注：&gt;和文本之间要保留一个字符的空格。 列表Markdown 支持有序列表和无序列表。 无序列表可以使用星号、加号或是减号作为列表标记： 1234567891011* Red* Green* Blue+ Red+ Green+ Blue- Red- Green- Blue 注：上面的三种格式效果都相同，符号后面保留一个字符的空格。 有序列表则使用数字接着一个英文句点： 1231. Bird2. McHale3. Parish 分割线可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。 1234***************--------------- 链接Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，不管是哪一种，链接文字都是用 [方括号] 来标记。 12This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute. 隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记，只需要在链接文字后面加上一个空的方括号： 1[Google][] 定义链接内容： 1[Google]: http://google.com/ 注：链接的定义可以放在文件中的任何一个地方，最好放到文件最后集中管理。 参考式链接的范例： 1234567[Google] [1][Baidu] [2] [LoveDev] [3] [1]: http://google.com/ &quot;Google Search&quot; [2]: http://baidu.com/ &quot;Baidu Search&quot; [3]: http://lovedev.org/ &quot;My Blog &quot; 参考式的链接其实重点不在于它比较好写，而是它比较好读以及易于维护，文章内容不需要改变，只用改变标示对应的链接就可以了。 强调Markdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 标签包围，用两个 * 或 _ 包起来的话，则会被转成 。 1234567*single asterisks*_single underscores_**double asterisks**__double underscores__ 会转成： 1234567&lt;em&gt;single asterisks&lt;/em&gt;&lt;em&gt;single underscores&lt;/em&gt;&lt;strong&gt;double asterisks&lt;/strong&gt;&lt;strong&gt;double underscores&lt;/strong&gt; 注：唯一的限制是，用什么符号开启标签，就要用什么符号结束。 代码如果要标记一小段行内代码，你可以用反引号把它包起来（`）。 1Use the `printf()` function. 如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段： 1``There is a literal backtick (`) here.`` 图片Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 行内式的图片语法： 123![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 详细叙述如下： 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。 参考式的图片语法： 1![Alt text][id] 「id」是图片参考的名称，图片参考的定义方式和参考式链接一样： 1[id]: url/to/image &quot;Optional title attribute&quot; 反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号。 1\\*literal asterisks\\* Markdown 支持以下符号前面加上反斜杠来帮助插入普通的符号： 123456789101112\\ 反斜线` 反引号* 星号_ 底线{} 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 自动链接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。例如： 1&lt;http://example.com/&gt; Markdown 会转为： 1&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt; 邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如： 1&lt;616651408@qq.com&gt; Markdown 会转成： 1234&lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;","link":"/2016/06/27/Markdown%E7%AE%80%E5%8D%95%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E/"},{"title":"NPM使用介绍","text":"NPM全名是Node Package Manager，是Node.js的套件（package）管理工具，已成为世界上最大的包管理器，登记了超过35万软件包，是第二名Apache Maven的两倍以上。 安装使用Homebrew安装node便于管理，Homebrew的使用请参考我的另一篇文章使用下面的命令安装node： 1$ brew install node测试是否安装成功： 12$ node -v //检测node版本$ npm -v //检测npm版本 配置查看用户配置文件：npm config get userconfig查看全局配置文件：npm config get globalconfig内置配置文件：安装npm目录下的npmrc文件 npm配置的命令行操作： 1234567$ npm config set &lt;key&gt; &lt;value&gt; [--global] //设置指定配置$ npm config get &lt;key&gt; //获取指定配置信息$ npm config delete &lt;key&gt; //删除指定配置$ npm config list //显示所有配置信息$ npm config edit //编辑npm配置$ npm get &lt;key&gt; //获取指定配置信息$ npm set &lt;key&gt; &lt;value&gt; [--global] //设置指定配置设置配置属性时默认是存储于用户配置文件中，加上--global，则被存储在全局配置文件中。如果要查看npm的所有配置属性（包括默认配置），可以使用npm config ls -l。如果要查看npm的各种配置的含义，可以使用npm help config。 由于某种神奇的原因，通过NPM官方源下载起来各种慢，要想更好的体验npm，还需要配置国内npm镜像，推荐使用淘宝的npm镜像https://registry.npm.taobao.org。 12345# 永久设置镜像$ npm config set registry https://registry.npm.taobao.org# 临时设置镜像$ npm --registry https://registry.npm.taobao.org install express 命令行操作查看帮助： 1$ npm help &lt;command&gt;升级npm： 12$ sudo npm install npm -g$ sudo cnpm install npm -g //使用淘宝镜像安装node.js模块： 1$ npm install &lt;Module Name&gt;查看安装： 1$ npm ls 查看全局安装： 1$ npm ls -g --depth=0卸载全局安装： 1$ npm uninstall -g &lt;Module Name&gt; 卸载安装： 1$ npm uninstall &lt;Module Name&gt;更新模块： 1$ npm update &lt;Module Name&gt;清空本地缓存: 123$ npm cache clean# 强制清理$ npm cache clear --force安装包版本号： 12345{ &quot;a&quot;: &quot;1.1.1&quot;, &quot;b&quot;: &quot;~1.1.1&quot;, &quot;c&quot;: &quot;^2.6.9&quot;,} NPM使用语义版本号来管理代码，语义版本号分为 X.Y.Z 三位： 只是修复 bug，更新 Z 位置 新增功能且向下兼容，更新 Y 位置 大变动且不向下兼容，更新 X 位置 版本号前缀为 ~ 表示同一主版本号和次版本号中，不小于指定版本号的版本号。~1.1.1 对应主版本号为 1，次版本号为 1 版本号前缀为 ^ 表示同一主版本号中，不小于指定版本号的版本号 开发阶段，^ 和 ~ 表示同一个意思：主版本号和次版本号都相同 先行版本号也有一些例外，只有以下几种方式可以匹配到先行版本号： 精确的指定版本号，如：1.0.0-alpha.1 使用 &gt; 指定范围，如：&gt;1.0.0-alpha、&gt;=1.0.0-rc.0 &lt;1.0.1 使用 x、X、* 指定所有版本号，如：*","link":"/2017/01/18/NPM%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"},{"title":"Scrapy学习笔记01-初窥","text":"Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。 安装安装过程请根据自己使用的平台自行 Google，这里是官方的安装指南 创建项目本项目用于爬取 豆瓣电影Top250 数据，开发工具为 PyCharm 项目地址：douban Scrapy 需要用命令行创建一个项目： 1$ scrapy startproject douban 项目结构： scrapy.cfg：项目配置文件 douban/setting.py：爬虫的设置文件 douban/spiders/：爬虫放置文件位置 修改配置文件需要修改 setting.py 中请求头信息 chrome 访问豆瓣电影Top250 ，然后打开开发者工具并选择 Network 标签，最后刷新界面： 根据获取到的数据修改 setting.py 文件： 12345678# 修改下面两个字段USER_AGENT = &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36&apos;# Scrapy HTTP Request使用的headerDEFAULT_REQUEST_HEADERS = { &apos;Accept&apos;: &apos;text/event-stream&apos;, &apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.8,en;q=0.6,zh-TW;q=0.4,zh-HK;q=0.2&apos;,} 定义数据对象需要为爬取到的数据提供一个对象，和 Java 中的对象类似，继承于 scrapy.Item 类，定义类型为 scrapy.Field 的属性字段： 12345678import scrapyclass Item(scrapy.Item): title = scrapy.Field() pic = scrapy.Field() link = scrapy.Field() score = scrapy.Field() commentsNum = scrapy.Field() 创建爬虫scrapy 提供了命令行工具，可以很方便的根据框架中的模板创建一个爬虫 123456# 显示所有模板$ scrapy genspider -l# 查看模板内容$ scrapy genspider -d basic# 根据模板生成名为doubanMovie的爬虫文件$ scrapy genspider -t basic doubanMovie douban.com 生成的 doubanMovie.py 文件： 12345678910# -*- coding: utf-8 -*-import scrapyclass DoubanmovieSpider(scrapy.Spider): name = &quot;doubanMovie&quot; allowed_domains = [&quot;douban.com&quot;] start_urls = [&apos;http://douban.com/&apos;] def parse(self, response): pass name：spider 名字，必须是唯一的 allowed_domains：允许爬取的域名 start_urls：开始爬取的 URL parse()：spider 的一个方法，调用时，会把 start_urls 中 URL 下载生成的 Response 对象作为唯一参数传递给该方法。该方法负责解析返回的数据，提取数据和生成需要进一步处理的 Request 对象 修改 start_urls 为我们要爬取的 豆瓣电影Top250 ，并用 XPath 解析 Response 对象： 123456789101112131415161718192021222324# -*- coding: utf-8 -*-import scrapyfrom douban.movie import Movieimport reclass DoubanMovieSpider(scrapy.Spider): name = &quot;doubanMovie&quot; allowed_domains = [&quot;douban.com&quot;] start_urls = [ &apos;https://movie.douban.com/top250&apos;, ] def parse(self, response): item = Movie() for sel in response.xpath(&apos;//div[@class=&quot;item&quot;]&apos;): item[&apos;title&apos;] = sel.xpath(&apos;div/a/img/@alt&apos;).extract_first() item[&apos;pic&apos;] = sel.xpath(&apos;div/a/img/@src&apos;).extract_first() item[&apos;link&apos;] = sel.xpath(&apos;div/a/@href&apos;).extract_first() item[&apos;info&apos;] = sel.xpath(&apos;div[2]/div[2]/p[2]/span/text()&apos;).extract_first() item[&apos;score&apos;] = sel.xpath(&apos;div[2]/div[2]/div/span[2]/text()&apos;).extract_first() item[&apos;commentsNum&apos;] = sel.xpath(&apos;div[2]/div[2]/div/span[4]/text()&apos;).re(r&apos;[0-9]+&apos;)[0] yield item 到此就可以爬取 豆瓣电影Top250 中第一页的内容了，在命令行中进入项目根目录输入运行命令开始爬取内容并输出到文件中： 1$ scrapy crawl doubanMovie -o ~/Downloads/doubanMovie.jsondoubanMovie.json 文件内容： 数据流","link":"/2017/04/28/Scrapy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-%E5%85%A5%E9%97%A8/"},{"title":"Scrapy学习笔记03-Spiders","text":"Spider 类定义了如何爬取某个网站。包括爬取的动作(例如:是否跟进链接)以及如何从网页的内容中提取结构化数据(爬取item)。 Spider 的执行流程： 以设置的 URL 初始化 Request，设置回调函数，Request 下载完毕返回时，生成 Response，并作为参数传给回调函数，Response 里面包含了所有想要的数据。Spider 中初始的 Request 通过 start_requests() 来获取， start_requests() 读取 start_urls 中的URL， 生成 Request 并把 parse() 作为回调函数。 在回调函数中处理返回内容，可以使用 XPath 或者 CSS，处理后的数据封装到 Item 对象里面 通过 Item Pipelinme 存入数据库，也可以使用 Feed exports 存入文件中 scrapy.Spider最简单的 Spider，其他的 Spider 都继承该类 单个回调函数中返回多个 Request 以及 Item 的例子： 12345678910111213141516171819import scrapyfrom douban.joke import Jokeclass MySpider(scrapy.Spider): name = &apos;example.com&apos; allowed_domains = [&apos;example.com&apos;] start_urls = [ &apos;http://www.example.com/1.html&apos;, &apos;http://www.example.com/2.html&apos;, &apos;http://www.example.com/3.html&apos;, ] def parse(self, response): sel = scrapy.Selector(response) for h3 in response.xpath(&apos;//h3&apos;).extract(): yield Joke(title=h3) for url in response.xpath(&apos;//a/@href&apos;).extract(): yield scrapy.Request(url, callback=self.parse) name字符串类型，定义 spider 的名称 allowed_domains要爬取的域名列表，当 OffsiteMiddleware 开启后，不在列表中的域名将不会被跟进OffsiteMiddleware 过滤出不由该 spider 负责的 URL。 start_urls要爬取的具体 URL 列表 make_request_from_url(url)该方法接受一个URL并返回用于爬取的 Request 对象。 该方法在初始化request时被 start_requests() 调用，也被用于转化url为request。 start_requests() 该方法必须返回一个可迭代对象(iterable)。该对象包含了 Spider 用于爬取的 Request parse(response) 当 Response 没有指定回调函数时，该方法是 Scrapy 处理下载的 Response 的默认方法，它负责处理 response 并返回处理的数据以及跟进的 URL log(message[, level, component])使用 scrapy.log.msg() 方法记录 (log)message，log 中自动带上该spider的 name 属性 closed(reason)当spider关闭时，该函数被调用。该方法提供了一个替代调用signals.connect()来监听 spider_closed 信号的快捷方式 CrawlSpiderCrawlSpider 可以自定义规则来跟进指定的 URL，除了继承了 Spider 的全部属性，它还提供了新的属性： rules一个包含一个(或多个) Rule 对象的集合(list)，如果多个 Rule 匹配了相同的连接，该列表中的第一个会被使用 parse_start_url(response)当start_url的请求返回时，该方法被调用。 该方法分析最初的返回值并必须返回一个 Item 对象或者 一个 Request 对象或者 一个可迭代的包含二者对象","link":"/2017/05/14/Scrapy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003-Spiders/"},{"title":"Scrapy学习笔记02-选择器","text":"Scrapy提取数据有自己的一套机制。它们被称作选择器(seletors)，他们通过特定的 XPath 或者 CSS 表达式来选择HTML文件中的某个部分。 XPathXPath 是一门在 XML 文档中查找信息的语言，CSS 是一门将HTML文档样式化的语言，本文主要介绍 XPath 以一个图片为例子： 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;div class=&quot;item&quot;&gt; &lt;table class=&quot;pic&quot;&gt; &lt;a href=&quot;https://movie.douban.com/subject/1292052/&quot;&gt; &lt;img alt=&quot;1&quot; src=&quot;https://img3.doubanio.com/view/movie_poster_cover/ipst/public/p480747492.webp&quot;&gt; &lt;img alt=&quot;2&quot; src=&quot;https://img3.doubanio.com/view/movie_poster_cover/ipst/public/p2233971046.jpg&quot;&gt; &lt;div&gt;hello, world&lt;/div&gt; &lt;/a&gt; &lt;/table&gt;&lt;/div&gt; 节点在 XPath 中，有七种类型的节点：元素、属性、文本、命名空间、处理指令、注释以及根节点。XML 文档是被作为节点树来对待的。树的根被称为根节点。 在上面例子中： div：根节点 table：元素节点 href：属性节点 选取节点 Expression Alias nodename 选取当前节点下所有子节点 / 绝对路径 // 文档中所有该节点 . 当前节点 .. 父节点 @ 选取属性 是不是很眼熟呢？和命令行操作很类似 Expression Alias div div下所有子节点 /div div根节点 div/table div子元素中所有table节点 //img 所有img节点 div//img div后代元素中所有table节点 //@src 名为src的所有属性 谓语谓语用来查找某个特定的节点或者包含某个指定的值的节点 Expression Alias //img[@alt=”1”] alt值为1的节点中src属性的值 //a/img[1] a中子元素的第一个img元素 //a/img[last()] a中子元素的最后一个img元素 获取值 Expression Alias //img[@alt=”1”]/@src alt值为1的节点中src属性的值 /div/@class div根节点中class属性的值 //a/div/text() div节点中的hello, world //a//text() div节点中子节点的所有文本 捷径伟大的 chrome 已经提供了直接复制 XPath 功能，在开发者工具中右键节点选择 Copy -&gt; Copy XPath，就可以获取到 XPath 的绝对路径 选择器由于在response中使用XPath、CSS查询十分普遍，因此，Scrapy提供了两个实用的快捷方式：response.xpath() 及 response.css()： 标准选择器12# alt属性值为1的img元素response.xpath(&apos;//img[@alt=&quot;1&quot;]&apos;) xpath() 及 css() 返回 SelectorList 类的实例，这是一个新选择器的列表，SelectorList 类是内建 list 类的子类，并提供一些额外的方法 Method Alias xpath(query) 结果为一个单一化的 SelectorList css(query) 结果为一个单一化的 SelectorList extract() 提取真实的原文数据，结果为单一化的unicode字符串列表 re() 通过正则表达式来提取数据，结果为单一化的unicode字符串列表 nonzero() 列表非空返回True，否则返回False 嵌套选择器12# 包含src属性，并且src属性值中包含doubanio字符串的img元素response.xpath(&apos;//img[contains(@src, &quot;doubanio&quot;)]&apos;) 带有正则的选择器Selector 有一个 .re() 方法，可以用来通过正则表达式来提取数据，例如在 Scrapy学习笔记01-初窥 中： 12# 获取 “12345评论” 中的12345item[&apos;commentsNum&apos;] = sel.xpath(&apos;div[2]/div[2]/div/span[4]/text()&apos;).re(r&apos;[\\d]+&apos;)[0] 括号里面的第一个 r 表示字符串为非转义的原始字符串，强烈推荐不管有没有转义字符都加上","link":"/2017/04/28/Scrapy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002-%E9%80%89%E6%8B%A9%E5%99%A8/"},{"title":"VIM学习笔记","text":"1VIM == &quot;编辑器之神&quot; 退出 Command Alias :q 未修改退出 :q! 强制不保存退出 :x 保存并退出 ## 切换 tab Command Alias :———- :——– gt 下个 tab gT 上个 tab ## 查找 Command Alias :———- :——– n 正序查找 / 后面加内容 f{char} 查找第一个 [char] ; 重复最后一个 f, F, t, T 指令 移动单词移动 Command Alias W w 移动到下一个单词开头 E e 移动到下一个单词结尾 B b 倒退到上一个单词开头 * 跳到下个词 # 跳到上个词 ### 整行移动 Command Alias :———- :——– 0 移动到行首 $ 移动到行末 + 移动到下一行开头 - 移动到上一行开头 ### 根据行号来移动 Command Alias :———- :——– Ctrl+g 显示当前行信息 nG 转至第n行 G 转至文本末尾 gg 移至文本开头 ### 屏幕 Command Alias :———- :——– H 屏幕上方 M 屏幕中间 L 屏幕底部 ### 复合命令 Command Alias :———- :——– C 相当于 c$，从光标所在位置删除到末尾 s 相当于 cl，删除光标所在位置字符并进入插入模式 S 相当于 cc A 在一行的结尾处追加 I 在一行的开头处插入 o 在光标所在位置的下一行打开新行插入 O 在光标所在位置的上一行打开新行插入 tips1：10I*先输入10,然后输入i，接着输入*号，最后按 　　 　这样就可以在一行开头输入十个*　　 　　　 　tips2：同样，5o###先输入5,然后输入o，接着输入###，最后按 　　　 这样就可以在下列5行中每一行开头插入###　　　 插入字符位置插入 Command Alias i 在光标之前插入 a 在光标之后追加 删除字符删除 Command Alias x 删除光标所在处字符 X 删除光标所在前字符 ### 单词删除 Command Alias :———- :——– dw 删除到下一个单词开头 de 删除到本单词末尾 dE 删除到本单词末尾包括标点在内 db 删除到前一个单词 dB 删除到前一个单词包括标点在内 dt) 删除到)之前所有内容 df) 删除光标包括)所有内容 dT) 删除光标到光标前)所有内容 dF) 删除光标到光标前包括)所有内容 ### 行删除 Command Alias :———- :——– dd 删除一整行 3dd 删除三整行 D d$ 删除光标位置到本行结尾 d0 删除光标位置到本行开头 ### 标点内删除 Command Alias :———- :——– ci( 更改配对标点符号中的文本内容 di[ 删除配对标点符号中的文本内容 yi{ 复制配对标点符号中的文本内容 vi&lt; 选择配对标点符号中的文本内容 ### 带标点删除 Command Alias :———- :——– ca( 更改配对标点符号中的文本内容和标点 da[ 删除配对标点符号中的文本内容和标点 ya{ 复制配对标点符号中的文本内容和标点 va&lt; 选择配对标点符号中的文本内容和标点 ## 复制 ### 行复制 Command Alias :———- :——– y^ 复制至行首 y$ 复制至行尾 yy 复制整行 yH 从当前行复制到屏幕顶端 yL 从当前行复制到屏幕低端 ### 单词和字符复制 Command Alias :———- :——– ynl 向右复制n个字符 ynh 向左复制n个字符 ynw 向前复制n个单词 ynb 向后复制n个单词 yiw 复制一个单词 diw 剪切一个单词 ## 修改 ### 字符替换 Command Alias :———- :——– r 单个字符替换 R 连续替换 ~ 更改大小写 ### 单词修改 Command Alias :———- :——– cw 从光标处修改到单词结尾 cb 从光标处修改到单词开头 ciw 改写整个单词 ### 行修改 Command Alias :———- :——– c$ 从光标修改到本行末尾 C 功能同上 c0 从光标修改到本行开头 cc 删除整行从头修改 S 功能同上 s 删除光标所在位置的字符，然后插入 ## 运算 Command Alias :———- :——– 对数字加操作 对数字减操作 {count} 加上 [count] 如果当前光标不在数字上，则正向查找第一个数字 ## 合并行 ### 多行合并成一行 AAAAA BBBBB CCCCC 合并为:AAAAA BBBBB CCCCC 方法1: normal状态下 3J 其中的3是范围,可以是书签或者搜索位置等方式实现,J为合并注: 如果改为3gJ的话,则合并时各行没有空白AAAAABBBBBCCCCC, 下面方法类似,不再重复这两种合并方式的区别. 方法2: 命令状态下 :1,3 join 或 :1,3 j 方法3: 传统一点的,替换换行符的方式,为避免最后一行也被换掉,范围缩小了,命令状态下 :1,2s/\\n/ / 隔行合并AAAAABBBBBCCCCCDDDDD合并为: AAAAA BBBBBCCCCC DDDDD方法1: 借用一下宏录制功能, normal状态下 qaJjq 实现录制, 然后在合适的区域重复执行n遍,这里2遍即可,normal状态下2@a 方法2: 命令状态下 :1,4g/^/ join 增加了g过滤后,合并变成了隔行处理】 替换 Command Alias :s/old/new/ 替换当前行第一个 old 为 new :s/old/new/g 替换当前行所有 old 为 new :n,$s/old/new/ 替换第 n 行开始到最后一行中每一行的第一个 old 为 new :n,$s/old/new/g 替换第 n 行开始到最后一行中每一行所有 old 为 new :%s/old/new/ 替换每一行的第一个 old 为 new :%s/old/new/g 替换每一行中所有 old 为 new 恢复 Command Alias u 撤消上次命令 U 恢复整行 ctrl+r 重做 . 重复 e! 全文恢复 多窗口打开 Command Alias :vs file 在新的垂直分屏中打开文件 :sv file 在新的水平分屏中打开文件 Pattern 操作 Command Example Description /{pattern}[/] /hello 向前查找第一次出现 hello 的位置 /{pattern}/{offset} /hello/2 向前查找第一次出现 hello 的位置，并向下移动两行 / / 使用上次的模式，向前查找 //{offset} //3 使用上次的模式，偏移值为3，偏移值为空和/功能一致 ?{pattern}[?] ?hello 向后查找第一次出现 hello 的位置 ?{pattern}?{offset} ?hello?2 向后查找第一次出现 hello 的位置，并向下移动两行 ? ? 使用上次的模式，向后查找 ??{offset} ??3 使用上次的模式，偏移值为3，偏移值为空和/功能一致 n n 向前查找 N N 向后查找 * * 向前查找距离光标最近的单词 # # 向后查找距离光标最近的单词 gd gd 跳转至局部变量声明的位置 gD gD 跳转至全局变量声明的位置 使用宏 normal 模式下按下 qa 开始录制宏，a 就是该宏的，可以是任意字符 和正常使用 vim 一样，记录下需要的操作 操作完成后再次按下 q 结束录制 @a：当前行使用该宏，3@a：重复使用三次该宏，@@：对上次宏的重复使用","link":"/2017/02/14/VIM%E6%93%8D%E4%BD%9C/"},{"title":"搭建CI环境","text":"Jenkins 是一款领先的开源自动化服务器，提供了数百个插件来支持任何项目的构建，部署和自动化 前往官网下载最新的 war 包，war 包使用起来比起安装到系统中方便一些，这篇文章中用到的是 2.46.2 版本的 war 包 启动命令： 12# --httpPort 参数可以指定启动的端口，避免端口冲$ java -jar jenkins.war --httpPort=1111 初次进入 Jenkins 时需要初始密码，密码会在启动日志中打印出来： 123456Jenkins initial setup is required. An admin user has been created and a password generated.Please use the following password to proceed to installation:f1bfd39676da4339afbb93dd3e07606bThis may also be found at: /home/.jenkins/secrets/initialAdminPassword 进入以后会有两个选项，建议选择左边的一个，会安装一些常用的插件，然后就是创建账号，创建账号的时候命令行可能会报 403 错误码，此时需要进入 系统管理 -&gt; Configure Global Security，关闭 防止跨站点请求伪造 选项 进入首页之后，需要在 Global Tool Configuration 中配置 JDK、Gradle 信息 JDK和Gradle的配置最好跟项目中使用的相同，我的配置如下： 编译 Android 项目怎么能少得了 SDK，SDK 的配置需要到 系统设置 中配置： 在 全局属性 中增加键值对，我的配置如下： 随便配置一下插件 Extended E-mail Notification： 到此，编译环境配置完成，接下来需要创建项目并配置项目，首先点击新建创建一个自由风格的软件项目： 创建完成后会自动跳转到项目的配置界面，里面有很多的配置项，该文章只介绍一些必须的配置项，日后会陆续更新补充 配置源码管理 点击 Add 按钮可以添加密钥： 配置构建触发器 配置 Gradle点击 增加构建步骤，选择图中选项： 具体配置： Tasks 选项里面的内容可以根据自己的需求填写 邮箱通知插件全局的邮件插件已经配置过了，现在需要在项目中进行具体的配置，配置步骤很简单： 邮件通知内容模板： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;${ENV, var=&quot;JOB_NAME&quot;}-第${BUILD_NUMBER}次构建日志&lt;/title&gt;&lt;/head&gt;&lt;body leftmargin=&quot;8&quot; marginwidth=&quot;0&quot; topmargin=&quot;8&quot; marginheight=&quot;4&quot; offset=&quot;0&quot;&gt; &lt;table width=&quot;95%&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; style=&quot;font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif&quot;&gt; &lt;tr&gt; &lt;td&gt;(本邮件是程序自动下发的，请勿回复！)&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;h2&gt; &lt;font color=&quot;#0000FF&quot;&gt;构建结果 - ${BUILD_STATUS}&lt;/font&gt; &lt;/h2&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;br /&gt; &lt;b&gt;&lt;font color=&quot;#0B610B&quot;&gt;构建信息&lt;/font&gt;&lt;/b&gt; &lt;hr size=&quot;2&quot; width=&quot;100%&quot; align=&quot;center&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;ul&gt; &lt;li&gt;项目名称&amp;nbsp;：&amp;nbsp;${PROJECT_NAME}&lt;/li&gt; &lt;li&gt;项目描述&amp;nbsp;：&amp;nbsp;${JOB_DESCRIPTION}&lt;/li&gt; &lt;li&gt;构建编号&amp;nbsp;：&amp;nbsp;第${BUILD_NUMBER}次构建&lt;/li&gt; &lt;li&gt;触发原因：&amp;nbsp;${CAUSE}&lt;/li&gt; &lt;li&gt;下载地址：&amp;nbsp;http://fir.im/t6k7&lt;/li&gt; &lt;li&gt;构建日志：&amp;nbsp;&lt;a href=&quot;${BUILD_URL}console&quot;&gt;${BUILD_URL}console&lt;/a&gt;&lt;/li&gt; &lt;li&gt;构建&amp;nbsp;&amp;nbsp;Url&amp;nbsp;：&amp;nbsp;&lt;a href=&quot;${BUILD_URL}&quot;&gt;${BUILD_URL}&lt;/a&gt;&lt;/li&gt; &lt;li&gt;项目&amp;nbsp;&amp;nbsp;Url&amp;nbsp;：&amp;nbsp;&lt;a href=&quot;${PROJECT_URL}&quot;&gt;${PROJECT_URL}&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;b&gt;&lt;font color=&quot;#0B610B&quot;&gt;Changes Since Last Successful Build:&lt;/font&gt;&lt;/b&gt; &lt;hr size=&quot;2&quot; width=&quot;100%&quot; align=&quot;center&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;ul&gt; &lt;li&gt;历史变更记录 : &lt;a href=&quot;${PROJECT_URL}changes&quot;&gt;${PROJECT_URL}changes&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; ${CHANGES_SINCE_LAST_SUCCESS,reverse=true, format=&quot;Changes for Build #%n:&lt;br /&gt;%c&lt;br /&gt;&quot;,showPaths=true,changesFormat=&quot;&lt;pre&gt;[%a]&lt;br /&gt;%m&lt;/pre&gt;&quot;,pathFormat=&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;%p&quot;} &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;b&gt;&lt;font color=&quot;#0B610B&quot;&gt;构建日志 (最后 100行):&lt;/font&gt;&lt;/b&gt; &lt;hr size=&quot;2&quot; width=&quot;100%&quot; align=&quot;center&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!-- &lt;tr&gt; &lt;td&gt;Test Logs (if test has ran): &lt;a href=&quot;${PROJECT_URL}ws/TestResult/archive_logs/Log-Build-${BUILD_NUMBER}.zip&quot;&gt;${PROJECT_URL}/ws/TestResult/archive_logs/Log-Build-${BUILD_NUMBER}.zip&lt;/a&gt; &lt;br /&gt; &lt;br /&gt; &lt;/td&gt; &lt;/tr&gt; --&gt; &lt;tr&gt; &lt;td&gt;&lt;textarea cols=&quot;80&quot; rows=&quot;30&quot; readonly=&quot;readonly&quot; style=&quot;font-family: Courier New&quot;&gt;${BUILD_LOG, maxLines=100}&lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 上传APK到fir官方文档在这里 这里具体介绍一下怎么上传 git 中的 commit 信息到fir，需要用到 Environment Injector Plugin 插件，具体步骤如下： 输出 commit 文件内容，增加构建步骤 -&gt; Execute shell -&gt;在Command输入以下内容（注意替换Jenkins的username，password，IP，端口）： 12CHANGELOG=$(curl -u username:password &quot;http://localhost:8080/job/$JOB_NAME/$BUILD_NUMBER/api/xml?wrapper=changes&amp;xpath=//changeSet//comment&quot; | sed -e &quot;s/&lt;\\/comment&gt;//g; s/&lt;comment&gt;//g; s/&lt;\\/*changes&gt;//g&quot; | sed &apos;/^$/d;G&apos;)echo CHANGELOG=$CHANGELOG &gt; change_log_vars 设置 commit 文件参数：增加构建步骤-&gt;Inject environment variables-&gt;在Properties File Path输入change_log_vars 输出 commit 作者文件内容：增加构建步骤-&gt;Execute shell-&gt;在Command输入以下内容： 12CHANGEAUTHOR=$(curl -u username:password &quot;http://localhost:8080/job/$JOB_NAME/$BUILD_NUMBER/api/xml?wrapper=changes&amp;xpath=//changeSet//fullName&quot; | sed -e &quot;s/&lt;\\/fullName&gt;//g; s/&lt;fullName&gt;//g; s/&lt;\\/*changes&gt;//g&quot; | sed &apos;/^$/d;G&apos;)echo CHANGEAUTHOR=$CHANGEAUTHOR &gt; change_author_vars 设置 commit 作者文件参数：增加构建步骤-&gt;Inject environment variables-&gt;在Properties File Path输入change_author_vars 最后设置到 fir 插件中：增加构建后操作步骤-&gt;Upload to fir.im，然后在Build Notes中输入: 12$CHANGELOGby $CHANGEAUTHOR最后上一张 fir 插件的配置图： 上传 APK 到蒲公英官方文档在这里 蒲公英采用脚本的方式上传 APK 文件，官方文档只提供了一行命令，其中的参数需要自行查找： 12# 官方提供$ curl -F &quot;file=@/tmp/example.apk&quot; -F &quot;uKey=&quot; -F &quot;_api_key=&quot; https://qiniu-storage.pgyer.com/apiv1/app/upload 需要注意的是 @ 符号是必须的，然后查找 uKey 和 _api_key 参数： step1查看个人资料： step2查看 User Key 和 API Key ，User Key 就是 Ukey，API Key 就是 _api_key： 12# WORKSPACE 就是当前的工作空间，默认是项目根目录$ curl -F &quot;file=@/${WORKSPACE}/app.main/build/outputs/apk/lovedev.apk&quot; -F &quot;uKey=000000000000000&quot; -F &quot;_api_key=000000000000000&quot; https://qiniu-storage.pgyer.com/apiv1/app/upload Docker 安装 Jenkins利用 docker search jenkins 命令搜索出来带有 OFFICIAL 标识，其实是已经启用的版本，第二个 jenkins/jenkins 才是官方正在维护的版本，在 Jenkins 文档 已经指明，本来按照官方文档一步步操作，运行起来应该完全没有问题： 12345# 1. pull 镜像$ docker pull jenkins/jenkins# 2. run$ docker run --name jenkins -p 8080:8080 -p 50000:50000 jenkins/jenkins:lts 事与愿违，我的容器是部署在京东云上的，暂时没有验证是不是跟这个有关，无论如何都访问不了，一直卡在启动页面，后来终于把 docker 容器的网络模式改为了 host 模式 才得以解决： 12# -u root 以 root 用户运行，避免权限问题$ docker run -u root --name jenkins --net=host -v /root/jenkins_home:/var/jenkins_home jenkins/jenkins:lts 常见问题构建失败12345678Fix the issues identified by lint, or add the following to your build script to proceed with errors:...android { lintOptions { abortOnError false }}...已经提示了怎么处理该错误，在 Gradle 文件中加入提示的代码即可 测试邮件发送失败123456789101112131415Failed to send out e-mailjavax.mail.AuthenticationFailedException: 535 Error: authentication failed at com.sun.mail.smtp.SMTPTransport$Authenticator.authenticate(SMTPTransport.java:809) at com.sun.mail.smtp.SMTPTransport.authenticate(SMTPTransport.java:752) at com.sun.mail.smtp.SMTPTransport.protocolConnect(SMTPTransport.java:669) at javax.mail.Service.connect(Service.java:317) at javax.mail.Service.connect(Service.java:176) at javax.mail.Service.connect(Service.java:125) at javax.mail.Transport.send0(Transport.java:194) at javax.mail.Transport.send(Transport.java:124) at hudson.tasks.Mailer$DescriptorImpl.doSendTestMail(Mailer.java:581) at java.lang.invoke.MethodHandle.invokeWithArguments(MethodHandle.java:627) at org.kohsuke.stapler.Function$MethodFunction.invoke(Function.java:343)认证失败，注意配置邮箱的密码并不是登录密码，而是授权码","link":"/2017/05/23/%E6%90%AD%E5%BB%BACI%E7%8E%AF%E5%A2%83/"},{"title":"搭建私有 Maven 仓库","text":"出于项目需求，需要在公司内部服务器搭建私有的 maven 仓库，如果真的从零开始搭建，虽然不至于麻烦，但是还需要耗费时间配置各种参数和环境，这个时候就需要掏出神器一般的 Docker 了，这里采用最新版 Nexus3 来搭建，如果不懂 Docker 的同学可以参考我另外一篇文章 搭建环境12345# 1. Docker 下载镜像$ docker pull sonatype/nexus3# 2. 运行镜像，-v 参数是指定磁盘映射，需根据自己情况设置，也可以不用$ docker run -d -p 8081:8081 --name nexus --restart always -v /root/nexus:/nexus-data sonatype/nexus3 访问 localhost:8081 ，出现如下页面：至此已经搭建完成，超级简单有没有！！！ 配置仓库Nesus 的默认账户：admin，默认密码：admin123 登录后点击小齿轮进入设置页面： 接着点击 Repository 点击 Create repository 选择 maven2(hosted) 字样的选项这里简单介绍一下仓库类型： Hosted（主机）：接受本地提交依赖包到仓库，一般用于公司私仓的搭建 Proxy（代理）：可以作为其他站点依赖包的代理，一般用于加速公司项目共同使用的开源库 Group（仓库组）：统一管理多个仓库 填写仓库配置 推荐 Release 和 Snapshot 都创建一个，至此仓库已经创建完毕，具体的使用会在后续文章中进行介绍","link":"/2017/12/15/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89-Maven-%E4%BB%93%E5%BA%93/"},{"title":"ANR 总结","text":"引起 ANR 的原因： 当 Activity 在前台时，在 5S 内没有响应触摸事件，或者 BroadcastReceiver 事件 当 Activity 后台运行时， BroadcastReceiver 中 onReceive() 函数在特定时间内没有执行完 常见场景： 主线程执行耗时操作，比如数据库操作，I/O操作 主线程等待子线程释放锁，导致无法及时响应用户的操作事件 主线程上进行长时间的计算 主线程通过 Binder 进行进程间通讯，其他进程长时间不返回结果 严格模式使用严格模式可以在开发应用程序时在主线程上查找意外的I / O操作。可以在 Application 或 Activity 级别使用严格模式，配置方法： 123456789StrictMode.setThreadPolicy(StrictMode.ThreadPolicy.Builder() .detectAll() .penaltyLog() .build())StrictMode.setVmPolicy(StrictMode.VmPolicy.Builder() .detectAll() .penaltyLog() .penaltyDeath() .build())当检测到违反规定的操作时，就会在 logcat 中打印日志 开启后台 ANR Dialog当程序在后台运行时，有时候并不会弹出 ANR 弹窗，此时需要在开发者选项中启用显示所有“应用程序无响应”选项 BlockCanaryBlockCanary 可以有效监控主线程上各种卡慢问题，定位问题并避免出现 ANR，具体使用方法参考官方文档 traces 文件每次 ANR 都会生成一个 /data/anr/traces.txt 文件，可以根据该文件内容分析出来导致 ANR 的原因","link":"/2018/07/16/Android/ANR-%E6%80%BB%E7%BB%93/"},{"title":"Android 内存泄漏总结","text":"","link":"/2018/07/19/Android/Android-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%80%BB%E7%BB%93/"},{"title":"Android架构组件WorkManager","text":"WorkManager 可以更容易的执行可延迟的异步任务，可以创建一个任务交给 WorkManager 立即执行或者在合适的时间执行。WorkManager 会自己选择一个合适的方式运行任务，当 App 在前台运行时，WorkManager 会在一个新的线程中运作该任务；如果 App 没有运行，可以不用谢任何逻辑代码，WorkManager 就可以根据项目的依赖以及设备 API 级别选择一个合适的方式运行任务，WorkManager 可以用 JobScheduler, Firebase JobDispatcher 或者 AlarmManager WorkManager 还有一个惊人的功能，在退出程序后依然能够运行之前添加的任务 利用 WorkManager 可以很容易的把一个在指定条件下才执行的任务交给系统运行，WorkManager 需要 compileSdk 版本至少为 28 才能使用： 1234567891011dependencies { def work_version = &quot;1.0.0-alpha07&quot; implementation &quot;android.arch.work:work-runtime:$work_version&quot; // use -ktx for Kotlin // optional - Firebase JobDispatcher support implementation &quot;android.arch.work:work-firebase:$work_version&quot; // optional - Test helpers androidTestImplementation &quot;android.arch.work:work-testing:$work_version&quot;} 下面是 WorkManage 中几个比较重要的类： Worker：用来执行任务的类，这是一个抽象类，需要继承该类 WorkRequest：定义一个任务，可以指定用哪个 Worker 来执行该任务，也可以添加执行该任务的条件。每一个 WorkRequest 都会生成一个唯一 ID；可以使用这个 ID 取消任务或者获取任务当前状态，这也是一个抽象类，它有两个子类可以使用， OneTimeWorkRequest 和 PeriodicWorkRequest，从命名上就能区分出来两个类的区别，一个执行单次任务，一个执行循环任务 WorkRequest.Builder：如果不想用定义好的子类，同样也可以利用它来创建一个 WorkRequest Constraints：用来指定任务运行的条件，通过 Constraints.Builder 来创建，在创建 WorkRequest 之前把 Constraints 传递给 WorkRequest.Builder 即可 WorkManager：存放和以及管理任务 WorkStatus：包含任务的一些信息，WorkManager 会为每一个 WorkRequest 提供一个 LiveData，该 LiveData 持有一个 WorkStatus 对象，观察该 LiveData 就能获取任务当前状态以及返回值 基本用法执行任务项目中需要定时检测本地日志文件的大小，如果过大就删除。之前的解决方案用的是 RxJava 的 interval 操作符，现在换成使用 WorkManager 看看有什么区别，首先定义一个继承了 Worker 的类： 12345678910class CheckFileSizeWorker : Worker() { override fun doWork(): Result { checkFileSize() return Result.SUCCESS } private fun checkFileSize() { println(&quot;checkFileSize&quot;) }} doWork 函数的返回值中一共有三个状态 Result.SUCCESS、Result.FAILUER 和 Result.RETRY 12val checkFillSizeWorker = OneTimeWorkRequest.Builder(CheckFillSizeWorker::class.java).build()WorkManager.getInstance().enqueue(checkFillSizeWorker) 获取状态使用 OneTimeWorkRequest 创建一个任务，如果不指定一个执行条件，这个任务会立即执行，可以通过这个任务的 ID 来获取该任务的状态： 1234WorkManager.getInstance().getStatusById(checkFillSizeWorker.id) .observe(this, Observer { println(it) })如果使用 PeriodicWorkRequest 来执行循环任务，有几个问题需要注意。它默认循环的最小间隔是15分钟，其中还有一个 叫做 flexInterval 的参数，最小间隔是5分钟，且不能超过循环间隔时间。这个参数是用来指定一个弹性时间，举个栗子说明一下，如果使用默认的参数，那么这个循环任务其实不是刚好过15分钟就执行，而是通过循环间隔时间减去这个弹性时间，也就是10分钟后才是任务开始执行的时间，WorkManager 会在前一个任务结束的10分钟到15分钟之间执行下一个任务 设置执行条件接下来给这个任务指定一个执行条件，这个时候就需要用到 Constraints 这个类了： 123456// 还有电量是否低，是否正在充电，设备是否空闲等条件val constraints = Constraints.Builder() .setRequiresDeviceIdle(true) .build() val checkFillSizeWorker = OneTimeWorkRequest.Builder(CheckFillSizeWorker::class.java).setConstraints(constraints).build() 取消任务通过任务的 ID 来取消该任务： 1WorkManager.getInstance().cancelWorkById(checkFillSizeWorker.id)如果想要取消一组任务，需要给这些任务指定了一个 tag，通过 cancelAllWorkByTag 函数来取消","link":"/2018/08/23/Android/Android%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6WorkManager/"},{"title":"Groovy 入门","text":"Apache Groovy是一种强大的，可选择类型和动态的语言，具有静态类型和静态编译功能，对于旨在通过简洁，熟悉和易于学习的语法提高开发人员生产力的Java平台。 它可以与任何Java程序顺利集成，并立即为您的应用程序提供强大的功能，包括脚本功能，特定于域的语言编写，运行时和编译时元编程和函数式编程。 安装最简单无脑的方式： 1$ brew install groovy IDE 推荐 Intellij IDEA，支持自动补全，API 文档以及源码查看，Mac 上需要配置 Groovy SDK，通过 brew 安装的 Groovy SDK 路径为 /usr/local/Cellar/groovy/2.4.15/libexec，该文件夹是隐藏的需要执行 ⌘+⇧+. 显示出隐藏文件夹才能选择该目录 基本语法单引号、双引号、三单引号、三双引号单引号和双引号的都可以互相在内部嵌套： 12&apos;Hello &quot;World&quot;&apos;&quot;Hello &apos;World&apos;&quot; 它们的区别在于单引号中不能使用表达式，同样也不能使用转义符，双引号则可以三单引号和三双引号在单引号和双引号的基础上多了支持原样输出的功能 类型Groovy 同时支持动态类型和静态类型，所以它定义变量的方式也会有很多种： 1234x = 1def y = 2int z = 3def int w = 4 循环支持 while、for、for-in、upto 1234567891011121314// $it 表示当前索引，起始位置是 1 到 101.upto(10){ println &quot;this is $it&quot;}// $it 表示当前索引，起始位置是 0 到 1010.times { println(&quot;this is $it&quot;);}// $it 表示当前索引，起始位置是 2，步进是 2，不包含 102.step(10,2){ println(&quot;this is $it&quot;);} as 关键字在Groovy语言中，进行强制类型转换使用的是 as 加上要转换的类型 12List list = [&apos;a&apos;,&apos;b&apos;]ArrayList list1 = list as ArrayList 方法方法可以接收任意数量的参数，且可以设置参数的默认值。定义参数时，不必显式定义类型。可以添加修饰符，如public，private和protected。默认情况下，如果未提供可见性修饰符，则该方法为public 123456789101112131415161718192021222324252627282930313233343536373839404142// 函数的写法def method(){ println &quot;Hello&quot;}// 带有返回值函数写法def print(){ return &quot;Hello&quot;}// 可以省略return关键字def methodWithRetrnKeywords(){ &quot;Hello&quot;}// 同java一样，return后的语句不执行def methodWithRetrnKeywords2(){ return &quot;Hello&quot; println &quot;i can&apos;t run&quot;}// 这是一个错误的示例，这种情况不能省略 returndef methodWithRetrnKeywords3(){ &quot;Hello&quot; println &quot;i can&apos;t run&quot;}// 带有参数默认值的方法定义，该参数是可选的def paramsWithDefaultValue(num = 100) { println num}// Groovy还把最后一个为数组的形参视为可选的def task(name,String[] details){ println &quot;$name - $details&quot;}def printName(name) { println name}// 可以省略括号直接调用printName &apos;kevin&apos; IO提供一个 IO 的工具类 FileUtil.groovy： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 读取文件内容def readFile(fileName) { File newFile = new File(fileName) return newFile.text}def writeFile(fileName, content) { if (!isFileExist(fileName)){ return false } new File(fileName).withWriter(&apos;utf-8&apos;) { writer -&gt; writer.writeLine content }}def writeFileAppend(fileName, content) { if (!isFileExist(fileName)){ return false } new File(fileName).withWriterAppend(&apos;utf-8&apos;) { writer -&gt; writer.writeLine content }}def isFileExist(fileName){ file = new File(fileName) return file.isFile()}def isDirectory(fileName){ return new File(fileName).isDirectory()}def mkdirDir(fileName){ return new File(fileName).mkdir()}def delFile(fileName){ return new File(fileName).delete()}def copyFileContent(targetFileName, copyFileName){ file = new File(targetFileName) copyFile = new File(copyFileName) return file &lt;&lt; copyFile.text}def getFileSize(fileName){ return new File(fileName).length()}def getFileAbsolutePath(fileName){ return new File(fileName).absolutePath} 引用外部脚本文件如果想要在一个 Groovy 脚本中调用另一个 Groovy 脚本中的函数，需要注意： 12345678910// 直接包含了另外一个 groovy 文件内容evaluate(new File(&quot;fileName&quot;))// 如果是同级目录调用另外一个 groovy 脚本fileUtil = new FileUtil()println fileUtil.readFile(&quot;fileName&quot;)// 如果不是同级目录，则需要在被引用的 groovy 脚本中加入 package 声明，声明为项目绝对路径即可util = new utils.Util()println util.readFile(&quot;fileName&quot;) 范围 1..10 - 包含范围的示例 1 .. &lt;10 - 独占范围的示例 ‘a’..’x’ - 范围也可以由字符组成 10..1 - 范围也可以按降序排列 ‘x’..’a’ - 范围也可以由字符组成并按降序排列 列表 [11，12，13，14] - 整数值列表 [‘Angular’，’Groovy’，’Java’] - 字符串列表 [1，2，[3，4]，5] - 嵌套列表 [‘Groovy’，21，2.11] - 异构的对象引用列表 [] - 一个空列表 Map [‘TopicName’：’Lists’，’TopicName’：’Maps’] - 具有TopicName作为键的键值对的集合及其相应的值 [：] - 空映射 特征它们可以被看作是承载默认实现和状态的接口，使用 trait 关键字定义trait 1234567891011121314trait IUser { def getName() { println &apos;Kevin&apos; }}class User implements IUser {}user = new User()user.getName()// output：kevin 安全导航操作符 - ?.安全导航（safe-navigation）操作符（?.）在安全的情况下才会去调用指定的方法或者属性 1234567891011class Userc { def i = 1000}user = new User()user.getName()user = null// output nullprintln user?.i// throw NullPointerExceptionprintln user.i 枚举123enum CoffeeSize { SHORT, SMALL, MEDIUM, LARGE, MUG} 函数1234567891011String getString(){ return &quot;hello world&quot;}def getDef(){ return &quot;hello world&quot;}void printSomething(){ println &quot;hello worlld&quot;} 闭包闭包是一个短的匿名代码块。一个方法可以将闭包作为参数 12345678910111213141516171819202122232425262728name = &apos;kevin&apos;def clo = {params -&gt; println &quot;$params + $name&quot;}def getUser(name, Closure clo) { clo.call(name)}// 声明了变量的闭包getUser(&apos;hello&apos;, clo)// 匿名闭包getUser(&apos;world&apos;, {params -&gt; println &quot;$params + $name&quot;})// 如果闭包只有一个参数，就可以用 it 这个特殊的参数名来代表getUser(&apos;world&apos;, {println &quot;$it + $name&quot;})// 如果最后一个参数是闭包，可以将闭包附加到方法调用上getUser(&apos;world&apos;){println &quot;$it + $name&quot;}// 如果函数只有一个参数且是闭包，调用该函数时可以直接省略小括号def withoutParams(Closure closure){ closure.call(&apos;Hello World&apos;)}withoutParams { println &quot;this is $it&quot;}","link":"/2018/05/28/Android/Groovy-%E5%85%A5%E9%97%A8/"},{"title":"Android 开发常见问题总结","text":"解决无限 This file is indented with tabs instead of 4 spacesFile -&gt; Settings -&gt; Editor -&gt; Code Style -&gt; Java -&gt; Tabs and Indents -&gt; 勾选Use tab character选项 配置阿里Maven仓库加速Gradle构建12345allprojects { repositories { maven{ url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos;} }} 升级Andorid Studio 2.3.0无法使用Instant run1This version of Android Studio is incompatible with the Gradle Plugin used. Try disabling Instant Run (or updating either the IDE or the Gradle plugin to the latest version) 关闭Instant Run即可 卡在Building XXX Gradle project info方式一项目中gradle-wrapper-gradle-wrapper.properties文件distributionUrl字段是编译项目所用的Gradle，如果本地没有这个Gradle版本，需要从网络上下载，下载速度极其感人。 把distributionUrl字段的值改为本地已有的Gradle版本即可，例如： 1distributionUrl=file\\:/Users/Kevin/Workspaces/Gradle/gradle-3.4.1-all.zip 由于每次都要修改distributionUrl字段，不符合一个追求完美的程序员的作风。 方式二 新建一个项目在里面查找：gradle-wrapper.properties这个文件，看到：distributionUrl=https\\://services.gradle.org/distributions/gradle-xxx-all.zip；这里说明推荐gradle版本需要用xxx版本 自己上网下载到这个包：gradle-xxx-all.zip进入目录/Users/xxx/.gradle/wrapper/dists/gradle-2.14.1-all/8bnwg5hd3w55iofp58khbp6yv，（8bnwg5hd3w55iofp58khbp6yv这个文件夹各个机器不一样），将里面的东西全部删掉 将下载的gradle-2.14.1-all.zip放到这里 重新启动android studio，gradle将会顺利通过。 gradle替换AndroidManifest中的占位符1234567891011121314&lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;${appName}&quot; //占位符 android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt; 1234567buildTypes { debug { manifestPlaceholders = [appName: appNames.watch] //赋值占位符 minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; } } java.util.concurrent.ExecutionException123456Error:Execution failed for task &apos;:app.main:transformClassesWithDexForDebug&apos;.com.android.build.api.transform.TransformException: com.android.ide.common.process.ProcessException: java.util.concurrent.ExecutionException: com.android.ide.common.process.ProcessException: Error while executing java process with main class com.android.dx.command.Main with arguments {--dex --num-threads=4 --multi-dex --main-dex-list /Users/Kevin/AndroidStudioProjects/Shine/NurseStationPhone/app.main/build/intermediates/multi-dex/debug/maindexlist.txt --output /Users/Kevin/AndroidStudioProjects/Shine/NurseStationPhone/app.main/build/intermediates/transforms/dex/debug/folders/1000/1f/main /Users/Kevin/AndroidStudioProjects/Shine/NurseStationPhone/app.main/build/intermediates/transforms/jarMerging/debug/jars/1/1f/combined.jar} 在 gradle.properties 中增加如下配置： 1org.gradle.jvmargs=-Xmx10248m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8 java.lang.NoClassDefFoundError: rx.plugins.RxJavaPlugins来自 stackOverflow 的翻译： 该问题可能是没有初始化 Multidex 选项导致的： Android 5.0 之后的版本支持 Multidex5.0 之后的 Android 版本用了一个叫做 ART 的运行时，它支持从 APK 文件中加载多 dex ，ART 在应用初始化的时候执行预编译，扫描 classes(..N).dex 文件并且编译它们为一个 .oat 文件，用于 Android 设备执行，关于 Android 5.0 运行时更多的资料，请看ART 的介绍，App 能够在 API21 上正常工作就是这个原因 Android 5.0 之前的设备支持 MultidexAndroid 5.0 之前的平台用的是 Dalvik 运行时执行 App 代码的。默认情况下，Dalvik 限制每个 APK 只能是一个 classes.dex 字节码文件。为了绕过这个限制，可以使用 Multidex 的支持库，该支持库将会变成你应用程序主 DEX 文件的一部分，用来管理对附加 DEX 文件以及其包含代码的访问 如果出现了 java.lang.NoClassDefFoundError: rx.plugins.RxJavaPlugins 异常，首先确定一下设备的 Android 版本信息，如果低于 5.0，就可以采用一下方案解决： 首先导入 Multidex 支持库： 123dependencies { compile &apos;com.android.support:multidex:1.0.1&apos;} 自定义一个 application ，然后让它继承 MultiDexApplication，如下所示： 123public class CustomApp extends MultiDexApplication { ...} Build APK 报错Error:java.lang.OutOfMemoryError: GC overhead limit exceeded在 gradle.properties 文件中添加如下配置： 1org.gradle.jvmargs=-Xmx4096m -XX:MaxPermSize=4096m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8 mips64el-linux-android-strip A problem occurred starting process ‘command ‘/Users/Kevin/Library/Android/sdk/ndk-bundle/toolchains/mips64el-linux-android-4.9/prebuilt/darwin-x86_64/bin/mips64el-linux-android-strip’’ 官方 NDK 版本历史中的最新版已经移除了 MIPS 和 MIPS64，如果项目中有用到需要下载较低版本替换即可，Revision 16b中虽然已经废弃了，但是还存在，Revision 17c 中已经没有这个库了","link":"/2017/08/01/Android/Android-%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"},{"title":"Gradle 入门","text":"Gradle是一款专注于灵活性和性能的开源构建自动化工具。 Gradle构建脚本使用 Groovy 或 Kotlin DSL 编写，具有以下特点： 高度可定制 — Gradle以最基本的方式进行定制和扩展 快速 — Gradle通过重复使用先前执行的输出，仅处理已更改的输入以及并行执行任务来快速完成任务 强大 — Gradle是Android的官方构建工具，并且支持许多流行的语言和技术 安装一行命令搞定法： 123$ brew install gradle# 验证是否安装成功$ gradle -v 基础Projects &amp; tasks任何一个 Gradle 构建都是由一个或多个 projects 组成，每个 task 都代表了构建执行过程中的一个原子性操作。如编译，打包，生成 javadoc，发布到某个仓库等操作 Hello World1234567task hello { doLast { println &apos;hello world&apos; }}// Run：gradle -q hello 首先定义了一个叫做 hello 的 task doLast - Adds the given closure to the end of this task’s action list，可以从官方文档中看的出来，doLast 把参数中的闭包放到了所有 task 的最后执行 其中 -q 参数表示只打印错误信息，不会打印其他日志信息 需要注意的是下面 task 的写法： 123task why { println &quot;hello&quot;} 这种写法属于给当前文件中的任务增加共同行为 快速定义123task append &lt;&lt; { println &apos;hello world&apos;} &lt;&lt; 操作符不能理解为 Groovy 中的追加操作，必须理解为 doLast 的简单写法。需要的注意的是 doLast 默认会按顺序执行所在文件中所有的 task 任务依赖任务依赖主要用 dependsOn ，有两种用法，第一种为常规用法： 123456789101112task append &lt;&lt; { println &apos;append&apos;}task depend(dependsOn: append) &lt;&lt; { println &apos;depend&apos;}task compile(dependsOn: [append, denpend]) &lt;&lt; { println &apos;compile&apos;} 第二种是当被依赖的 task 声明在当前 task 之后的写法： 12345678// 注意区别，这里 task 名字加上了单引号task depend(dependsOn: &apos;append&apos;) &lt;&lt; { println &apos;depend&apos;}task append { println &apos;append&apos;} 动态创建任务使用 Groovy 循环方式也可以创建 task： 123451.upto(5){ task &quot;task_$it&quot; &lt;&lt; { println &quot;$it&quot; }} 使用已存在的 task12345678910111213task_1.dependsOn task_2, task_3task_1.doFirst { println &quot;do $task_1.name&quot;}task_1.doLast { println &quot;finish $task_1.name&quot;}task_1 &lt;&lt; { println &quot;finish $task_1.name again&quot;} task 属性12345678910111213// 其中 $task_1.name 就是默认的 task 属性task_1 &lt;&lt; { println &quot;finish $task_1.name again&quot;}// 自定义属性task config { ext.customName = &apos;kevin&apos;}task test &lt;&lt; { println config.customName} 默认 task使用 defaultTasks 定义默认 task，多个 task 使用逗号区分： 1defaultTasks &apos;append&apos;, &apos;hello&apos; 为不同 task 配置不同参数123456789101112131415161718192021222324252627282930313233File[] getFiles(dir) { file(dir).listFiles({file -&gt; file.isFile()} as FileFilter).sort()}// 获取文件内容task loadDirFile &lt;&lt; { def files = getFiles(&quot;$dir&quot;) if (files.length &gt; 0) { files.each { file -&gt; ant.loadfile(srcFile: file, property: file.name) println &quot;${ant.properties[file.name]}&quot; } }}// 生成校验值task checkSum &lt;&lt; { def files = getFiles(&quot;$dir&quot;) if (files.length &gt; 0) { files.each { file -&gt; ant.checksum(file: file, property: file.name) println &quot;${ant.properties[file.name]}&quot; } }}gradle.taskGraph.whenReady { task -&gt; if (task.hasTask(checkSum)) { ext.dir = &quot;..&quot; } else if (task.hasTask(loadDirFile)) { ext.dir = &quot;.&quot; }} Gradle Wrapper运行 Gradle Script 的推荐方式就是使用 Gradle Wrapper，先看一下 Gradle Wrapper 的工作流程： Wrapper是一个调用Gradle声明版本的脚本，如果需要的话可以事先下载。因此，开发人员可以快速启动并运行Gradle项目，不用担心本地 Gradle 版本和项目中使用的 Gradle 版本不一致导致一些不可预见的问题，从而节省公司的时间和金钱。 Gradle 命令行执行 gradle -h 可以查看所有参数以及描述 多任务调用123456789101112131415task compile &lt;&lt; { println &apos;compile&apos;}task compileTest(dependsOn: compile) &lt;&lt; { println &apos;compileTest&apos;}task runTest(dependsOn: [compile, compileTest]) &lt;&lt; { println &apos;runTest&apos;}task running(dependsOn: runTest) &lt;&lt; { println &apos;running&apos;}执行 gradle running compile 后的结果： 12345678910111213➜ gradle running compile &gt; Task :compilecompile&gt; Task :compileTestcompileTest&gt; Task :runTestrunTest&gt; Task :runningrunning 这是因为每个 task 只会执行一次，running 已经依赖了 compile，所以 compile 不会执行两次 排除任务 -x, –exclude-task Specify a task to be excluded from execution.指定一个 task 不执行 12345678910➜ gradle running -x compile&gt; Task :compileTestcompileTest&gt; Task :runTestrunTest&gt; Task :runningrunning 失败后继续执行 –continue Continue task execution after a task failure.当一个 task 失败后继续往后执行 简化任务名需要执行任务时，无须输入全部任务名，只需提供足够的可以唯一区分出该任务的字符即可 指定构建文件 -b, –build-file Specify the build file.指定一个构建文件 获取任务信息 tasks - Displays the tasks runnable from root project ‘gradle’获取任务新 1234// 获取所有的 task$ gradle -q tasks --all// 获取 task 的详细信息$ gradle help --task taskName 配置任务参数12345task hello { description = &quot;hello&quot; version = &quot;10.0.0&quot; group = &quot;build&quot;} 获取依赖信息针对 Android 项目的一个例子： 123456// 获取所有 projects$ gradle -q projects// 选择其中一个或多个获取它的依赖信息$ gradle -q app:dependencies lib:dependenices// 获取 Gradle 构建脚本的依赖项$ gradle buildEnvironment 获取指定依赖信息首先需要明白 configuration 的概念： What is a configuration? Every dependency declared for a Gradle project applies to a specific scope. For &gt; example some dependencies should be used for compiling source code whereas others only need to be available at runtime. Gradle represents the scope of a dependency with the help of a Configuration. Every configuration can be identified by a unique name. Many Gradle plugins add pre-defined configurations to your project. The Java plugin, for example, adds configurations to represent the various classpaths it needs for source code compilation, executing tests and the like. See the Java plugin chapter for an example. The sections above demonstrate how to declare dependencies for different use cases. 上面是官方的解释，简单翻译后可以理解为： 每个 Gradle 项目的依赖都有一个特定的范围，比如 implementation 以及 api，根据这些配置，Gradle 才能知道该怎么处理这些依赖。其实 implementation 以及 api 都是 Android 项目预定义的 configuration 12// 获取指定 configuration 的依赖信息$ gradle app:dependencies --configuration implementation 获取特定依赖报告123// --dependency 是具体依赖 --configuration 是依赖的具体配置，缺一不可$ gradle -q app:dependencyInsight --dependency com.facebook.stetho --configuration compileClasspath dependencyInsight 可以查看依赖深度报告，用来排查依赖冲突非常有效 获取属性1$ gradle -q app:properties 构建日志加上 --profile 参数就可以在根目录的 build/reports/profile 中生成一个以日期命名的日志文件： 1$ gradle -q --profile getConfigurationByName Dry Run只想知道某个任务在一个任务集中按顺序执行的结果，但并不想实际执行这些任务，可以使用 -m 参数： 1$ gradle -m build 给 JVM 添加参数1$ gradle -Dmyprop=mypropGradle 的 -D 参数和 Java 的 -D 参数功能一致 Gradle DSLDSL 的全称就是 Domain Specific Language（领域特定语言），通过例子可能会更好的理解： 正则表达式 - 按照指定规则编写字符串，是否匹配全交给了语言引擎来完成 SQL - 可以看作数据库领域的 DSL Markdown - 写作领域的 DSL 声明变量局部变量只在定义该变量的文件中有效的变量： 123456// build.gradledef value = &apos;kevin&apos;task getValue { println value} 额外属性额外属性可以通过所属对象的 ext 属性进行添加，读取和设置： 1234567891011121314151617// root/build.gradleext { value = &apos;world&apos;}ext.a = &apos;a&apos;ext.b = [1,2,3]ext.c = [:]c.a = &apos;c.a&apos;c.b = &apos;c.b&apos;// root/app/buidl.gradledef value = &apos;kevin&apos;task getValue &lt;&lt; { println &quot;Local variable is $value, Global variable is $c.a&quot;}同时也可以使用 gradle.properties 文件为 project 对象添加额外参数，如果当前目录中不存在配置文件，读取项目根目录中的配置文件 -P 参数设置属性： 12345// command: gradle -q -PcommandValue=hello2 getCommandValue// output: hello2task getCommandValue &lt;&lt; { println commandValue} -D 参数设置属性： 12345// command: gradle -q -DsystemValue=hello getSystemValue// output: hellotask getSystemValue &lt;&lt; { println System.getProperty(&quot;systemValue&quot;)} 通过系统变量设置属性，当有类似 ORG_GRADLE_PROJECT_propName=value 这样格式的系统变量时，Gradle 里面就可以使用 propName 属性，这样就可以设置一个： 1234567// command:// export ORG_GRADLE_PROJECT_value=kevin// gradle -q getSystemValue2// output: kevintask getSystemValue2 &lt;&lt; { println value} 还有一种情况是需要设置系统变量时，就可以通过 gradle.properties 文件来设置，如果该文件中有一个 systemProp. 为前缀的属性，该属性和它对应的值就会被添加到系统属性中，且不带前缀。需要注意的是，在多项目构建中，除了根目录的 systemProp. 属性，其他目录下的都将被忽略： 12345678// gradle.propertiessystemProp.helloWorld=hello// build.gradle// command: gradle -q getSystemValue// output: hellotask getSystemValue &lt;&lt; { println System.getProperty(&quot;helloWorld&quot;)} 如果同时在 gradle.properties 和命令行中都设置了同一个参数，则优先使用命令行中配置的参数 闭包委托修炼中… 使用外部构建脚本1234567891011// other.gradleext.otherValue=&apos;other&apos;ext.otherMethod={ println &quot;other.gradle#otherMethod&quot;}// build.gradleapply from: &apos;other.gradle&apos;task getOtherScriptValue &lt;&lt; { otherMethod() println otherValue} 缓存Gradle 默认缓存所有编译过的脚本，如果有脚本有改动重新编译并缓存，没有改动则使用缓存不进行编译。使用 --recompile-scripts 选项运行 Gradle 会强制丢弃缓存重新编译并缓存 Task定义任务123456789101112131415161718192021task myTask{ println &apos;myTask&apos;}task(myTask){ println &apos;myTask&apos;}task(&apos;myTask&apos;){ println &apos;myTask&apos;}task(myTask, type: Copy){ from &quot;.&quot; into &quot;..&quot; include &apos;*.gradle&apos;}tasks.create(name: &apos;createTask&apos;) { println &apos;crate task&apos;} 重写任务12345678910tasks.create(name: &apos;createTask&apos;) &lt;&lt; { println &apos;crate task&apos;}task createTask(overwrite: true) &lt;&lt; { println &apos;overwrite&apos;}// output: // override必须把 overwrite 属性设置为 true，否则会抛出 a task with that name already exists 的异常 自定义类型 Task123456789101112131415161718class CustomTask extends DefaultTask { String value = &apos;hello workd&apos; @TaskAction def init() { println &quot;i&apos;m custom task -- $value&quot; }}task customTask1(type: CustomTask)task customTask2(type: CustomTask) { value = &apos;custom prop&apos;}// command: gradle -q customTask2 hello// output: i&apos;m custom task -- custom prop// output: i&apos;m custom task -- hello workd 该任务添加一个方法并使用 @TaskAction 注释标记它。当任务执行时，Gradle将调用该方法 跳过任务onlyIfTypical usage:myTask.onlyIf{ dependsOnTaskDidWork() }，当闭包中的内容返回 true 时，才会执行该 Task： 12345678createTask.onlyIf { project.hasProperty(&apos;skip&apos;)}// command: gradle createTask// output: BUILD SUCCESSFUL in 0s// command: gradle -q createTask -Pskip// output: overwrite StopExecutionException123456789101112task compile &lt;&lt; { println &apos;We are doing the compile.&apos;}compile.doFirst { if (true) { throw new StopExecutionException() }}task myTask(dependsOn: &apos;compile&apos;) &lt;&lt; { println &apos;I am not affected&apos;} // command: gradle -q myTask// output: I am not affected Task enable 属性每个 task 都有一个值为 true 的 enable 属性，如果把这个属性设置为 false，则不会执行该 task 的任何操作 任务规则12345678910tasks.addRule(&quot;Pattern: ping&lt;ID&gt;&quot;) { String taskName -&gt; if (taskName.startsWith(&quot;ping&quot;)) { task(taskName) &lt;&lt; { println &quot;Pinging: &quot; + (taskName - &apos;ping&apos;) } }} // command: gradle -q pingHello// output: Pinging: Hello conventions vs extensions扩展是较新的概念，已在很大程度上取代了约定。简而言之，仅使用扩展名，而不使用约定。 日志等级 Level Feature ERROR 错误消息 QUIET 重要的信息消息 WARNING 警告 LIFECYCLE 进度 INFO 信息性消息 DEBUG 调试消息 日志命令参数 选项 输出 无 LIFECYCLE 及更高 –quiet QUIET 及更高 –info INFO 及更高 –debug DEBUG 及更高 堆栈跟踪参数 选项 含义 无 构建错误（如编译错误）时没有栈跟踪打印到控制台。只有在内部异常的情况下才打印栈跟踪。如果选择 DEBUG 日志级别，则总是输出截取后的栈跟踪信息 –stacktrace 输出截断的栈跟踪。我们推荐使用这一个选项而不是打印全栈的跟踪信息。Groovy 的全栈跟踪非常冗长 （由于其潜在的动态调用机制，然而他们通常不包含你的的代码中哪里错了的相关信息） –full-stacktrace 打印全栈的跟踪信息 打印日志12345678prinln &apos;log&apos;logger.quiet(&apos;An info log message which is always logged.&apos;)logger.error(&apos;An error log message.&apos;)logger.warn(&apos;A warning log message.&apos;)logger.lifecycle(&apos;A lifecycle info log message.&apos;)logger.info(&apos;An info log message.&apos;)logger.debug(&apos;A debug log message.&apos;)logger.trace(&apos;A trace log message.&apos;) 自定义 configuration12345678910111213configurations { custom}dependencies { custom &apos;com.facebook.stetho:stetho:1.5.0&apos;}task copyDependencies(type: Copy){ from configurations.custom into &apos;build/bins&apos;} 可以根据自定义的 configurations 做一些不一样的事情，比如把自定义 configurations 所依赖的库拷贝到指定的文件夹中 debug plugin只用改一个你想要的名字即可，其他参数不用变： 下好断点位置后，执行如下指令： 1$ ./gradlew assembleDebug -Dorg.gradle.daemon=false -Dorg.gradle.debug=true 看到这个提示后再执行 debug 操作： 自定义插件参考资料参考资料 官方 dsl demokts 配置 uploadArchives中文 demo 小技巧忽略debug版本12345variantFilter { variant -&gt; if(variant.buildType.name == &apos;debug&apos;) { setIgnore(true) }} 设置 apk 文件名称12345android.applicationVariants.all { variant -&gt; variant.outputs.all { outputFileName = &quot;${defaultConfig.applicationId}-${variant.productFlavors[0].name}.apk&quot; }} util.gradle总结了常用的一些工具函数 util.gradle ： 12345678910111213141516171819202122232425262728293031323334353637ext.getCurrentFlavor = { Gradle gradle = getGradle() String tskReqStr = gradle.getStartParameter().getTaskRequests().toString() Pattern pattern if (tskReqStr.contains(&quot;assemble&quot;)) pattern = Pattern.compile(&quot;assemble(\\\\w+)(Release|Debug)&quot;) else pattern = Pattern.compile(&quot;generate(\\\\w+)(Release|Debug)&quot;) Matcher matcher = pattern.matcher(tskReqStr) if (matcher.find()) { println matcher.group(1).toLowerCase() return matcher.group(1).toLowerCase() } else { println &quot;NO MATCH FOUND&quot; return &quot;&quot; }}ext.getCurrentBuildType = { Gradle gradle = getGradle() String tskReqStr = gradle.getStartParameter().getTaskRequests().toString() if (tskReqStr.contains(&quot;Release&quot;)) { println &quot;getCurrentBuildType release&quot; return &quot;release&quot; } else if (tskReqStr.contains(&quot;generateDebug&quot;)) { println &quot;getCurrentBuildType debug&quot; return &quot;debug&quot; } println &quot;NO MATCH FOUND&quot; return &quot;&quot;} build.gradle 中使用： 1234apply from: &apos;util.gradle&apos;task callOtherScriptMethod { getCurrentBuildType()} 实例讲了这么多，下面列举几个常见的 Gradle 配置： 加速Gradle构建阿里国内镜像，下载速度很快，从此告别添加依赖后再等上十分钟 12345allprojects { repositories { maven{ url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos;} }} 修改默认 apk 文件名很多时候需要通过 apk 的命名很直观的看到一些信息，比如版本号，渠道以及是否测试版等等，此时就需要修改 apk 文件名： 123456789101112131415buildTypes { ... applicationVariants.all { variant -&gt; variant.outputs.each { output -&gt; def outputFile = output.outputFile if (outputFile != null &amp;&amp; outputFile.name.endsWith(&apos;.apk&apos;)) { // 输出apk名称为LoveDev-v1.0.apk def fileName = &quot;LoveDev-v${defaultConfig.versionName}.apk&quot; output.outputFile = new File(outputFile.parent, fileName) } } } ...} 自动生成 versionCode 和 versionName1234567891011121314151617181920212223242526272829303132333435// versionCode : git commit 次数 ;// versionName : 大版本号.小版本号.修改版本号.编译版本号 ;// 获取 version codestatic def getVersionCode(boolean isDebug) { if (isDebug) { return Integer.parseInt(new Date().format(&quot;yyMMddHHmm&quot;)) } return getRevisionNumber()}// 获取 version namedef getVersionName(boolean isDebug) { String version = rootProject.ext.appmajor + &apos;.&apos; + rootProject.ext.appminor + &apos;.&apos; + getRevisionNumber() String today = new Date().format(&apos;yyMMdd&apos;) String time = new Date().format(&apos;HHmmss&apos;) if (isDebug) { return version + &quot;.$today.$time.&quot; + getRevisionDescription() } return version + &quot;.$today.&quot; + getRevisionDescription()}// 获取修订版本 git 提交次数static def getRevisionNumber() { Process process = &quot;git rev-list --count HEAD&quot;.execute() process.waitFor() return process.getText().toInteger()}// 获取修订版本最后一次 git 记录后6位static def getRevisionDescription() { String desc = &apos;git describe --always&apos;.execute().getText().trim() return (desc == null || desc.size() == 0) ? new Date().format(&quot;yyMMdd&quot;) : desc.substring(desc.size() - 6)} productFlavors 配置产品风味如果除了正式版，测试版之外还要继续细分化，针对不同的渠道，正式版要分为收费版，免费版等情况，这时候就需要用到 productFlavors 来配置了 将配置信息添加到 productFlavors {} 代码块并配置想要的设置。产品风味支持与 defaultConfig 相同的属性，这是因为 defaultConfig 实际上属于 ProductFlavor 类，我在实际项目中碰到一个需求，针对某一个功能方法，分为两个版本处理，除此之外在 CI 环境中还要同时上传这两个版本，这就意味着两个版本的包名也要不同，下面是示例代码： 12345678910111213141516171819202122232425262728// buildConfig 中配置AUDIO_VERSION字段productFlavors { shine { buildConfigField &quot;int&quot;, &quot;AUDIO_VERSION&quot;, &quot;2&quot; versionCode 2 } webrtc { buildConfigField &quot;int&quot;, &quot;AUDIO_VERSION&quot;, &quot;1&quot; versionCode 1 }} // buildTypes 针对不同的产品风味，构建不同的 apk 文件名buildTypes { ... applicationVariants.all { variant -&gt; variant.outputs.each { output -&gt; def outputFile = output.outputFile if (outputFile != null &amp;&amp; outputFile.name.endsWith(&apos;.apk&apos;)) { // 这里添加productFlavors的名字，输出apk名称为LoveDev-v1.0-webrtc.apk def fileName = &quot;LoveDev-v${defaultConfig.versionName}-${variant.productFlavors[0].name}.apk&quot; output.outputFile = new File(outputFile.parent, fileName) } } } ...}配置之后在 buildType 类中就有了int 类型的 AUDIO_VERSION 字段，可以根据该字段判断方法中的具体实现 其实很多配置，在官网里面已经提到过了，不过还是要根据具体的项目进行具体的配置，尽量不要照抄照搬，官网地址请戳这里 sourceSets 设置源集如果需要为一个程序在逻辑不变的情况下配置多套界面，就需要用到 sourceSets 来配置项目源集，现在有如下结构的一个程序： 1234+--main| +--java| +--skin-custom| +--res其中 skin-custom 存放的就是定制皮肤，build.gradle 需要进行如下配置： 1234567891011121314151617181920flavorDimensions(&quot;skin&quot;)productFlavors { standard { dimension &quot;skin&quot; } skin { dimension &quot;skin&quot; }}sourceSets{ standard { res.srcDirs = [&apos;src/main/res&apos;] } skin { res.srcDirs = [&apos;src/main/skin-custom&apos;] }}如果在 skin-custom 中获取不到需要的文件，就遍历其他文件夹寻找该文件 忽略 release buildType12345678910android{ ... variantFilter { variant -&gt; def names = variant.buildType.name if (names.contains(&quot;release&quot;)) { setIgnore(true) } } ...} 生成 jar 包12345678task makeJar(type: Copy) { delete &apos;build/myapp.jar&apos; //删除之前的旧jar包 from(&apos;build/intermediates/packaged-classes/release/&apos;) //从这个目录下取出默认jar包 into(&apos;build/&apos;) //将jar包输出到指定目录下 include(&apos;classes.jar&apos;) rename(&apos;classes.jar&apos;, &apos;myapp.jar&apos;) //自定义jar包的名字}makeJar.dependsOn(build)","link":"/2018/05/29/Android/Gradle-%E5%85%A5%E9%97%A8/"},{"title":"macOS 交叉编译 Android so 库以及可运行二进制文件","text":"编译 Android so库和可运行二进制文件的方式有两种： ndk-build cmake ndk-build 只能编译 Android 平台运行的 so 库或者可执行的二进制文件，cmake 支持跨平台的交叉编译 ndk-build这种方式需要 Android.mk 和 Application.mk 文件配合编译，通过一个 demo 了解利用 ndk-build 的整个过程，首先一段很简单的 C 代码： 123456#include &lt;stdio.h&gt;int main(){ printf(&quot;hello world\\n&quot;); return 0;}Android.mk 文件配置： 12345678LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := ndk_build_demoLOCAL_SRC_FILES := main.c# BUILD_SHARED_LIBRARY 编译结果为 .so 文件include $(BUILD_SHARED_LIBRARY)# BUILD_EXECUTABLE 编译结果为可执行二进制文件# include $(BUILD_EXECUTABLE)Application.mk 文件配置： 12APP_PLATFORM := android-16APP_BUILD_SCRIPT := Android.mk配置完成后，运行命令 ndk-build NDK_PROJECT_PATH=. APP_BUILD_SCRIPT=./Android.mk NDK_APPLICATION_MK=./Application.mk 运行完成生成 libs 和 obj 两个文件夹，其中 libs 文件夹中存放着对应各个 CPU 架构的 .so 文件 cmakecmake 的编译方式需要有 CMakeLists.txt 文件配合编译，通过编译一个可在 Android 平台运行的二进制文件为例简单了解一下整个编译过程，其中 C 文件不变，以下是 CMakeLists.txt 的配置： 12345678cmake_minimum_required(VERSION 3.8.2)set(CMAKE_TOOLCHAIN_FILE ndk-path/build/cmake/android.toolchain.cmake)project(demo)set(CMAKE_SYSTEM_NAME Android)set(CMAKE_SYSTEM_VERSION 21) # API levelset(CMAKE_ANDROID_ARCH_ABI arm64-v8a)add_executable(run main.c) CMAKE_TOOLCHAIN_FILE - 将提前加载指定的文件中的设置项设置编译器的值 其他的配置查阅cmake 文档 配置完成后，执行命令： 12$ cmake .$ make编译结果： 其中需要注意Check for working C compiler和Check for working CXX compiler的内容，只有使用 NDK 中的编译器才能正确编译出在 Android 平台运行的 .so 和可执行二进制文件 这种把跟平台相关的配置写入 CMakeLists.txt 的写法其实不太好，让 CMakeLists.txt 文件看起来很臃肿，CMakeLists.txt 文件中应该只存放编译源码相关的配置，和平台相关的配置最好单独放到对应平台的 shell 脚本中： 123456#!/usr/bin/env bashcmake -DCMAKE_TOOLCHAIN_FILE=&quot;${ANDROID_NDK}/build/cmake/android.toolchain.cmake&quot; \\ -DCMAKE_BUILD_TYPE=Debug \\ -DANDROID_ABI=&quot;armeabi-v7a&quot; \\ -DANDROID_PLATFORM=&quot;android-21&quot; \\ . Clion 配置Clion 默认查找本机环境的头文件，在开发 Android 驱动或者 NDK 开发时默认无法找到 NDK 包含的头文件，需要在 CMakeLists.txt 当中配置 CMAKE_C_COMPILER、CMAKE_CXX_COMPILER 这两个编译器的属性，以及指定 NDK 头文件根目录： 12345set(CMAKE_C_COMPILER /ndk/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin/arm-linux-androideabi-gcc)set(CMAKE_CXX_COMPILER /ndk/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin/arm-linux-androideabi-g++)add_definitions(&quot;--sysroot=/ndk/sysroot&quot;)# 必须指定一个编译类型，最后才能在 Clion 的 External Libraries 中生成头文件搜索路径add_executable(run_rtc main.c) 虽然在命令行中也可以指定编译器类型，但是 Clion 不会自动生成头文件搜索路径，这样设置的结果就是只能用 Android 的 C 和 C++ 编译器，无法实现项目的跨平台（也许可以）。","link":"/2019/01/10/Android/macOS-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91-Android-so-%E5%BA%93%E4%BB%A5%E5%8F%8A%E5%8F%AF%E8%BF%90%E8%A1%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/"},{"title":"设计模式-Builder模式","text":"Builder模式可以称为建造者模式，它将一个复杂对象的构建和表示分离，同样的构建过程可以创建不同的表示 适用场景： 相同的方法，不同执行顺序，产生不同事件结果 多个部件都可以装配到一个对象中，但产生的运行结果不相同 产品类非常复杂或者产品类因为调用顺序不同而产生不同作用 初始化一个对象时，参数过多，或者很多参数具有默认值 用 builder 模式创建共享单车为例子，示例代码：没有贴出来的类请参考另外一篇文章产品类： 1234567891011121314151617181920212223242526272829public class Bike { private IFrame frame; private ISeat seat; private ITire tire; public IFrame getFrame() { return frame; } public void setFrame(IFrame frame) { this.frame = frame; } public ISeat getSeat() { return seat; } public void setSeat(ISeat seat) { this.seat = seat; } public ITire getTire() { return tire; } public void setTire(ITire tire) { this.tire = tire; }} Builder 类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 抽象 builder 类public abstract class Builder { abstract void buildFrame(); abstract void buildSeat(); abstract void buildTire(); abstract Bike createBike();}// 具体 builder 类public class MobikeBuilder extends Builder{ private Bike mBike = new Bike(); @Override void buildFrame() { mBike.setFrame(new AlloyFrame()); } @Override void buildSeat() { mBike.setSeat(new DermisSeat()); } @Override void buildTire() { mBike.setTire(new SolidTire()); } @Override Bike createBike() { return mBike; }}public class OfoBuilder extends Builder{ private Bike mBike = new Bike(); @Override void buildFrame() { mBike.setFrame(new CarbonFrame()); } @Override void buildSeat() { mBike.setSeat(new RubberSeat()); } @Override void buildTire() { mBike.setTire(new InflateTire()); } @Override Bike createBike() { return mBike; }}导演类： 123456789101112131415public class Director { private Builder mBuilder = null; public Director(Builder builder) { mBuilder = builder; } public Bike construct() { mBuilder.buildFrame(); mBuilder.buildSeat(); mBuilder.buildTire(); return mBuilder.createBike(); }}使用方式： 12345678910111213141516public class Click { public static void main(String[] args) { showBike(new OfoBuilder()); showBike(new MobikeBuilder()); } private void showBike(Builder builder) { Director director = new Director(builder); Bike bike = director.construct(); bike.getFrame().frame(); bike.getSeat().seat(); bike.getTire().tire(); } } 上面示例是 Builder模式的常规用法，导演类 Director 在 Builder模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把Director和抽象建造者进行结合，示例代码：改造后的抽象建造者： 12345678910111213141516171819202122public abstract class NewBuilder { abstract void buildFrame(); abstract void buildSeat(); abstract void buildTire(); abstract Bike createBike(); /** * 把导演类中的construct()方法合并到抽象建造者类中 * * @return 具体产品对象 */ public Bike construct() { this.buildFrame(); this.buildSeat(); this.buildTire(); return this.createBike(); }} 这样做确实简化了系统结构，但同时也加重了抽象建造者类的职责，也不是太符合单一职责原则，如果 construct() 过于复杂，建议还是封装到 Director 中 除了上面的用途外，还有另外一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用 builder模式进行重构，重构前示例代码： 1234567891011121314// 省略 getter 和 setter 方法public class Computer { private String cpu; private String screen; private String memory; private String mainboard; public Computer(String cpu, String screen, String memory, String mainboard) { this.cpu = cpu; this.screen = screen; this.memory = memory; this.mainboard = mainboard; }} 重构后示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class NewComputer { private String cpu; private String screen; private String memory; private String mainboard; public NewComputer() { throw new RuntimeException(&quot;can&apos;t init&quot;); } private NewComputer(Builder builder) { cpu = builder.cpu; screen = builder.screen; memory = builder.memory; mainboard = builder.mainboard; } public static final class Builder { private String cpu; private String screen; private String memory; private String mainboard; public Builder() {} public Builder cpu(String val) { cpu = val; return this; } public Builder screen(String val) { screen = val; return this; } public Builder memory(String val) { memory = val; return this; } public Builder mainboard(String val) { mainboard = val; return this; } public NewComputer build() {return new NewComputer(this);} }} 客户端： 1234567891011121314public class Click { public static void main(String[] args) { // 非 Builder 模式 Computer computer = new Computer(&quot;cpu&quot;, &quot;screen&quot;, &quot;memory&quot;, &quot;mainboard&quot;); // Builder 模式 NewComputer newComputer = new NewComputer.Builder() .cpu(&quot;cpu&quot;) .screen(&quot;screen&quot;) .memory(&quot;memory&quot;) .mainboard(&quot;mainboard&quot;) .build(); } }上面的示例代码只是传入四个参数，如果参数是十四个甚至更多，builder 模式的优势将会更加明显，传递参数更加灵活，代码具有更高的可读性 建造者模式与抽象工厂模式的比较: 与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族 在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象 如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车 说了这么多 Builder模式的好处，再来看看它有什么缺点： Builder模式所创建的产品一般具有较多共同点，组成部分也相似，所以 Builder模式不适合创建差异性很大的产品类 产品内部变化复杂，会导致需要定义很多具体建造者类实现变化，增加项目中类的数量，增加系统的理解难度和运行成本 源码戳这里","link":"/2017/06/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Builder%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-享元模式","text":"享元模式（Flyweight Pattern）：运用共享技术有效地支持大量细粒度对象的复用，系统只使用少量对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。 当系统中存在大量相似或相同的对象时，将会导致运行代价过高、性能下降、OOM 等问题，享元模式正为解决之一类问题而诞生 在学习享元模式之前需要先了解一下 细粒度 和享元对象中的 内部状态、外部状态 这三个概念： 内部状态：不随环境改变而改变的状态，内部状态可以共享，例如人的性别，不管任何环境下都不会改变 外部状态：随着环境改变而改变的状态，不可以共享的状态，享元对象的外部状态通常由客户端保存，并在享元对象创建后，需要的时候传入享元对象内部，不同的外部状态是相互独立的。例如衣服和鞋子，人在不同的环境下会穿不同的衣服和鞋子，但是衣服和鞋子又是相互独立不受彼此影响的 细粒度：较小的对象，所包含的内部状态较小 Flyweight（抽象享元类）：通常是接口或抽象类，抽象享元类中声明了具体享元类公共方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态） ConcreteFlyweight（具体享元类）：继承抽象享元类，在具体享元类中为内部状态提供存储空间。通常可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象 UnshareConcreteFlyweight（非分享具体享元类）：并不是所有的具体享元类都需要被共享，不能被共享的子类可以设计为非共享具体享元类，当需要一个非共享具体享元类的对象时可以直接通过实例化创建 FlyweightFactory（享元工厂类）：创建并管理享元对象，将各种具体享元类存储到一个享元池中，享元池一般为“键值对”集合，可以结合工厂模式进行设计。当用户请求一个具体享元对象时，享元池中如果保存的有就直接返回给用户，如果没有就创建该享元对象返回给用户并存储到享元池中 上面的图片是众所周知的俄罗斯方块中的一个个方块，这次就拿这个游戏举个栗子，如果在俄罗斯方块这个游戏中，每个不同的方块都是一个实例对象，这些对象就要占用很多的内存空间，下面利用享元模式进行改造： Flyweight 类： 12345678public abstract class AbstractBox { public abstract String getShape(); public void display() { LogUtils.i(&quot;方块形状：&quot; + this.getShape()); }} ConcreteFlyweight 类： 1234567891011121314151617181920212223// I形方块public class IBox extends AbstractBox { @Override public String getShape() { return &quot;I&quot;; }}// L形方块public class LBox extends AbstractBox { @Override public String getShape() { return &quot;L&quot;; }}// O形方块public class OBox extends AbstractBox { @Override public String getShape() { return &quot;O&quot;; }} FlyweightFactory 类： 12345678910111213141516171819202122232425262728public class BoxFactory { private static class SingletonHolder { private static final BoxFactory INSTANCE = new BoxFactory(); } public static final BoxFactory getInstance() { return SingletonHolder.INSTANCE; } private static Hashtable&lt;String, AbstractBox&gt; sHashtable; private BoxFactory() { sHashtable = new Hashtable&lt;&gt;(); AbstractBox iBox = new IBox(); AbstractBox lBox = new LBox(); AbstractBox oBox = new OBox(); sHashtable.put(&quot;I&quot;, iBox); sHashtable.put(&quot;L&quot;, lBox); sHashtable.put(&quot;O&quot;, oBox); } public AbstractBox getBox(String key) { return sHashtable.get(key); }} Client 类： 12345678910AbstractBox i1 = BoxFactory.getInstance().getBox(&quot;I&quot;);i1.display();AbstractBox i2 = BoxFactory.getInstance().getBox(&quot;L&quot;);i2.display();AbstractBox i3 = BoxFactory.getInstance().getBox(&quot;O&quot;);i3.display();AbstractBox i4 = BoxFactory.getInstance().getBox(&quot;O&quot;);i4.display();// 用 == 对比两个对象的内存地址LogUtils.i(&quot;两个对象是否相等：&quot; + (i3 == i4));可以看出，所有的方块都从工厂类中获取，而且是同一个对象，不用重新创建对象导致占用过多的内存。看完了之后内部状态的享元模式，下面接着看带有外部状态的享元模式，接下来给不同的方块染上不同的染色： FlyweightFactory 类： 123456789101112131415161718192021222324public class ExtrinsicStateBoxFactory { private static class SingletonHolder { private static final ExtrinsicStateBoxFactory INSTANCE = new ExtrinsicStateBoxFactory(); } public static final ExtrinsicStateBoxFactory getInstance() { return SingletonHolder.INSTANCE; } private static Hashtable&lt;String, ExtrinsicStateBox&gt; sHashtable; private ExtrinsicStateBoxFactory() { sHashtable = new Hashtable&lt;&gt;(); ExtrinsicStateBox jBox = new JBox(); sHashtable.put(&quot;J&quot;, jBox); } public ExtrinsicStateBox getBox(String key) { return sHashtable.get(key); }} ConcreteFlyweight 类： 123456public class JBox extends ExtrinsicStateBox { @Override public String getShape() { return &quot;J&quot;; }} Flyweight 类： 1234567public abstract class ExtrinsicStateBox { public abstract String getShape(); public void display(String color) { LogUtils.i(&quot;方块形状：&quot; + this.getShape() + &quot; 颜色：&quot; + color); }} 在调用 display() 的时候传入颜色的外部状态，虽然方块对象还是一个对象，但是它们可以具有不同的颜色 优点 极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能 享元模式中的外部状态相对独立，且不影响内部状态 缺点 为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂 适用场景 系统中具有大量相同或相似对象 对象大部分状态都可以外部化 享元池耗费一定系统资源，需要多次重复使用享元对象时才值得使用享元模式","link":"/2017/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-代理模式","text":"代理模式（Proxy Pattern）：给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问，它是一种对象结构型模式。 当无法或不想直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，委托对象和代理对象需要实现相同的接口 Subject（抽象类）：声明代理角色和真实角色共同的接口，可以是抽象类或接口 Proxy（代理类）：持有真实对象的引用，通常，在代理类中，客户端在调用所引用的真实对象之前或之后还需要执行其他操作，不仅仅是调用真实对象中的操作 RealSubject（真实类）：真实对象的业务操作 下面是代理模式的一个简单实现： Subject 类： 123interface Subject { void request();}RealSubject 类： 123456class RealSubject implements Subject { @Override public void request() { LogUtils.i(&quot;我是真实对象&quot;); }} Proxy 类： 123456789101112131415public class Proxy implements Subject { private RealSubject mRealSubject; public Proxy() { mRealSubject = new RealSubject(); } @Override public void request() { LogUtils.i(&quot;调用真实对象前&quot;); mRealSubject.request(); LogUtils.i(&quot;调用真实对象后&quot;); }} 猛的一看和 装饰模式 非常的相似，装饰模式中的具体组件类（ConcreteComponent）和装饰类（Decorator）都实现同一个接口，代理模式中的抽象类（Subject）和代理类（Proxy）也是实现同一个接口，装饰类（Decorator）和代理类（Proxy）都是在真实对象的方法前面或者后面添加方法，但实际上，这两个模式还是又本质上的区别，装饰模式用于给一个对象动态添加方法，而代理模式用于控制一个对象的访问，隐藏对象的具体信息，代理模式中代理对象和真实对象间的关系在编译器就已经确定，而装饰模式是通过构造器传递，运行期才能确定，下面是 装饰类（Decorator） 的部分代码，对比 代理类（Proxy） 的代理就很清晰了 123456789public class Decorator extends Component { private Component component; // 通过构造器传递对象 public Decorator(Component component) { this.component = component; }} 看完代理模式和装饰模式的区别，再来了解一下代理模式中的动态代理，上面是静态代理的例子，代理对象在编译期就已经存在；而动态代理不同于静态代理，动态代理通过反射机制在运行期动态生成代理对象，Java 中提供了一个 InvocationHandler 接口实现动态代理，下面是示例代码： DynamicProxy 类： 12345678910111213141516public class DynamicProxy implements InvocationHandler { private Subject subject; public DynamicProxy(Subject subject) { this.subject = subject; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { LogUtils.i(&quot;方法调用前&quot;); Object invoke = method.invoke(subject, args); LogUtils.i(&quot;方法调用后&quot;); return invoke; }} 静态代理 Client 类： 12Proxy proxy = new Proxy();proxy.request(); 动态代理 Client 类： Subject realSubject = new RealSubject(); DynamicProxy dynamicProxy = new DynamicProxy(realSubject); Subject subject = (Subject)java.lang.reflect.Proxy.newProxyInstance(RealSubject.class.getClassLoader(), RealSubject.class.getInterfaces(),dynamicProxy); subject.request(); ```![]() &lt;h3&gt; 优点 &lt;/h3&gt; * 协调调用者和被调用者，一定程度上降低系统耦合 * 客户端可针对抽象类进行编程，增加和替换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性 &lt;h3&gt; 缺点 &lt;/h3&gt; * 客户端和真实对象之间增加了代理对象，有些类型的代理模式可能会造成请求的处理速度变慢，例如保护代理 * 实现代理模式需要额外的工作量，有些代理模式实现过程较为复杂，例如远程代理 &lt;h3&gt; 适用场景 &lt;/h3&gt; * 需要控制对一个对象的访问，为不同调用者提供不同级别的访问权限 * 需要为一个对象提供一些额外的操作","link":"/2017/07/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"title":"API Translation - RxJava","text":"Observableempty()返回一个不向 observe 发送任何项目的 Observable 对象，并且立即调用它的 onComplete() 方法 onErrorReturn()当发生错误的时候，指示一个 ObservableSource 发送一个数据，而不是去调用 onError 默认情况下，当遇到一个错误时，将从数据流中拦截这个错误，并发送到 Observer，接着调用其 Observer 的 onError() 方法，之后在不调用 Observer 其他方法的情况下退出，onErrorReturn() 方法将会改变这个行为，如果传递一个函数 (resumeFunction) 给 ObservableSource 的 onErrorReturn() 方法，当再次遇到错误的时候，不再是调用 Observer 的 onError() 方法，它将会发送 resumeFunction 的返回值 该方法可以用于阻止错误的传播以及提供发生错误时需要的备用数据 RxJava catch Schedulers用于返回 Schedulers 实例的静态工厂方法可以通过以下四个方法设置 Schedulers 的初始值： RxJavaPlugins.setInitComputationSchedulerHandler() RxJavaPlugins. setInitIoSchedulerHandler() RxJavaPlugins. setInitNewThreadSchedulerHandler() RxJavaPlugins. setInitSingleSchedulerHandler() 以下方法设置 Schedulers 运行时的值： RxJavaPlugins.setComputationSchedulerHandler() RxJavaPlugins. setIoSchedulerHandler() RxJavaPlugins. setNewThreadSchedulerHandler() RxJavaPlugins. setSingleSchedulerHandler() computation()该方法返回一个用于计算工作的默认且共享的 Scheduler 实例，它可以用于循环事件，处理回调和其他的计算工作，不推荐用于执行阻塞 IO 的工作 默认实例具有一个等于 JVM 可用处理器数量的单线程 ScheduledExecutorService 实例的后备池 没有处理的错误将会发送到 scheduler 线程的 Thread.UncaughtExceptionHandler 该 scheduler 对于 Scheduler.Worker 实例的泄漏不敏感，如果没有取消 timed/delayed 任务，执行 and/or 任务可能会导致资源泄漏 如果 RxJavaPlugins.setFailOnNonBlockingScheduler(boolean) 设置了 true，在 scheduler 运行过程中执行阻止的操作符，会导致 IllegalStateException 在使用 Scheduler 之前，可以通过必须设置的系统属性控制标准的 scheduler 的某些属性，支持的系统属性（通过 System.getProperty() 获取）： rx2.computation-threads (int)：设置 Computation() 的 Scheduler 的线程数，默认是可用 CPU 数 rx2.computation-priority (int):设置 Computation() 的 Scheduler 的线程优先级，默认是 Thread.NORM_PRIORITY，也就是一般的优先级 前面已经提到了，可以通过 RxJavaPlugins.setInitComputationSchedulerHandler() 方法覆盖 scheduler 的初始化默认值，需要注意的是，由于初始化的生命周期，在 Scheduler 初始化完成前调用其他返回 Scheduler 实例的方法都会抛出 NullPointerException，一旦 Scheduler 初始化完成，可以通过 RxJavaPlugins.setComputationSchedulerHandler() 方法覆盖返回的 Scheduler 实例 通过 RxJavaPlugins.createComputationScheduler(ThreadFactory) 方法可以利用一个自定义的 ThreadFactory 创建一个新的实例，需要注意的是该自定义实例需要手动调用 Scheduler.shutdown() 允许 JVM 退出或者 J2EE 容器正确卸载 使用该 scheduler 作为基础的运算符都用 @SchedulerSupport(COMPUTATION) 注解标识 DisposableisDisposed()如果资源已经被处理，则返回 true dispose()处理资源，该操作应该是幂等的 Error handingRxJava 2.x 中一个重要的设计需求就是异常不应该被忽略，这意味着当下游的生命周期到达了终点或者下游取消了即将发生错误的序列，将不会发生错误 这样的错误将路由到 RxJavaPlugins.onError 进行处理，RxJavaPlugins.setErrorHandler(Consumer&lt;Throwable&gt;) 这个方法可以重写这个错误处理器，如果没有一个明确的错误处理器，RxJava 默认会打印异常的堆栈信息到控制台并且调用当前线程未捕获异常的处理器 在 Java 程序中，后面的处理器对 ExecutorService 支持的 Scheduler 无效，程序可以继续保持运行。然而，Android 程序更加的严格，这样的未捕获异常会导致程序终止 这种行为是否是合适的可以进一步的讨论，但无论如何，如果想要避免调用未捕获异常的处理器，使用 RxJava 2.x 的程序应该设置一个无操作的处理器： 12345// If Java 8 lambdas are supportedRxJavaPlugins.setErrorHandler(e -&gt; { });// If no Retrolambda or Jack RxJavaPlugins.setErrorHandler(Functions.&lt;Throwable&gt;emptyConsumer()); 不推荐中间库在测试环境之外更改错误处理器，不幸的是，RxJava 2.x 无法告诉某个生命周期遇到无法传递的异常时，是否该让程序崩溃。识别这些异常的来源和原因很让人讨厌，特别是它们来源于将链路路由到 RxJavaPlugins.onError 的源中 因此，2.0.6引入了一个特定的异常包装器来帮助区分和追踪异常信息： OnErrorNotImplementedException：当用户忘记给 subscribe() 添加错误处理时，重新引入检测 ProtocolViolationException：表示操作中的错误 UndeliverableException：包装由于 Subscriber/Observer 的生命周期限制而无法传递的原始异常。它由 RxJavaPlugins.onError 自动用于完整的堆栈跟踪，它有助于帮助找到是那个操作符重新路由了原始错误 如果一个未传递的异常是 NullPointerException，IllegalStateException， IllegalArgumentException， CompositeException， MissingBackpressureException or OnErrorNotImplementedException 的实例或者子类，这些异常将不会包装成 UndeliverableException 此外，一些第三方的库，当它们被一个 cancel/dispose 调用中断时，很多情况下会导致未传递的异常，2.0.6版本内部的改变是在 cancelling/disposing 一个 task 或者 worker（会导致目标线程中断）之前，会一直 cancel 或者 dispose Subscription/Disposable 12345678910// in some librarytry { doSomethingBlockingly()} catch (InterruptedException ex) { // check if the interrupt is due to cancellation // if so, no need to signal the InterruptedException if (!disposable.isDisposed()) { observer.onError(ex); }} 如果库或者代码中已经这么做了，现在应该停止无法传递的 InterruptedExceptions，如果之前没有使用这个模式，我们提倡更新相关的代码或库 如果决定添加一个非空的全局错误处理，这里有一个例子，可以根据它们是否代表一个 bug 或者一个可忽略的程序或网络状态来管理典型的未传递的异常： 1234567891011121314151617181920212223242526RxJavaPlugins.setErrorHandler(e -&gt; { if (e instanceof UndeliverableException) { e = e.getCause(); } if ((e instanceof IOException) || (e instanceof SocketException)) { // fine, irrelevant network problem or API that throws on cancellation return; } if (e instanceof InterruptedException) { // fine, some blocking code was interrupted by a dispose call return; } if ((e instanceof NullPointerException) || (e instanceof IllegalArgumentException)) { // that&apos;s likely a bug in the application Thread.currentThread().getUncaughtExceptionHandler() .handleException(Thread.currentThread(), e); return; } if (e instanceof IllegalStateException) { // that&apos;s a bug in RxJava or in a custom operator Thread.currentThread().getUncaughtExceptionHandler() .handleException(Thread.currentThread(), e); return; } Log.warning(&quot;Undeliverable exception received, not sure what to do&quot;, e);});","link":"/2017/07/24/%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/API-Translation-RxJava/"},{"title":"设计模式-单例模式","text":"单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一，该模式确保一个类只有一个实例 懒汉式，线程不安全1234567891011class LazySingleton { private static LazySingleton instance; private LazySingleton (){} public static LazySingleton getInstance() { if (instance == null) { instance = new LazySingleton(); } return instance; }}懒汉式使用懒加载模式，但是在多线程环境中调用 getInstance() 就会创建多个实例 懒汉式，线程安全12345678910111213class SynchronizedLazySingleton { private static SynchronizedLazySingleton instance; private SynchronizedLazySingleton(){} //添加synchronized关键字 public static synchronized SynchronizedLazySingleton getInstance() { if (instance == null) { instance = new SynchronizedLazySingleton(); } return instance; }}给 getInstance() 方法加上 synchronized 关键字实现线程安全，但是该方法效率上有问题，任何时候只能有一个线程调用 getInstance() 获取实例，而且实例第一次创建之后就不需要同步操作 饿汉式，线程安全123456789class HungrySingleton { private static final HungrySingleton instance = new HungrySingleton(); private HungrySingleton(){} public static HungrySingleton getInstance(){ return instance; }}实例被 static final 修饰，类加载时就会初始化，但它不是懒加载模式，如果 HungrySingleton 实例的创建需要某个条件参数，这种写法就不能实现 双重检验锁1234567891011121314151617class DoubleCheckedSingleton { private volatile static DoubleCheckedSingleton instance; private DoubleCheckedSingleton() {} public static DoubleCheckedSingleton getInstance() { if (instance == null) { synchronized (DoubleCheckedSingleton.class) { if (instance == null) { instance = new DoubleCheckedSingleton(); } } } return instance; }}为了避免在多线程环境中执行 instance = new DoubleCheckedSingleton() 造成指令重排序，添加 volatile 关键字修饰，禁止指令重排序优化，抛开代码可读性来说这种写法已经完美了，但是这样你就满足了吗？没有的话就接着看下去吧 静态内部类12345678910class StaticSingleton { private static class SingletonHolder { private static final StaticSingleton INSTANCE = new StaticSingleton(); } private StaticSingleton (){} public static final StaticSingleton getInstance() { return SingletonHolder.INSTANCE; }}该方法为 《Effective Java》上推荐的，它是懒汉式，并且性能没有缺陷 带参单例类123456789101112131415161718192021public class Singleton { private static Singleton Instance = null; private Singleton(final Context context) { //TODO }public static void createInstance(final Context context) { if (Instance == null) { synchronized (Singleton.class) { if (Instance == null) { Instance = new Singleton(context); } } } } public static Singleton getInstance() { if (Instance == null) { throw new NullPointerException(&quot;getInstance() is Null, please call Singleton.createInstance(context) first!&quot;); } return Instance; }}有时不得不往单例类里面传递一个上下文参数，或者初始化参数，可以用这样的单例类 枚举123enum EnumSingleton { INSTANCE}最简单的单例类，没有之一，还能防止序列化导致重新创建新的对象 切勿滥用单例类 单例模式中没有抽象层，因此单例类的扩展很困难。类的构造函数通常是私有的，无法被继承。尤其在单元测试的时候，常常需要继承原始的类，并覆写一些方法以达到打桩的目的 对需要多例的集成测试不友好，在集成测试的时候，可能需要在同一个进程里构造出两个A的实例，以方便测试 代码模块之间的依赖不清晰。举例，当模块B需要使用类A的实例，它通常可以A.getInstance()来获取A的唯一实例，这样会造成整个项目代码中，到处都有A.getInstance()这样的使用，于是很难看出到底哪些模块真正依赖A。而如果B的构造函数是B（A a），就可以很直观地看出B对A的依赖 思考以上介绍的单例模式的写法均在单一进程中有效，如果是多进程环境中，这些写法均不能保证实例的唯一性，如何在多进程环境中保证单例模式的特性呢？","link":"/2017/06/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-原型模式","text":"原型模式是创建型模式的一种，其特点在于通过“复制”一个已经存在的实例来返回新的实例，而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的 使用场景： 通过 new 产生一个对象需要非常繁琐的数据准备和访问权限 一个对象需要提供给其他对象访问，每个调用者都有可能修改其属性，可以原型模式拷贝多个对象供调用者使用，即保护性拷贝uml 看起来是不是特别简单，用起来其实也很简单，Object 类已经提供了一个 clone() 方法，查看源码可以得知，想要使用该方法，还要实现一个标识接口Cloneable ，clone() 源码： 12345678protected Object clone() throws CloneNotSupportedException { if (!(this instanceof Cloneable)) { throw new CloneNotSupportedException(&quot;Class &quot; + getClass().getName() + &quot; doesn&apos;t implement Cloneable&quot;); } return internalClone();} Java语言提供的Cloneable接口和Serializable接口的代码非常简单，它们都是空接口，这种空接口也称为标识接口，标识接口中没有任何方法的定义，其作用是告诉JRE这些接口的实现类是否具有某个功能，如是否支持克隆、是否支持序列化等 再来看看超级简单的示例代码： 具体原型类： 12345678910111213141516171819202122232425public class ConcretePrototype implements Cloneable { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } @Override public String toString() { return &quot;ConcretePrototype{&quot; + &quot;name=&apos;&quot; + name + &apos;\\&apos;&apos; + &quot;, person=&quot; + person + &apos;}&apos;; }} 看着有没有特别的简单方便，但是这里面有一个坑在，这就牵扯到浅拷贝和深拷贝，上述的原型模式就是浅拷贝，也称为影子拷贝，如果需要拷贝的类中全部都是基础类型的属性，浅拷贝也是没有问题的，但是有引用类型的属性，就会出现问题了，出现问题的示例代码： 具体原型类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Person { private String name; private String age; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAge() { return age; } public void setAge(String age) { this.age = age; } @Override public String toString() { return &quot;Person{&quot; + &quot;name=&apos;&quot; + name + &apos;\\&apos;&apos; + &quot;, age=&apos;&quot; + age + &apos;\\&apos;&apos; + &apos;}&apos;; }}// 具体原型类public class ConcretePrototype implements Cloneable { private String name; private Person person; public String getName() { return name; } public void setName(String name) { this.name = name; } public Person getPerson() { return person; } public void setPerson(Person person) { this.person = person; } @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } @Override public String toString() { return &quot;ConcretePrototype{&quot; + &quot;name=&apos;&quot; + name + &apos;\\&apos;&apos; + &quot;, person=&quot; + person + &apos;}&apos;; }} Client类： 123456789101112131415161718192021222324252627282930313233343536373839404142public class PrototypeActivity extends Activity { @BindView(R.id.prototype_text) TextView mTextView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_prototype); ButterKnife.bind(this); } @OnClick(R.id.prototype) public void prototype_click() { ConcretePrototype concretePrototype = new ConcretePrototype(); concretePrototype.setName(&quot;Kevin&quot;); Person person = new Person(); person.setName(&quot;Person&quot;); person.setAge(&quot;10&quot;); concretePrototype.setPerson(person); StringBuilder stringBuilder = new StringBuilder(&quot;concretePrototype：&quot; + concretePrototype.toString()); try { ConcretePrototype clone = (ConcretePrototype) concretePrototype.clone(); clone.setName(&quot;LoveDev&quot;); stringBuilder.append(&quot;\\nclone: &quot;).append(clone.toString()); //第一次修改，正常 Person newPerson = clone.getPerson(); newPerson.setName(&quot;newPerson&quot;); newPerson.setAge(&quot;20&quot;); clone.setPerson(newPerson); stringBuilder.append(&quot;\\n\\n\\nconcretePrototype: &quot;).append(concretePrototype.toString()); stringBuilder.append(&quot;\\nclone: &quot;).append(clone.toString()); //第二次修改，被拷贝对象同时被修改 stringBuilder.append(&quot;\\n\\n\\n 对比两个类中的 Person 字段是否相同：&quot;).append(concretePrototype.getPerson() == clone.getPerson()); mTextView.setText(stringBuilder); } catch (CloneNotSupportedException e) { e.printStackTrace(); } }} 第一次修改的时候，只改了具体原型类中的String类型，打印结果没有是问题的，只修改了克隆后的类，第二次修改Person字段，再次打印的时候，发现原型类已经被修改了，导致这个问题的原因是因为浅拷贝只是拷贝了引用地址，两个对象指定的是同一内存地址，从打印结果就可以看的出来，要解决这个问题就要采用深拷贝进行克隆，在克隆对象时，对于引用类型的字段也要采用克隆的形式，修改后的示例代码： 12345678910111213141516171819202122232425262728293031323334353637public class ConcretePrototype implements Cloneable { private String name; private Person person; public String getName() { return name; } public void setName(String name) { this.name = name; } public Person getPerson() { return person; } public void setPerson(Person person) { this.person = person; } @Override protected Object clone() throws CloneNotSupportedException { ConcretePrototype concretePrototype = new ConcretePrototype(); concretePrototype.name = this.name; concretePrototype.person = (Person) this.person.clone(); return concretePrototype; } @Override public String toString() { return &quot;ConcretePrototype{&quot; + &quot;name=&apos;&quot; + name + &apos;\\&apos;&apos; + &quot;, person=&quot; + person + &apos;}&apos;; }} 再次执行，可以发现问题得以解决，原型模式一个很重要的用途就是保护性拷贝，再给其他模块提供接口访问一个不可修改的对象时，为了防止该模块负责人出于某种原因而修改该对象时，就要用原型模式进行保护性拷贝 优点： 看了很多的文章都说原型模式效率搞，下面分别是原型模式和直接new在10000次for循环中创建对象的内存消耗和耗时： 直接new对象，执行耗时为23毫秒，内存占用增加909K，对比图： 原型模式，执行耗时为44毫秒，内存占用增加876K，对比图： 从这些数据来看，原型模式增加了将近一倍的耗时，内存占用并没有少很多，这还是建立在不太准确的测试数据上，个人认为原型模式在效率方面比直接 new 对象并没有提高，不过还有其他的优点在： 原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品 可以利用深拷贝实现保护性拷贝，可实现撤销操作 缺点： 想要使用原型模式就要在类中实现克隆方法，修改类的源码，违背了“开闭原则” 深拷贝是需要编写大量的代码，多层对象嵌套时，每层对象都要支持深拷贝","link":"/2017/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-外观模式","text":"外观模式（Facade Pattern）：又称为门面模式，为一组接口提供一个统一的入口。外观模式是迪米特法则的一种具体实现，通过引入一个新的外观角色降低原有系统的复杂度，同时降低客户端类与子系统的耦合度。 Facade（外观角色）：外观角色中可以知道相关的多个子系统的功能和责任，客户端调用它的方法，它再传递给相应的子系统对象处理 SubSystem（子系统角色）：子系统可以不是单独的类，而是类的集合，它实现子系统的功能，每个子系统都可以被客户端直接调用，或者被外观角色调用，对于子系统而言，外观角色也是一个客户端。 最近习惯了自己做饭，虽然做饭的过程很痛苦，可是看到自己做出来的美食后，还是很幸福很有成就感的。就拿自己做饭吃和去餐馆吃饭来举例，把餐馆看做外观角色，让它把买菜、切菜、炒菜、刷碗这些工作统一组织起来，我要做的就是告诉他要吃什么就行了，下面是示例代码： SubSystem 类： 123456789101112131415161718192021222324252627// 买菜public class BuyVegetable { public void buy() { LogUtils.i(&quot;买菜&quot;); }}// 切菜public class CutVegetable { public void cut() { LogUtils.i(&quot;切菜&quot;); }}// 炒菜public class CookVegetable { public void cook() { LogUtils.i(&quot;炒菜&quot;); }}// 洗刷刷public class WashDishes { public void wash() { LogUtils.i(&quot;洗刷刷&quot;); }} Facade 类： 12345678910111213141516171819202122// 餐馆public class Restaurant { private final BuyVegetable mBuyVegetable; private final CutVegetable mCutVegetable; private final CookVegetable mCookVegetable; private final WashDishes mWashDishes; public Restaurant() { mBuyVegetable = new BuyVegetable(); mCutVegetable = new CutVegetable(); mCookVegetable = new CookVegetable(); mWashDishes = new WashDishes(); } public void eat() { mBuyVegetable.buy(); mCutVegetable.cut(); mCookVegetable.cook(); mWashDishes.wash(); }} Client 类： 12345678910111213// 自己做饭，需要跟这些子系统交互BuyVegetable buyVegetable = new BuyVegetable();CutVegetable cutVegetable = new CutVegetable();CookVegetable cookVegetable = new CookVegetable();WashDishes washDishes = new WashDishes();buyVegetable.buy();cutVegetable.cut();cookVegetable.cook();washDishes.wash();// 去餐馆吃饭，只需跟餐馆交互Restaurant restaurant = new Restaurant();restaurant.eat(); 有了外观模式，需要交互的类就变成了一个，让它负责和业务类实现交互，简化负责的交互，降低系统的耦合度，但是在标准的外观模式中，如果需要增删改外观类交互的子系统类，就需要改动客户端源码，这样就违反了“开闭原则”，因此遇到此类情况需要引入抽象外观类进行优化，还以上面例子为基础： AbstarctFacade 类： 123public abstract class AbstractFacade { public abstract void eat();} ConcreteFacade 类： 1234567891011121314151617181920// 有些不用切就可以直接做的饭，比如面，这就需要把切菜移除掉public class NoodlesRestaurant extends AbstractFacade{ private final BuyVegetable mBuyVegetable; private final CookVegetable mCookVegetable; private final WashDishes mWashDishes; public NoodlesRestaurant() { mBuyVegetable = new BuyVegetable(); mCookVegetable = new CookVegetable(); mWashDishes = new WashDishes(); } @Override public void eat() { mBuyVegetable.buy(); mCookVegetable.cook(); mWashDishes.wash(); }} Client 类： 12AbstractFacade abstractFacade = new NoodlesRestaurant();abstractFacade.eat(); 优点 屏蔽子系统，减少客户端所需交互的对象，简化调用 降低客户端与子系统耦合，面对子系统变化，只需要调整外观类即可 子系统间的修改不会相互影响 缺点 不能很好限制客户端直接使用子系统类，对访问子系统类做过多限制则减少可变性和灵活性 设计不当时，增加新的子系统需要修改外观类源码，违背开闭原则 使用场景 需要访问一系列子系统完成业务需求 客户端和多个子系统很高的耦合，使用外观模式解耦，提高子系统的独立性和可移植性 层次化结构中，使用外观模式定义系统中每层的入口，层与层之间不直接产生联系，通过外观类建立联系，降低层之间的耦合","link":"/2017/07/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-工厂模式","text":"工厂模式是最常用的设计模式之一，该模式定义一个用于创建对象的工厂类，调用者不用关心创建的细节 工厂模式可以分为三个子模式： 简单工厂模式（Simple Creational Pattern） 工厂方法模式（Factory Creational Pattern） 抽象工厂模式（Abstract Creational Pattern） 简单工厂模式 定义工厂类，根据参数返回不同类的实例，这些实例通常具有共同的父类，因为简单工厂模式用静态方法创建实例，所以又称为静态工厂模式（Static Creational Pattern） Factory：工厂类，实现创建所有产品实例的内部逻辑 Product：抽象产品类，封装产品公有方法，它的引入使得工厂类只需要定义一个通用的工厂方法，因为创建的具体产品都是该类的子类 ConcreteProduct：具体实现类 代码示例： 产品类： 123456789101112// 抽象产品类abstract class Product { abstract void doSomething(Context context);}// 具体产品类class ConcreteProduct extends Product { @Override void doSomething(Context context) { }} 工厂类： 1234567891011121314151617181920class Factory { public Factory() { throw new RuntimeException(&quot;can&apos;t init&quot;); } static final String concreteProductA = &quot;concreteProductA&quot;; static final String concreteProductB = &quot;concreteProductB&quot;; static Product createdProduct(String arg) { switch (arg) { case concreteProductA: return new ConcreteProductA(); case concreteProductB: return new ConcreteProductB(); default: return null; } }} 适用场景： 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂 客户端只知道传入工厂类的参数，对于如何创建对象并不关心 现实情况是复杂多变的，突然有一天产品经理说还要增加一个其他的类型，如果是简单工厂方法，就不得不在 if...else 或者 switch 中增加一个判断，这样就违反了开闭原则，对于这样的工厂类，称它为全能类或者上帝类 工厂方法模式 工厂方法模式去掉简单工厂模式的静态方法，使它可以被子类继承，这样就可以把静态方法的压力分担给各个子类承担，每个子工厂类只负责创建一个具体的产品类实例 Product：抽象产品类，所有需要实例化子类的父类 ConcreteProduct：具体产品类 Factory：抽象工厂类，此类是工厂方法模式的核心，所有工厂类都要继承该类 ConcreteFactory：具体工厂类，实现具体的业务逻辑 示例代码：产品类： 1234567891011121314151617181920// 抽象类abstract class People { abstract void doSomething();}// 女性class Female extends People{ @Override void doSomething() { }}// 男性class Male extends People { @Override void doSomething() { }} 工厂类： 123456789101112131415161718192021// 抽象工厂类public abstract class Factory { abstract People createPeople();}// 具体工厂类public class FemaleFactory extends Factory { @Override People createPeople() { return new Female(); }}public class MaleFactory extends Factory { @Override People createPeople() { return new Male(); }} 适用场景： 客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建 抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展 跟简单工厂模式一样的问题，虽然没有违反开闭原则，但是增加新产品类的时候，因为一个具体工厂类只负责一个具体产品类，所以必须也要增加对应的具体工厂类，项目中类的个数成对增加，进而增加了系统的复杂度，更多的类需要编译和运行，给系统带来额外的开销 抽象工厂模式 工厂方法模式中一个工厂类负责生产一个具体产品，有时根据业务需求，一个工厂类需要提供多个具体产品，例如生产共享单车，一个工厂类可以提供多个共享单车的组件，比如车胎，车架，车座，车把，从而组成一个完整产品，为了更好理解抽象工厂模式，先理解两个概念： 产品等级结构：即产品的继承结构，如车轮，子类有实心车胎，充气车胎，山地车胎等，抽象车轮和车轮具体类型构成一个产品等级结构 产品族：抽象工厂模式中，产品族指同一工厂生产的，位于不同产品等级结构的一组产品，如自行车厂商生产实心车胎、铝合金车架等，实心车胎位于车胎产品等级结构中，铝合金车架位于车架产品等级结构中，实心车胎、铝合金车架等构成一个产品族 AbstractProductA：抽象产品类 AbstractProductB：抽象产品类 ConcreteProductA1：具体产品类 ConcreteProductA2：具体产品类 ConcreteProductB1：具体产品类 ConcreteProductB2：具体产品类 AbstractFactory：抽象工厂类 ConcreteFactory1：具体工厂类，实现具体的业务逻辑 ConcreteFactory2：具体工厂类，实现具体的业务逻辑 这里用一个生产单车的例子实践一下抽象工厂模式，示例代码：产品类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 车座interface ISeat { void seat();}// 车胎interface ITire { void tire();}// 车架interface IFrame { void frame();}// 铝合金车架public class AlloyFrame implements IFrame { @Override public void frame() { Log.i(&quot;IFrame&quot;, &quot;AlloyFrame&quot;); }}// 碳纤维车架class CarbonFrame implements IFrame { @Override public void frame() { Log.i(&quot;IFrame&quot;, &quot;CarbonFrame&quot;); }}// 真皮车座class DermisSeat implements ISeat { @Override public void seat() { Log.i(&quot;ISeat&quot;, &quot;DermisSeat&quot;); }}// 橡胶车座class RubberSeat implements ISeat { @Override public void seat() { Log.i(&quot;ISeat&quot;, &quot;RubberSeat&quot;); }}// 充气车胎class InflateTire implements ITire { @Override public void tire() { Log.i(&quot;ITire&quot;, &quot;InflateTire&quot;); }}// 实心车胎class SolidTire implements ITire { @Override public void tire() { Log.i(&quot;ITire&quot;, &quot;SolidTire&quot;); }} 工厂类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 抽象工厂类abstract class AbstractFactory { /** * 生产车胎 * * @return 车胎 */ abstract ITire createTire(); /** * 生产车架 * * @return 车架 */ abstract IFrame createFrame(); /** * 生产车座 * * @return 车座 */ abstract ISeat createSeat();}// ofo 工厂类class OfoFactory extends AbstractFactory { @Override ITire createTire() { return new InflateTire(); } @Override IFrame createFrame() { return new CarbonFrame(); } @Override ISeat createSeat() { return new RubberSeat(); }}// mobike 工厂类class MobikeFactory extends AbstractFactory{ @Override ITire createTire() { return new SolidTire(); } @Override IFrame createFrame() { return new AlloyFrame(); } @Override ISeat createSeat() { return new DermisSeat(); }} 适用场景： 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦 系统中有多于一个的产品族，而每次只使用其中某一产品族 产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构 抽象工厂模式可以很方便根据现有的产品等级结构生成新的产品族，但是增加新的产品等级结构会很麻烦，这种性质称为开闭原则的倾斜性","link":"/2017/05/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-桥接模式","text":"桥接模式是种很实用的结构型设计模式，又称为柄体模式或接口模式，该模式可以将两个维度的变化分离开，让系统更符合“单一职责原则”，与多层继承方案不同，它将两个独立变化的维度设计为两个独立的继承等级结构，并在抽象层建立抽象关联，该关联关系类似一条连接两个独立继承结构的桥，故而叫桥接模式 Abstraction（抽象类）：一般是抽象类，其中定义一个 Implementor 类型的对象，它与 Implementor 之间具有关联关系。该类可以包含抽象业务方法，也可以包含具体业务方法 RefineAbstraction（扩展抽象类）：一般是具体类而不是抽象类，实现 Abstraction 中的抽象方法 Implementor（实现类接口）：该接口一般情况仅提供基本操作，Abstraction 中做更多更复杂的操作，Implementor 接口对这些基本操作进行声明，具体实现交给子类，通过关联关系，Abstraction 不仅拥有自己的方法，还可以调用 Implementor 中的方法，使用关联关系代替继承关系 ConcreteImplementor（具体实现类）：代替父类对象，提供给抽象类做具体的业务 举一个衣服店的例子，店里现在只剩下两种衣服，黄色 XXL 号和红色 M 号的，衣服这个对象具有至少两个维度的变化，一个是衣服尺码，一个是衣服颜色，现在来看用桥接模式实现衣服对象的代码示例： Implementor 类： 123public interface Color { String dyeing();}ConcreteImplementor 类： 123456public class Yellow implements Color { @Override public String dyeing() { return &quot;黄色&quot;; }} Abstraction 类： 12345678910public abstract class Clothes { public Color color; public void setColor(Color color) { this.color = color; } public abstract void getClothes();} RefineAbstraction 类： 1234567891011public class XXLClothes extends Clothes { @Override public void getClothes() { String s = null; if (color != null) { s = color.dyeing(); } LogUtils.i(s + &quot;XXL号的衣服&quot;); }} Client 类： 1234Yellow yellow = new Yellow();XXLClothes xxlClothes = new XXLClothes();xxlClothes.setColor(yellow);xxlClothes.getClothes(); 现在需要增加几种衣服的类型，就会很快捷方便，也遵守“开闭原则”比如增加一个粉色 L 号衣服对象，首先增加一个 RefineAbstraction 类： 1234567891011public class LClothes extends Clothes { @Override public void getClothes() { String s = null; if (color != null) { s = color.dyeing(); } LogUtils.i(s + &quot;L号的衣服&quot;); }} 再添加一个 ConcreteImplementor 类： 123456public class Pink implements Color { @Override public String dyeing() { return &quot;粉色&quot;; }} Client 类： 1234Yellow Pink = new Pink();LClothes lClothes = new LClothes();lClothes.setColor(Pink);lClothes.getClothes(); 桥接模式中体现了很多面向对象设计原则的思想： 单一职责原则：一个类负责一项职责 开闭原则：开放扩展，关闭修改 里氏替换：子类能完全替代父类 依赖倒置：不依赖细节，依赖抽象 桥接模式的好处有很多，但是对使用者有一定的经验要求，需要正确识别独立变化的两个维度，以及一开始就要对抽象层进行设计","link":"/2017/06/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-状态模式","text":"一个对象的行为其属性的动态变化，这样的属性叫状态，这类对象也叫做有状态的对象。当此类对象被某一事件修改其内部状态时，程序的行为也要随之改变 状态模式又称状态对象模式（Pattern of Objects for States）是用于解决对象的复杂状态及不同状态下的行为的一种模式。 模式定义状态模式允许一个对象在其内部属性改变的时候改变其行为，这个对象看上去就像是改变了它的类一样 模式结构状态模式涉及角色： 环境角色（Context）：定义客户感兴趣的接口，并保留一个具体状态类的实例 抽象状态角色（State）：定义一个借口，封装特定状态下的对应行为 具体状态角色（ConcreteState）：抽象状态角色的子类，每个子类实现了相关的行为 Tip： 该图为UML图 类包含3个组成部分，第一栏为类名，第二栏为属性，第三栏为方法 属性和方法前可加一个可见性修饰符， + 号表示 public 修饰符， - 号表示 private 修饰符， # 号表示 protected 修饰符，省略表示包级可见。 接口包含2个组成部分，第一栏为接口名，第二栏为方法，在接口名之上加上 &lt;&lt;interface&gt;&gt; 使用场景比如游戏中一个用户的用过外挂违规次数属性，如果用户用过1~3次，每次警告制裁；3次以上，每次封号3天；5次以上，每次封号1周；到达10次，永久封号。 根据以上描述可以分为四种状态： 警告 封号3天 封号1周 永久封号 源码环境角色123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class PunishManager { //保存违规用户及次数 private Map&lt;String, Integer&gt; mPunishMap = new HashMap&lt;&gt;(); /** * 获取违规用户及次数 */ Map&lt;String, Integer&gt; getPunishMap() { return mPunishMap; } /** * 获取具体状态角色，封装转换规则 * * @param oldPunishCount 违规次数 * @return 具体状态角色 */ private PunishState getPunishState(Integer oldPunishCount) { //推荐尽量少用else，如果超过3层if-else代码推荐使用卫语句 if (oldPunishCount &lt;= 3) { return new LowPunishState(); } if (oldPunishCount &lt;= 5) { return new MidPunishState(); } if (oldPunishCount &lt; 10) { return new HeightPunishState(); } return new BlackPunishState(); } /** * 违规处理 * * @param uid 用户ID */ public void punish(String uid) { //获取之前违规次数 Integer oldPunishCount = mPunishMap.get(uid); if (oldPunishCount == null) { oldPunishCount = 0; } oldPunishCount += 1; mPunishMap.put(uid, oldPunishCount); //获取对应状态对象进行响应操作 getPunishState(oldPunishCount).punish(uid, oldPunishCount, this); }} 抽象状态角色12345678910public interface PunishState { /** * 违规处理 * * @param uid 用户ID * @param violationCount 违规次数 * @param punishManager 环境角色 */ public void punish(String uid, int violationCount, PunishManager punishManager);} 具体状态角色根据不同的具体状态角色做相应的业务 12345678public class LowPunishState implements PunishState { @Override public void punish(String uid, int violationCount, PunishManager punishManager) { //违规1~3次，警告制裁 System.out.println(&quot;警告制裁&quot;); }} 1234567public class MidPunishState implements PunishState { @Override public void punish(String uid, int violationCount, PunishManager punishManager) { //违规3次以上，封号三天 System.out.println(&quot;封号三天&quot;); }} 1234567public class HeightPunishState implements PunishState { @Override public void punish(String uid, int violationCount, PunishManager punishManager) { //违规5次以上，封号一周 System.out.println(&quot;封号一周&quot;); }} 1234567public class BlackPunishState implements PunishState { @Override public void punish(String uid, int violationCount, PunishManager punishManager) { //违规10次，永久封号 System.out.println(&quot;永久封号&quot;); }} 入口类123456789public class Main { public static void main(String[] args) { PunishManager punishManager = new PunishManager(); for (int i = 1; i &lt;= 10; i++) { punishManager.punish(&quot;Kevin&quot;); } }} 运行结果： 优点 封装了转换规则 结构清晰，提高可维护性 不同状态对应的不同行为放到单独类中，方便增加新的状态，只需改变对象状态即可改变对象行为 缺点 增加了类和对象的个数 状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。","link":"/2017/03/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-类型","text":"设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性 设计模式一共可以分为三大类： 创建型模式（Creational Patterns） 结构型模式（Structural Patterns） 行为型模式（Behavioral Patterns） 创建型模式 这类模式在创建对象的同时隐藏具体创建逻辑，不是使用新的运算符直接实例化对象，这使得程序根据给定条件创建对应对象时更加灵活 工厂模式 简单工厂模式（Simple Creational Pattern） 工厂方法模式（Factory Creational Pattern） 抽象工厂模式（Abstract Creational Pattern） 单例模式 Builder模式 原型模式 结构型模式 这类模式关注类和对象的组合，继承的概念被用来组合接口和定义组合对象获得新功能 适配器模式 桥接模式 装饰模式 外观模式 享元模式 行为型模式 这类模式主要关注对象间的通信","link":"/2017/06/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%B1%BB%E5%9E%8B/"},{"title":"设计模式-组合模式","text":"对于树形结构，容器对象（如文件夹）可以进行添加删除叶子对象（如文件）等操作，但是叶子对象就不能具备这样的操作，所以容器对象和叶子对象需要区别对待，但是这样会使得程序非常复杂，通常我们希望可以一致的处理它们，组合模式就是为此类问题而诞生，组合模式通过一种巧妙的设计方案使得用户可以一致性地处理整个树形结构或者树形结构的一部分，也可以一致性地处理树形结构中的叶子对象和容器对象 组合模式（Composite Pattern）：组合多个对象形成树形结构以表示具有“整体-部分”关系的层次结构，组合模式又可以称为“整体-部分”（Part-Whole）模式，是一种结构型模式 Component（抽象构件）：可以是接口或者抽象类，为叶子对象和容器对象声明接口 Leaf（叶子对象）：对于增加、删除等操作，可以通过异常进行处理，只实现属于叶子对象的方法 Composite（容器对象）：包含叶子对象的容器 先来用透明组合模式实现一个获取文件后缀名的操作： Component 类： 12345678910111213public abstract class AbstractFile { private String name; public AbstractFile(String name) { this.name = name; } public abstract void addFile(AbstractFile file); public abstract void removeFile(AbstractFile file); public abstract AbstractFile getFile(int index); public abstract void getFileSuffix();} Leaf 类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// Java 文件对象public class JavaFile extends AbstractFile { public JavaFile(String name) { super(name); } @Override public void addFile(AbstractFile file) { throw new UnsupportedOperationException(&quot;不支持操作&quot;); } @Override public void removeFile(AbstractFile file) { throw new UnsupportedOperationException(&quot;不支持操作&quot;); } @Override public AbstractFile getFile(int index) { throw new UnsupportedOperationException(&quot;不支持操作&quot;); } @Override public void getFileSuffix() { LogUtils.i(&quot;Java 文件的后缀名是 .java&quot;); }}// text 文件对象public class TextFile extends AbstractFile { public TextFile(String name) { super(name); } @Override public void addFile(AbstractFile file) { throw new UnsupportedOperationException(&quot;不支持操作&quot;); } @Override public void removeFile(AbstractFile file) { throw new UnsupportedOperationException(&quot;不支持操作&quot;); } @Override public AbstractFile getFile(int index) { throw new UnsupportedOperationException(&quot;不支持操作&quot;); } @Override public void getFileSuffix() { LogUtils.i(&quot;Text 文件的后缀名是 .txt&quot;); }} Composite 类： 1234567891011121314151617181920212223242526272829303132public class Folder extends AbstractFile { ArrayList&lt;AbstractFile&gt; fileList = new ArrayList&lt;&gt;(); public Folder(String name) { super(name); } @Override public void addFile(AbstractFile file) { fileList.add(file); } @Override public void removeFile(AbstractFile file) { fileList.remove(file); } @Override public AbstractFile getFile(int index) { return fileList.get(index); } @Override public void getFileSuffix() { LogUtils.i(&quot;文件夹无后缀名&quot;); for (AbstractFile abstractFile : fileList) { abstractFile.getFileSuffix(); } }} Client 类： 12345678910111213141516171819AbstractFile text1 = new TextFile(&quot;text1&quot;);AbstractFile text2 = new TextFile(&quot;text2&quot;);AbstractFile javaFile1 = new JavaFile(&quot;javaFile1&quot;);AbstractFile javaFile2 = new JavaFile(&quot;javaFile2&quot;);AbstractFile folder1 = new Folder(&quot;folder1&quot;);AbstractFile folder2 = new Folder(&quot;folder2&quot;);AbstractFile folder3 = new Folder(&quot;folder3&quot;);folder1.addFile(text1);folder1.addFile(javaFile1);folder2.addFile(text2);folder2.addFile(javaFile2);folder3.addFile(folder1);folder3.addFile(folder2);folder3.getFileSuffix(); 如果仅仅是获取文件后缀名，暂时没有任何问题，但是不熟悉代码得小伙伴调用了 TextFile 中的 addFile() 函数，又没有进行异常处理，就会导致程序出现异常，这就是透明组合模式的缺点，对于调用者来说所有函数足够透明，但是一不小心就会导致程序出现异常 下面再来介绍另外一种组合模式，叫做安全组合模式： 利用该模式再实现一下上面获取文件后缀名的操作： Component 类： 12345678910public abstract class AbstractSafeFile { private String name; public AbstractSafeFile(String name) { this.name = name; } public abstract void getFileSuffix();} Leaf 类： 123456789101112131415161718192021222324// Java 文件对象public class JavaFile extends AbstractSafeFile { public JavaFile(String name) { super(name); } @Override public void getFileSuffix() { LogUtils.i(&quot;Java 文件的后缀名是 .java&quot;); }}// text 文件对象public class TextFile extends AbstractSafeFile { public TextFile(String name) { super(name); } @Override public void getFileSuffix() { LogUtils.i(&quot;Text 文件的后缀名是 .txt&quot;); }} Composite 类： 1234567891011121314151617181920212223242526272829303132public class Folder extends AbstractSafeFile { ArrayList&lt;AbstractFile&gt; fileList = new ArrayList&lt;&gt;(); public Folder(String name) { super(name); } @Override public void addFile(AbstractFile file) { fileList.add(file); } @Override public void removeFile(AbstractFile file) { fileList.remove(file); } @Override public AbstractFile getFile(int index) { return fileList.get(index); } @Override public void getFileSuffix() { LogUtils.i(&quot;文件夹无后缀名&quot;); for (AbstractFile abstractFile : fileList) { abstractFile.getFileSuffix(); } }} Client 类： 12345678910111213141516171819TextFile text1 = new TextFile(&quot;text1&quot;);TextFile text2 = new TextFile(&quot;text2&quot;);JavaFile javaFile1 = new JavaFile(&quot;javaFile1&quot;);JavaFile javaFile2 = new JavaFile(&quot;javaFile2&quot;);Folder folder1 = new Folder(&quot;folder1&quot;);Folder folder2 = new Folder(&quot;folder2&quot;);Folder folder3 = new Folder(&quot;folder3&quot;);folder1.addFile(text1);folder1.addFile(javaFile1);folder2.addFile(text2);folder2.addFile(javaFile2);folder3.addFile(folder1);folder3.addFile(folder2);folder3.getFileSuffix(); 安全组合模式中的 Component 类不提供任何管理成员对象的方法，在 Composite 类中自己实现这些方法，这种做法虽然安全了，但是不能针对抽象编程，不够透明，要有区别的对待叶子对象和容器对象，正所谓鱼与熊掌不可兼得","link":"/2017/07/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-职责链模式","text":"职责链模式（Chain of Responsibility Pattern）：避免请求发送者与接受者耦合一起。把全部有可能接受请求的对象连接成一条链，并沿着这条链传递请求，知道有对象处理该请求为止。 假设有一个需求，当用户咨询客服时，需要根据用户的年龄提供不同的客服人员，先看一下传统的处理方式，下面是伪代码： Handler 类： 1234567891011121314151617181920212223242526272829303132333435363738public class PersonRequestHandler { private Person person; public PersonRequestHandler(Person person) { this.person = person; } public void handle() { int age = this.person.getAge(); if (age &lt; 5) { handleForChild(); } else if (age &lt; 23) { handleForYouth(); } else if (age &lt; 60) { handleForAdult(); } else { handleForOld(); } } private void handleForOld() { LogUtils.i(&quot;doSomething For Old&quot;); } private void handleForAdult() { LogUtils.i(&quot;doSomething For Adult&quot;); } private void handleForYouth() { LogUtils.i(&quot;doSomething For Youth&quot;); } private void handleForChild() { LogUtils.i(&quot;doSomething For Chile&quot;); }} 用这样的方式完全可以处理这个需求，但是只停留在完成需求这个阶段远远不够，这种方式有几个问题： 如果需要更细分年龄段 Handler 类会变的异常庞大，不易阅读和维护 所有的处理都放在该类中，违反了单一职责原则 如果需要增删处理方式，就需要修改该类，又违反了开闭原则 职责链模式的出现解决了上述的几个问题，先来看职责链模式的结构图： Handler（抽象处理者）：一般设计为抽象类，定义一个请求接口，不同的具体处理者处理请求的方式不同。因为每个处理者的下家还是一个处理者，因此抽象处理者中定义了一个抽象处理者的对象，作为对下家的引用，通过该引用，就可以把所有处理者形成一条链 Concrete（具体处理者）：抽象处理者的实现类，实现请求接口处理用户请求，处理请求前根据处理条件进行判断，看是否有能力处理，如果有就处理，没有则转发给下家 下面是利用职责链模式处理上面需求的伪代码： Handler 类： 12345678910public abstract class Handler { protected Handler successor; public void setSuccessor(Handler successor) { this.successor = successor; } public abstract void handleRequest(Person person);} ConcreteHandler 类： 12345678910111213141516171819202122232425262728293031323334353637383940414243// Childpublic class Child extends Handler { @Override public void handleRequest(Person person) { if (person.getAge() &lt; 5) { LogUtils.i(&quot;doSomething For Child&quot;); } else { this.successor.handleRequest(person); } }}// Youthpublic class Youth extends Handler { @Override public void handleRequest(Person person) { if (person.getAge() &lt; 23) { LogUtils.i(&quot;doSomething For Youth&quot;); } else { this.successor.handleRequest(person); } }}// Adultpublic class Adult extends Handler { @Override public void handleRequest(Person person) { if (person.getAge() &lt; 60) { LogUtils.i(&quot;doSomething For Adult&quot;); } else { this.successor.handleRequest(person); } }}// Oldpublic class Old extends Handler { @Override public void handleRequest(Person person) { LogUtils.i(&quot;doSomething For Old&quot;); }} 这种属于纯的职责链模式，ConcreteHandler 对象只能在处理和不处理两个行为中选择一个 如果是不纯的职责链模式是允许在处理请求时只处理一部分，然后继续往下家发送该请求；也可以全部处理完成后，再往下家发送；同时也允许该请求不被任何 ConCreteHandler 对象接收并处理 优点 职责链模式使得一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度 在给对象分派职责时，职责链可以给我们更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责 在系统中增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可，符合开闭原则 缺点 职责链模式没有一个明确的接收者，所以请求就不能保证一定会被处理 较长的职责链，处理请求涉及多个处理对象，给代码调试带来不便 如果建链不当，很可能导致循环调用，引发系统死循环 适用场景 一个请求可以被多个对象处理时，在运行时才能确定具体该由那个对象处理 需要动态指定处理者时，客户端可以动态建链，可以动态改变处理者在链中的次序","link":"/2017/09/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-装饰模式","text":"装饰模式（Decorator Pattern）：也可以称为包装模式（Wrapper Pattern），它动态给一个对象增加额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活，它是一种对象结构型模式。 装饰模式是一种用于替代继承的技术，通过一种无须定义子类的方式给对象动态增加职责，使用对象间的关联关系替代继承关系 Component（抽象组件类）：具体组件类和抽象装饰类共同父类，声明了具体组件中需要实现的方法，它的引入可以使调用者以一致的方式处理未装饰对象和装饰对象，实现调用者的透明操作 ConcreteComponent（具体组件类）：实现抽象组件类的声明的方法 Decorator（抽象装饰类）：用于增加具体组件的职责，它的子类实现具体职责，它持有一个具体组件类的引用，通过该引用可以调用未装饰前的方法，并通过子类扩展该方法 ConcreteDecorator（具体装饰类）：给具体组件类增加新方法 平时生活中，有很多需要送礼物的时候，一个好礼物更需要好包装来衬托，但是有时候买的礼物只有一个很丑陋的盒子，以装饰模式实现包装礼物的需求： Component 类： 1234567public abstract class Gift { /** * 礼物包装 */ public abstract void packaging();} ConcreteComponent 类： 123456public class BirthdayGift extends Gift { @Override public void packaging() { LogUtils.i(&quot;包装盒&quot;); }} Decorator 类： 123456789101112public abstract class GiftPackaging extends Gift { private Gift gift; public GiftPackaging(Gift gift) { this.gift = gift; } public void packaging() { gift.packaging(); }} ConcreteDecorator 类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 简易包装public class SimplePackaging extends GiftPackaging { public SimplePackaging(Gift gift) { super(gift); } @Override public void packaging() { super.packaging(); addColorSheet(); } private void addColorSheet() { LogUtils.i(&quot;包彩纸&quot;); }}// 奢华包装public class LuxuryPackaging extends GiftPackaging { public LuxuryPackaging(Gift gift) { super(gift); } @Override public void packaging() { super.packaging(); addColorSheet(); addRibbon(); addCard(); addGiftBox(); } private void addColorSheet() { LogUtils.i(&quot;包彩纸&quot;); } private void addRibbon() { LogUtils.i(&quot;加彩带&quot;); } private void addCard() { LogUtils.i(&quot;加贺卡&quot;); } private void addGiftBox() { LogUtils.i(&quot;加礼盒&quot;); }} Client 类： 123456789// 简易包装的礼物Gift gift = new BirthdayGift();Gift giftPackaging = new SimplePackaging(gift);giftPackaging.packaging();// 奢华包装的礼物Gift gift = new BirthdayGift();Gift giftPackaging = new LuxuryPackaging(gift);giftPackaging.packaging(); 透明装饰模式 上面实现的装饰模式叫做透明装饰模式，客户端可以完全针对抽象编程，装饰模式的透明性要求客户端不应该将对象类型声明为具体组件类型或者具体装饰类型，需要全部声明为抽象组件类型，对于客户端调用来说，具体组件对象和具体装饰对象是一样的，没有任何区别，可以一致处理这些对象，实现透明装饰模式时，要求具体装饰类的 operation() 方法覆盖抽象装饰类的 operation() 方法，除了调用具体组件类的 operation() 方法外，还需要调用新增的 addedBehavior() 方法来增加新职责。 透明模式可以对一个已装饰的对象再进行装饰，获得更复杂，功能更强大的对象。 半透明装饰模式 有透明装饰模式，就有对应的半透明装饰模式，有时我们需要单独调用新增方法，就不得不把对象声明为具体装饰类型，具体组件对象还是可以继续定义为抽象组件类型，这就是半透明装饰模式。 还是拿上面的栗子来说，如果包装礼物只想用丝带和彩纸包装或者再加一个礼袋，用半透明模式就会非常方便灵活，直接调用对应的方法就可以了，但是客户端需要区别对待装饰前后的对象 优点 利用关联关系替代继承关系，更加灵活，不会导致类个数急剧增加 透明装饰模式可以对一个对象进行多次装饰，通过使用不同的具体装饰类的组合，能得到功能更加强大的对象 具体组件类和具体装饰类可以独立变化，根据需求，在不变原来代码得基础上，增加这两个类，很符合“开闭原则” 缺点 既然是更加灵活的解决方法，出错的几率也随之变大，排查错误的困难也跟着变大","link":"/2017/07/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式-适配器模式","text":"适配器模式（Adapter Pattern）：将一个接口转换成调用者希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装类（Wrapper），该模式可以作为类结构型模式，也可以作为对象结构型模式 适配器模式应该是 Android 开发当中最常见的几个设计模式之一了，各种各样的列表（ListView，GridView，RecyclerView）都要使用一个 Adapter 的类 使用场景： 系统需要使用现有的类，而这些类的接口不符合系统的需要 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作 适配器模式一个可以分为三个适配器： 类适配器 对象适配器 缺省适配器 类适配器 Target：目标角色，可以是一个抽象类或接口，由于是类适配器，不能为具体类 Adaptee：适配者类，一般是一个具体类，包含期望的业务方法，某些情况下可能没有适配者的源代码 Adapter：适配器类，可以把源接口转换成目标接口 使用 Mac 的同学应该很熟悉上面的两个东西，Apple 的充电器可以把两脚的充电头拔掉换成一个更长且是三脚的充电头，下面就以这两个东西为示例，完成一个适配器模式，示例代码： Target 类： 123456public interface Power { /** * 充电 */ void charge();}在正常情况下用两脚的插头已经足够满足需求了，但是现在所处的环境只有三脚的插板，现在就可以把只支持三脚的插板看做是现有的接口，而默认的充电是不支持此接口的，这时候就需要用到三脚的适配器，示例代码： Adaptee 类，期望实现的功能： 123456public class ExtensionPower { public void specificPower() { LogUtils.i(&quot;用三脚，1.8米延长线充电&quot;); }} Adapter 类，三脚延长线： 1234567public class PowerAdapter extends ExtensionPower implements Power{ @Override public void charge() { super.specificPower(); }} Client 类： 1234public class Client { PowerAdapter powerAdapter = new PowerAdapter(); powerAdapter.charge();} 利用适配器模式就可以解决上述的问题，并且非常符合开闭原则 对象适配器 对象适配器不在使用类适配器继承再实现的方式，而是采用直接关联的方式，区别就在于 adapter 类： 1234567891011121314public class PowerAdapter implements Power { private ExtensionPower extensionPower; // 此处改为直接关联的方式 public PowerAdapter(ExtensionPower extensionPower) { this.extensionPower = extensionPower; } @Override public void charge() { this.extensionPower.specificPower(); }} 缺省适配器 当我们只想实现一个接口 N 多个方法中的一个时，就要用到该模式了，在具体实现类和接口中间设计一个抽象类实现该接口，并提供所有方法的空实现，具体实现类就可以继承抽象类，这样就可以选择自己想要实现的某一接口 举个栗子：一个已婚人士的生活是吃饭，睡觉以及啪啪啪，但是现在需要需要添加一个新的物种叫做单身狗，单身狗当然是没有啪啪啪功能的，这个时候就需要创建一个抽象类实现已婚人士这个接口，并让单身狗继承实现吃饭和睡觉的功能 示例代码： 已婚人士接口： 123456789101112131415161718public interface MarriedPeople { /** * 吃饭 */ void eat(); /** * 睡觉 */ void sleep(); /** * 啪啪啪 */ void papapa();} 抽象类： 12345678910111213141516public abstract class Adults implements MarriedPeople { @Override public void eat() { } @Override public void sleep() { } @Override public void papapa() { }} 单身狗： 12345678910public class SingleDog extends Adults { public void eat() { LogUtils.i(&quot;吃饭&quot;); } public void sleep() { LogUtils.i(&quot;睡觉&quot;); }} 说了这么多，该到总结的时候了，适配器模式优点： 使用适配器类达到重用先用适配者类，无须修改原有结构 增加类的透明性和复用性，具体业务逻辑都封装在适配者类中，提高适配者的复用性","link":"/2017/06/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"title":"Java 锁总结","text":"独享锁/互斥锁/方法锁/对象锁这部分锁意思大致相同，Synchronized 修饰的方法默认是当前对象为锁，Synchronized 修饰的静态方法默认是当前Class 对象为锁，方法执行，获取该锁，并且独占，其他线程无法获取锁；执行结束，释放该锁，所以对象中所有被 Synchronized 修饰的方法只能有一个能处于执行状态","link":"/2018/07/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java-%E9%94%81%E6%80%BB%E7%BB%93/"},{"title":"《Android 开发艺术探索》- 第一章内容总结","text":"生命周期 onCreate()Activity 开始创建，并且只会被调用一次 onStart()Activity 创建完成开始启动，此时的 Activity 已经可见，但是还没有出现在前台，不能交互，可以理解为已经显示出来了，但是还看不到 onRestart()Activity 重新启动，通常当 Activity 从不可见到可见会执行该声明周期函数，比如用户按下 Home 键或打开了一个新的 Activity 后再回到这个 Activity onResume()Activity 可见，Activity 此时在前台活动，onStart() 执行的时候这个 Activity 还是后台运行，直到 onResume() 这个 Activity 才在前台活动 onPause()Activity 正在停止，这个 Activity 的 onPause() 执行完毕才能执行新的 Activity 的 onResume()，所以不建议在 onPause() 里面做耗时操作，这样会影响打开新的 Activity 的速度 onStop()Activity 即将停止，onPause() 之后就会立即执行该生命周期函数，可以执行稍微重量级的回收工作。理想状态下 onPause() 后快速回到当前 Activity，onStop() 则不会执行 onDestory()Activity 即将销毁，此时可以执行一些资源回收等操作 常见情况 Activity 首次启动：onCreate() -&gt; onStart() -&gt; onResume() 返回桌面或打开新的 Activity：onPause() -&gt; onStop() 重新回到这个 Activity：onRestart() -&gt; onStart() -&gt; onResume() 返回键或者调用 finish() 函数：onPause() -&gt; onStop() -&gt; onDestroy() A Activity 启动 B Activity Activity Method A onPause() B onCrete() B onStart() B onResume() A onStop() 需要对源码进行分析 异常情况分别有两种情况： 系统配置发生变化，例如横竖屏切换 系统内存不足杀掉 Activity 这种情况下生命周期函数执行顺序就为： 1234567891011s=&gt;start: 横竖屏切换或者Activity被杀死e=&gt;end: 执行结束op1=&gt;operation: onPause()op2=&gt;operation: onSaveInstanceState()op3=&gt;operation: onStop()op4=&gt;operation: onDestroy()op5=&gt;operation: onCreate()op6=&gt;operation: onStart()op7=&gt;operation: onRestoreInstanceState()op8=&gt;operation: onResume()s-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;op5-&gt;op6-&gt;op7-&gt;op8-&gt;e 由于 Activity 是因为异常原因才结束的，所以在结束的时候会调用 onSaveInstanceState() 函数保存状态，该函数的调用顺序和 onPause() 函数并没有既定的时序关系，可能是 onPause() 之前也可能是之后，Activity 被重新创建后会调用 onRestoreInstanceState() 函数中的 Bundle 就是之前保存在的 onSaveInstanceState() 中的数据，并且此时 onCreate() 中的参数也同样是该 Bundle 对象 Activity 异常结束并重新创建的过程中，系统同时把该 Activity 的视图结构也保存了下来，所以同 Activity 一样，所有的 View 也都具有 onSaveInstanceState() 和 onRestoreInstanceState() 函数 Activity 的优先级可以分为三级： 前台 Activity：可见并可交互，优先级最高 可见非前台 Activity：当 Activity 被弹窗遮盖时 后台 Activity：已经暂停的 Activity，优先级最低，系统内存不足时优先回收此类 Activity 如果不想在系统配置发生变化时，销毁并重新创建 Activity，可以在 AndroidManifest.xml 中配置该 Activity 的属性,从 Android 3.2（API 级别 13）开始，当设备在纵向和横向之间切换时，屏幕尺寸也会发生变化。因此，在开发针对 API 级别 13 或更高版本的应用时，若要避免由于设备方向改变而导致运行时重启，则除了 “orientation” 值以外，您还必须添加 “screenSize” 值： 123&lt;activity android:name=&quot;Activity&quot; android:configChanges=&quot;orientation|screenSize&quot;&gt;&lt;/activity&gt; 所有下列字符串均是该属性的有效值： Dialog 弹出弹出和隐藏 Dialog 时并不会执行所在 Activity 的任何生命周期，因为 Dialog 被看做是依附在 Activity 的一个 View，可以理解为它本来就是 Activity 的一部分 启动模式standard 标准模式系统默认模式，每次启动 Activity 都会在当前 Activity 所在栈中创建一个实例，Activity 的生命周期函数正常执行，不管这个实例是否存在任务栈中，如果使用 ApplicationContext 启动一个 Activity，就会报错： 1Caused by: android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want? 报错信息说的很清楚，startActivity() 函数被非 Activity Context 调用需要加上 FLAG_ACTIVITY_NEW_TASK 标识，之所以会报这个错是因为，Application Context 并没有运行在一个承载 Activity 实例的任务栈中，加上该标识后，再次启动就会为此 Activity 实例单独创建一个任务栈，此时该 Activity 实际上是以 singleTask 模式启动 singleTop 栈顶复用模式该模式下，如果即将启动的 Activity 的实例已经存在任务栈中且位于栈顶，该 Activity 实例则不会被创建，并且位于栈顶的 Activity 的 onNewIntent 函数会被回调，如果新 Activity 的实例存在任务栈中，但并没有位于栈顶，新 Activity 实例依旧会正常创建 singleTask 栈内复用模式这是一种单例模式，只要新 Activity 实例在任务栈中存在，不管是否位于栈顶，都不会创建新的实例。当 singleTask 模式的 Activity 启动时，系统会先找是否存在该 Activity 实例所需的任务栈，如果不存在则新建一个任务栈存放该 Activity 实例，如果存在并且该任务栈中存在该 Activity 的实例，则把该实例调到栈顶并回调其 onNewIntent 函数同时会移除该任务栈中位于 Activity 实例上方的所有实例，如果不存在实例，就创建新 Activity 实例并压入栈内 如果 K 需要任务栈 T，T 中此时有 AKBC，任务栈中存在 K，所有就不会重新创建，系统会把 K 调到栈顶，同时回调 onNewIntent 函数，由于 singleTask 具有 clearTop 效果，所有此时的任务栈中情况为：AK singleInstance 单实例模式可以理解为增强型的 singleTask 模式，它除了具有 singleTask 所有属性外，还有就是具有该模式的 Activity 实例都会拥有单独属于自己的任务栈 特殊情况singleTask singletTop singleInstance 三种模式下，如果新 Activity 的实例没有创建，复用任务栈中的实例对象，生命周期只会执行 onPause onResume，以及回调 onInstance 函数 singleTask 模式下会有一种特殊情况： 前台任务栈存在 12，后台任务栈存在 XY，当启动 Y 时，整个后台任务栈都会切换到前台，此时从 Y 返回，其实是到 X，并不是到 2。如果启动 X ，那么 Y 就会直接出栈 设置 Activity 启动模式有两种设置方式： AndroidMinifest.xml 文件中设置 123&lt;activity android:name=&quot;.Activity&quot; android:launchMode=&quot;singleInstance&quot;&gt;&lt;/activity&gt; Java 文件中设置 123Intent intent = new Intent(this, SecondActivity.class);intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);startActivity(intent); 如果两种方式同时存在，Java 文件中的设置方式优先级要高于 AndroidMinifest.xml 文件中的设置方式。其次上述两种设置方式的限定范围也有所不同，第一种方式不能直接为 Activity 设置 FLAG_ACTIVITY_CLEAR_TOP 标识，第二种方式设置 singleInstance 启动模式 TaskAffinity上提到 singleTask 启动模式中，Activity 会寻找所需的任务栈，taskAffinity 参数标识了 Activity 所需任务栈的名字，默认情况下所有 Activity 所需任务栈名称都是包名，taskAffinity 主要和 singleTask 模式或者 allowTaskReparenting 属性配合使用，下面有一个 taskAffinity 和 singleTask 模式配合使用的例子： 有 A、B、C 三个 Activity，包名是 org.lovedev.chapter_1，其中 A 没有设置任何参数，B 和 C 的启动模式都为 singleTask，taskAffinity 都设置为 org.lovedev.kevin。A 启动 B，B 启动 C，C 再启动 A，此时使用 adb shell dumpsys activity 命令查看下任务栈情况： 可以看到当前具有两个任务栈，由于 A 的启动模式是 standard，所有在 C 启动 A 时，系统会为 A 创建一个新的实例，压入启动它的那个栈中，此时再从 A 启动 B，接着看一下任务栈情况： 由于 B 的启动模式为 singleTask ，由于 singleTask 的 clearTop 特性，系统销毁任务栈中 B 上面的所有实例，此时如果按返回键，B 出栈，B 所在任务栈中已经没有实例，所以该任务栈也就不存在了，此时回到最初启动的 A 所在后台任务栈： Activity 的 Flags FLAG_ACTIVITY_NEW_TASK 指定 singleTask 启动模式 FLAG_ACTIVITY_SINGLE_TOP 指定 singleTop 启动模式 FLAG_ACTIVITY_CLEAR_TOP 通常和 FLAG_ACTIVITY_NEW_TASK 配合使用，如果启动模式是 standard，那么该 Activity 实例和之上的所有实例都将出栈，系统会重新创建该 Activity 新的实例压入该栈中 隐式启动想要隐式启动 Activity 需要 Intent 对象能够匹配上目标组件的 IntentFilter 中所设置的过滤条件，IntentFilter 过滤条件有 action、category、data： 1234567891011121314151617181920212223&lt;activity android:name=&quot;.IntentFilterActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;org.lovedev.kevin01&quot;/&gt; &lt;action android:name=&quot;org.lovedev.kevin02&quot;/&gt; &lt;action android:name=&quot;org.lovedev.kevin03&quot;/&gt; &lt;category android:name=&quot;org.lovedev.category01&quot;/&gt; &lt;category android:name=&quot;org.lovedev.category02&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;data android:host=&quot;org.lovedev&quot; android:scheme=&quot;http&quot;/&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;org.lovedev.kevin04&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;data android:mimeType=&quot;image/*&quot;/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 需要注意的是，一个过滤列表可以有多个 action、category、data 属性，也可以有多个过滤列表 action 匹配规则intent 中的 action 只要和过滤规则中的任意一条 action 匹配即可，action 匹配区分大小写 category 匹配规则intent 可以设置多个 category，但是每个 category 都需要匹配上过滤规则中的 category 才算成功，也可以不设置 category，因为在 startActivity 默认添加了 android.intent.category.DEFAULT 这个 category， 所以过滤条件中必须添该 category data 匹配规则data 语法如下： 1234567&lt;data android:scheme=&quot;string&quot; android:host=&quot;string&quot; android:port=&quot;string&quot; android:path=&quot;string&quot; android:pathPattern=&quot;string&quot; android:pathPrefix=&quot;string&quot; android:mimeType=&quot;string&quot; /&gt; 其中包括两部分，URI 和 mimeType，mimeType 是指媒体类型，例如 image/jpeg、audio/mpeg4-generic、image/*，URI 包含数据就比较多了，URI 结构如下： 1&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;] 示例如下： 1http://www.lovedev.org/andrid/activity 如果 URI 中没有指定 scheme，整个 URI 参数无效 如果 host 未指定，整个 URI 参数同样无效 需要注意的是，如果过滤规则中只指定了 mimeType，未指定 URI，如下所示： 1234567&lt;intent-filter&gt; &lt;action android:name=&quot;org.lovedev.kevin&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;data android:mimeType=&quot;image/*&quot;/&gt;&lt;/intent-filter&gt; 这种情况下会有默认的 URi，默认值为 content 和 file 判断规则是否匹配如果不进行判断隐式启动是否是否匹配，就出抛出异常，导致应用崩溃，可以使用 Intent 的 resolveActivity 函数或者 PackageManager 的 resolveActivity 函数进行判断是否匹配，使用方法参考官方 API 文档： [PackageManager.resolveActivity](https://developer.android.com/reference/android/content/pm/PackageManager.html#resolveActivity(android.content.Intent, int)) Intent.resolveActivity","link":"/2018/01/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AAndroid-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"},{"title":"面向对象六大原则","text":"在学习设计模式之前，需要了解一下面向对象的六大原则，设计模式大多都遵循这些原则，写代码时心中时刻不要忘记六大原则，利用它们能写出更整洁、低耦合、高内聚的代码，更加清晰的逻辑 该文章由网上以及书籍上的资料整理而来 :) 六大原则 单一职责原则 里氏替换原则 依赖倒置原则 接口隔离原则 迪米特法则 开闭原则 单一职责原则 Single Responsibility Principle，简称SRP，对一个类而言，应该仅有一个引起它变化的原因，即一个类只负责一项职责 问题描述当类 C 负责两个不同的职责：职责 M1，职责 M2，职责 M1 需求发生改变需要改变类 C 的时候，很有可能影响到原先的职责 M2 的功能 解决方案一个类只负责一个职责，当需求改变时，不会影响到其他职责 里氏替换原则 Liskov Substitution Principle，简称LSP，所有引用基类的地方必须能透明地使用其子类的对象 问题描述有一个功能 M，由类 C 完成，由于业务需要，需要拓展 M 功能 M1，此时需要由类 C 的子类 C1 完成拓展功能，当 C1 完成 M1 功能的同时，有可能导致原来 M 功能不可用 解决方案当使用继承时，遵循里氏替换原则。类 M1 继承类 M 时，除添加新的方法完成 M1 的新增功能外，尽量不要重写父类 C 的方法，也尽量不要重载父类 C 的方法 继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障 依赖倒置原则 Dependence Inversion Principle，简称DIP 高层模块不应该依赖低层模块，高层模块是调用类，低层模块是实现类 二者都应该依赖其抽象，抽象指接口或抽象类 细节应该依赖抽象，细节指实现类 问题描述有 B 和 C 两个实现类，类 A 直接依赖类 B，这种场景下，类 A 一般为高层模块，负责复杂业务逻辑，类 B 和类 C 是低层模块，负责原子操作，如果需要把类 A 改为依赖类 C，必须通过修改类 A 源代码，可能会引入不必要的风险 Tip： 原子操作：不可分割的，在执行完毕之前不会被任何其它任务或事件中断的操作 解决方案将类 A 修改为依赖接口 I ，类 B 和类 C 各自实现接口 I ，类 A 通过接口 I 间接与类 B 或者类 C 发生联系，则会大大降低修改类A的几率 示例代码： 1234567891011121314151617181920212223242526interface Animal{ public String getFood();}class Cat implements Animal { @Override public String getFood() { return &quot;鱼&quot;; }}class Dog implements Animal{ @Override public String getFood() { return &quot;骨头&quot;; }}class Master { // 依赖Animal接口 public void feed(Animal animal) { String food = animal.getFood(); }} 接口隔离原则 Interface Segregation Principle，简称ISP，一个类对另一个类的依赖应该建立在最小的接口上 问题描述类 A 通过接口 I 依赖类 B，类 C 通过接口 I 依赖类 D，如果接口 I 对于类 A 和类 B 来说不是最小接口，则类 B 和类 D 必须去实现他们不需要的方法 解决方案将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则 迪米特法则 Law of Demeter，简称LoD，也称为最少知识原则（Principle of Least Knowledge）或得墨忒耳定律，一个对象应该对其他对象保持最少的了解 问题描述类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大 解决方案尽量降低类与类之间的耦合 开闭原则 Open Close Principle，简称OCP，对象应该对扩展开放，对修改关闭，开闭原则是面向对象设计中最基础的设计原则 问题描述在软件的开发工程中，因为需求变化，升级，重构和维护等原因，需要修改源代码，这样很有可能引入错误 解决方案当软件有变化时，尽量通过扩展的行为实现变化，而不是通过修改已有的代码实现变化","link":"/2017/05/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"},{"title":"《Android 开发艺术探索》- 第九章内容总结","text":"startActivity文章参考了gityuan博客，以及《Android 开发艺术探索》，基本 Android API 27 源码分析，旨在理解整个 Activity 启动的流程，忽略代码细节 1.1 Activity#startActivitystartActivity 启动一个 Activity，且不会收到该 Activity 退出通知，如果不指定 Intent#FLAG_ACTIVITY_NEW_TASK 标志，该 Activity 会被添加到调用者的栈中 12345678@Overridepublic void startActivity(Intent intent, @Nullable Bundle options) { if (options != null) { startActivityForResult(intent, -1, options); } else { startActivityForResult(intent, -1); }}该函数最终会调用 startActivityForResult，startActivityForResult 启动一个 Activity 时，该 Activity 退出时 onActivityResult 会被回调，且携带传入的 requestCode 1.2 Activity#startActivityForResult使用 startActivityForResult 的时候 Intent 不能设置 flag。比如，设置 Intent#FLAG_ACTIVITY_NEW_TASK 后，就会立马收到一个 cancel 的通知 还有一个特殊的情况：如果在 Activity 的 onCreate/onResume 中使用 startActivityForResult，必须等到有返回结果时，该 Activity 才会显示出来，这是为了避免重定向时造成闪屏 12345678910111213141516171819202122public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) { if (mParent == null) { options = transferSpringboardActivityOptions(options); // 重点代码 Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) { mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); } if (requestCode &gt;= 0) { mStartedActivity = true; } cancelInputsAndStartExitTransition(options); } else { ... }}mParent == null 这个条件是成立的，mParent 在 Activity#attach 中被赋值，在后面的源码分析中会发现其实 attach 中 parent 参数就是 null 1.3 Instrumentation#execStartActivity接下来看 Instrumentation#execStartActivity，可能由于版本的问题，在官方文档中并没有找到对该函数的解释，但是源码中确实是有的，提取有用的信息大意如下： 执行一个 startActivity 的请求，默认实现是负责更新活动对象并此调用分派给 system activity manager 12345678910111213141516171819public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) { ... try { intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(who); // 重点代码 int result = ActivityManager.getService() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); } catch (RemoteException e) { throw new RuntimeException(&quot;Failure from system&quot;, e); } return null;}ActivityManager.getService().startActivity 也就证明了上面对该函数解释，其实 ActivityManager.getService() 获得的就是 IActivityManager 类型的 IBinder 对象，所以这个 Binder 对象的具体实现就是 ActivityManager(AMS)，利用单例模式对外提供实例： 12345678910111213public static IActivityManager getService() { return IActivityManagerSingleton.get();}private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton = new Singleton&lt;IActivityManager&gt;() { @Override protected IActivityManager create() { final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); final IActivityManager am = IActivityManager.Stub.asInterface(b); return am; } }; 1.4 ActivityManagerService#startActivity123456789@Overridepublic final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) { // 重点代码 return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId());} 1.5 ActivityManagerService#startActivityAsUser123456789101112@Overridepublic final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) { enforceNotIsolatedCaller(&quot;startActivity&quot;); userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null); // 重点代码 return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, bOptions, false, userId, null, &quot;startActivityAsUser&quot;);}在该函数中又将调用转入到一个新的类中 ActivityStarter 1.6 ActivityStarter#startActivityMayWait123456789101112131415161718192021222324252627final int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration globalConfig, Bundle bOptions, boolean ignoreTargetSecurity, int userId, TaskRecord inTask, String reason) { // 保护性拷贝，不会修改客户端的 Intent 对象 intent = new Intent(intent); ... // 解析 Intent 中的内容 ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo); ... final ActivityRecord[] outRecord = new ActivityRecord[1]; // 继续调用 startActivityLocked 获取返回值并返回 int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason); Binder.restoreCallingIdentity(origId); ... return res; }}通过 ActivityStackSupervisor#resolveActivity 获取 Activity 的信息，传递给 startActivityLocked 1.7 ActivityStarter#startActivityLocked123456789101112131415161718int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, TaskRecord inTask, String reason) { ... // 继续调用 startActivity 获取返回值并返回 mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord, inTask); ... // Aborted results are treated as successes externally, but we must track them internally. return mLastStartActivityResult != START_ABORTED ? mLastStartActivityResult : START_SUCCESS;} 1.8 ActivityStarter#startActivity12345678910111213/** DO NOT call this method directly. Use {@link #startActivityLocked} instead. */private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, TaskRecord inTask) { ... // 只用关心最后这行代码，继续调用 startActivity 的重载方法 return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask, outActivity);} 1234567891011121314151617181920212223private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) { int result = START_CANCELED; try { mService.mWindowManager.deferSurfaceLayout(); // 重点代码 result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, doResume, options, inTask, outActivity); } finally { if (!ActivityManager.isStartResultSuccessful(result) &amp;&amp; mStartActivity.getTask() != null) { mStartActivity.getTask().removeActivity(mStartActivity); } mService.mWindowManager.continueSurfaceLayout(); } postStartActivityProcessing(r, result, mSupervisor.getLastStack().mStackId, mSourceRecord, mTargetStack); return result;} 1.9 ActivityStarter#startActivityUnchecked1234567891011private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) { ... // 重点代码 mTargetStack.startActivityLocked(mStartActivity, topFocused, newTask, mKeepCurTransition, mOptions); ... return START_SUCCESS;}ActivityStarter 主要的任务就是收集 Intent 和 flag，并且转换为一个 ActivityStack 对象，调用 ActivityStack#startActivityLocked 2.0 ActivityStack#startActivityLocked12345678910final void startActivityLocked(ActivityRecord r, ActivityRecord focusedTopActivity, boolean newTask, boolean keepCurTransition, ActivityOptions options) { TaskRecord rTask = r.getTask(); final int taskId = rTask.taskId; if (!r.mLaunchTaskBehind &amp;&amp; (taskForIdLocked(taskId) == null || newTask)) { // 把当前 Activity 放到栈顶 insertTaskAtTop(rTask, r); } ...}从该函数源码中可以猜测出它的作用一方面在操作 Activity 的堆栈，Activity 的动画以及和 WindowManagerService 的交互，之后还要回到 ActivityStarter#startActivityUnchecked 2.1 ActivityStarter#startActivityUnchecked123456789101112131415161718192021222324252627private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) { ... if (mDoResume) { final ActivityRecord topTaskActivity = mStartActivity.getTask().topRunningActivityLocked(); if (!mTargetStack.isFocusable() || (topTaskActivity != null &amp;&amp; topTaskActivity.mTaskOverlay &amp;&amp; mStartActivity != topTaskActivity)) { mTargetStack.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS); mWindowManager.executeAppTransition(); } else { if (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) { mTargetStack.moveToFront(&quot;startActivityUnchecked&quot;); } // 重点代码 mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity, mOptions); } } else { mTargetStack.addRecentActivityLocked(mStartActivity); } ... return START_SUCCESS;} 2.2 ASS#resumeFocusedStackTopActivityLocked12345678910111213141516171819202122boolean resumeFocusedStackTopActivityLocked( ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) { if (!readyToResume()) { return false; } if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) { // 重点代码 return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); } final ActivityRecord r = mFocusedStack.topRunningActivityLocked(); if (r == null || r.state != RESUMED) { // 重点代码 mFocusedStack.resumeTopActivityUncheckedLocked(null, null); } else if (r.state == RESUMED) { mFocusedStack.executeAppTransition(targetOptions); } return false;} 2.3 ASS#resumeTopActivityUncheckedLocked123456789101112131415161718192021boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) { if (mStackSupervisor.inResumeTopActivity) { // Don&apos;t even start recursing. return false; } boolean result = false; try { // 重点代码 mStackSupervisor.inResumeTopActivity = true; result = resumeTopActivityInnerLocked(prev, options); } finally { mStackSupervisor.inResumeTopActivity = false; } final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */); if (next == null || !next.canTurnScreenOn()) { checkReadyForSleep(); } return result;} 2.4 ASS#resumeTopActivityInnerLocked该函数中调用了 ActivityStackSupervisor#startSpecificActivityLocked 2.5 ASS#startSpecificActivityLocked123456789101112131415161718192021222324252627void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) { // Is this activity&apos;s application already running? ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); r.getStack().setLaunchTime(r); if (app != null &amp;&amp; app.thread != null) { try { if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0 || !&quot;android&quot;.equals(r.info.packageName)) { app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode, mService.mProcessStats); } // 重点代码 realStartActivityLocked(r, app, andResume, checkConfig); return; } catch (RemoteException e) { Slog.w(TAG, &quot;Exception when starting activity &quot; + r.intent.getComponent().flattenToShortString(), e); } } mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, &quot;activity&quot;, r.intent.getComponent(), false, false, true);} 2.6 ASS#realStartActivityLocked123456789101112final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException { ... app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, mergedConfiguration.getGlobalConfiguration(), mergedConfiguration.getOverrideConfiguration(), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); ...}其中 app.thread 就是 IApplicationThread，而 IApplicationThread 的实现类是 ActivityThrea 的内部类 ApplicationThread 2.7 AT#scheduleLaunchActivity12345678910111213141516171819202122232425262728293031323334@Overridepublic final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) { updateProcessState(procState, false); // 重点代码 ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; r.overrideConfig = overrideConfig; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r);}可以看到这里初始化了一个 ActivityClientRecord 对象，其中 parent 并没有初始化，这个 parent 字段正是 Activity 中的为 mParent 赋值的那个变量，此时把这个初始化完成的对象交给 Handler 处理： 12345678910case LAUNCH_ACTIVITY: { Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); // 重点代码 handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);} break;继续调用 handleLaunchActivity 2.8 AT#handleLaunchActivity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) { // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; if (r.profilerInfo != null) { mProfiler.setProfiler(r.profilerInfo); mProfiler.startProfiling(); } // Make sure we are running with the most recent config. handleConfigurationChanged(null, null); if (localLOGV) Slog.v( TAG, &quot;Handling launch of &quot; + r); // Initialize before creating the activity if (!ThreadedRenderer.sRendererDisabled) { GraphicsEnvironment.earlyInitEGL(); } WindowManagerGlobal.initialize(); // 到这里 Activity 对象被创建出来 Activity a = performLaunchActivity(r, customIntent); if (a != null) { r.createdConfig = new Configuration(mConfiguration); reportSizeConfigurations(r); Bundle oldState = r.state; handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) { performPauseActivityIfNeeded(r, reason); if (r.isPreHoneycomb()) { r.state = oldState; } } } else { // If there was an error, for any reason, tell the activity manager to stop us. try { ActivityManager.getService() .finishActivity(r.token, Activity.RESULT_CANCELED, null, Activity.DONT_FINISH_TASK_WITH_ACTIVITY); } catch (RemoteException ex) { throw ex.rethrowFromSystemServer(); } }} 2.9 AT#performLaunchActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { // System.out.println(&quot;##### [&quot; + System.currentTimeMillis() + &quot;] ActivityThread.performLaunchActivity(&quot; + r + &quot;)&quot;); // 获取 Activity 的组件信息 ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) { r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); } ComponentName component = r.intent.getComponent(); if (component == null) { component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); } if (r.activityInfo.targetActivity != null) { component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); } // 创建 ContextImpl 对象 ContextImpl appContext = createBaseContextForActivity(r); // 通过 Instrumentation#newActivity 创建 Activity 对象 Activity activity = null; try { java.lang.ClassLoader cl = appContext.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) { r.state.setClassLoader(cl); } } catch (Exception e) { if (!mInstrumentation.onException(activity, e)) { throw new RuntimeException( &quot;Unable to instantiate activity &quot; + component + &quot;: &quot; + e.toString(), e); } } // 通过 LoadedApk#makeApplication 创建 Application 对象 // 其中 makeApplication 的实现中，如果 Application != null 就直接返回 // 证明了 Application 对象只有一个 try { Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (localLOGV) Slog.v(TAG, &quot;Performing launch of &quot; + r); if (localLOGV) Slog.v( TAG, r + &quot;: app=&quot; + app + &quot;, appName=&quot; + app.getPackageName() + &quot;, pkg=&quot; + r.packageInfo.getPackageName() + &quot;, comp=&quot; + r.intent.getComponent().toShortString() + &quot;, dir=&quot; + r.packageInfo.getAppDir()); if (activity != null) { CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (r.overrideConfig != null) { config.updateFrom(r.overrideConfig); } if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot; + r.activityInfo.name + &quot; with config &quot; + config); Window window = null; if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) { window = r.mPendingRemoveWindow; r.mPendingRemoveWindow = null; r.mPendingRemoveWindowManager = null; } appContext.setOuterContext(activity); // 在这里完成 Activity 数据的初始化，把 Activity 和 Context 关系起来 // attach 函数中还会完成 Window 的创建以及与 Activity 相关联 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback); if (customIntent != null) { activity.mIntent = customIntent; } r.lastNonConfigurationInstances = null; checkAndBlockForNetworkAccess(); activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) { activity.setTheme(theme); } activity.mCalled = false; // 在这里 Activity 的 onCreate 函数最终被调用 if (r.isPersistable()) { mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnCreate(activity, r.state); } if (!activity.mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + r.intent.getComponent().toShortString() + &quot; did not call through to super.onCreate()&quot;); } r.activity = activity; r.stopped = true; if (!r.activity.mFinished) { activity.performStart(); r.stopped = false; } if (!r.activity.mFinished) { if (r.isPersistable()) { if (r.state != null || r.persistentState != null) { mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); } } else if (r.state != null) { mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); } } if (!r.activity.mFinished) { activity.mCalled = false; if (r.isPersistable()) { mInstrumentation.callActivityOnPostCreate(activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnPostCreate(activity, r.state); } if (!activity.mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + r.intent.getComponent().toShortString() + &quot; did not call through to super.onPostCreate()&quot;); } } } r.paused = true; mActivities.put(r.token, r); } catch (SuperNotCalledException e) { throw e; } catch (Exception e) { if (!mInstrumentation.onException(activity, e)) { throw new RuntimeException( &quot;Unable to start activity &quot; + component + &quot;: &quot; + e.toString(), e); } } return activity;} 总结 [1.1 ~ 1.3]：运行在调用者所在进程，比如从桌面启动Activity，则调用者所在进程为launcher进程，launcher进程利用ActivityManagerService作为Binder Client，进入system_server进程(AMS相应的Server端) [1.4 ~ 2.7]：运行在system_server系统进程 1.6：resolveActivity() 解析 Intent 中包含的内容，并创建 ActivityRecord 对象 1.7：给 ActivityRecord 赋值 1.9：为Activity找到或创建新的Task对象，设置flags信息 2.6：system_server 进程利用 ApplicationThread（Binder Client） 把任务传递到目标进程 [2.8 ~ 2.9]：运行在目标进程，通过Handler消息机制，该进程中的Binder线程向主线程发送H.LAUNCH_ACTIVITY，最终会通过 Instrumentation#newActivity 创建目标Activity，然后进入onCreate()生命周期 下图以及App 启动流程来自Gityuan 博客 APP 启动流程： 点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求； system_server进程接收到请求后，向zygote进程发送创建进程的请求； Zygote进程fork出新的子进程，即App进程； App进程，通过Binder IPC向sytem_server进程发起attachApplication请求； system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进程发送scheduleLaunchActivity请求； App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息； 主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法GG","link":"/2018/07/09/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AAndroid-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B-%E7%AC%AC%E4%B9%9D%E7%AB%A0%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"},{"title":"《Android 开发艺术探索》- 第二章内容总结","text":"多进程创建多个进程Android 中使用多进程的方式只有一种，就是给四大组件在 AndroidManifest.xml 配置 android:process 属性： 123456&lt;activity android:name=&quot;.FirstActivity&quot; android:process=&quot;:kevin&quot;&gt;&lt;/activity&gt;&lt;activity android:name=&quot;.SecondActivity&quot; android:process=&quot;org.lovedev.chapter_2.kevin&quot;&gt;&lt;/activity&gt; 不配置 android:process 属性，默认进程名就是包名org.lovedev.chapter_2 FirstActivity 的进程名是 org.lovedev.chapter_2:kevin，以 : 开头的进程名配置，属于当前应用的私有进程，其他应用的组件不可以和他跑在同一个进程当中 SecondActivity 的进程名是 org.lovedev.chapter_2.kevin，其他应用可以通过 ShareUID 的方式和它跑在同一个进程中 启动两个 Activity 后，查看运行的进程： 运行机制Android 为每个进程都会分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，这就导致了不同的虚拟机访问同一对象会产生多个副本。 举例说明，创建一个 Constant 类： 123public class Constant { public static int index = 1;}在 MainActivity 中修改 index 的值为 2，在 FirstActivity 中再次访问 index 的值，发现该值还是 1，并且打印 Constant 对象的 hashCode 值也是不同的。 多进程还会造成以下问题： 静态成员和单例模式失效 线程同步机制失效 SharedPreferences 可靠性下降，因为 SharedPreferences 底层是通过读/写 xml 文件实现的，并发写很可能会有问题，所以多进程中 SharedPreferences 同时执行写操作会导致数据丢失 Application 多次创建，虚拟机创建进程的过程就是启动一个应用的过程，运行在不同进程中的组件也具有不同的 Application，下图是启动不同进程 Activity 时，Application 中的打印信息 序列化当程序需要 Intent 或 Binder 传递数据时需要使用 Parcelable 或 Serializable 接口完成序列化过程，有时还需要把对象持久化到存储设备或通过网络传输给其他客户端，此时也需要 Serializable 来完成对象的持久化 Serializable 接口Serializable 接口是 Java 提供的序列化接口，为对象提供标准的序列化和反序列化操作。实现起来特别简单，只需要实现该接口就可以了，下面提供一个典型的持久化对象的例子： 123456789101112131415161718192021222324public void serializable(View view) { User user = new User(); user.name = &quot;kevin&quot;; user.age = 25; String filePath = Environment.getExternalStorageDirectory().getAbsolutePath() + &quot;/user.txt&quot;; File file = new File(filePath); try { ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file)); out.writeObject(user); out.close(); } catch (IOException e) { e.printStackTrace(); } try { ObjectInputStream input = new ObjectInputStream(new FileInputStream(file)); User u = (User) input.readObject(); input.close(); Log.d(TAG, &quot;serializable: &quot; + u.name); } catch (IOException | ClassNotFoundException e) { e.printStackTrace(); }} 此外还需要注意的是实现 Serializable 接口的对象可以声明一个 serialVersionUID，有时即使不声明也不会影响对象的序列化和反序列化，这个 serialVersionUID 是用来辅助序列化和反序列化的，只有序列化后数据中的 serialVersionUID 和反序列化对象中的 serialVersionUID 相同才能反序列化成功，相当于类的唯一标识。需要注意的是静态变量属于类不属于该类的对象以及 transient 关键字标记的成员变量不参与序列化过程。 Parcelable 接口Parcelable 接口是 Android 提供的序列化接口，在 Andorid Studio 中有很多插件可以自动实现 Parcelable 接口，不需要手动写。 serializable 使用简单，但是开销很大，序列化和反序列化都需要 I/O 操作。Parcelable 使用麻烦，但有现成的插件，而且更适用于 Android 平台。Parcelable 主要用于内存序列化上，对于序列化对象到存储设备或网络传输，使用 Parcelable 稍显麻烦，这两种情况建议使用 Serializable。 BinderBinder 是 Android 的一个实现了 IBinder 接口的类，它是 Android 中特有的，Linux 中不在。从 IPC 的角度来看，它是 Android 中进程通讯的一种方式。可以把 Binder 理解为一个虚拟的物理设备，它的设备驱动是 /dev/binder；从 Android Framwork 层来说，Binder 是 ServiceManager 连接各种 Service 以及 Manager（ActivityManager、WindowService等）的桥梁；从应用层来说，Binder 是客户端和服务端进行通信的媒介。下面分析通过 IBookManager.aidl 生成的类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145public interface IBookManager extends android.os.IInterface { /** * Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements org.lovedev.chapter_2.IBookManager { // Binder 的唯一标识，一般用当前的全类名表示 private static final java.lang.String DESCRIPTOR = &quot;org.lovedev.chapter_2.IBookManager&quot;; /** * Construct the stub at attach it to the interface. */ public Stub() { this.attachInterface(this, DESCRIPTOR); } /** * 将服务器端的 Binder 对象转换为客户端所需要的 AIDL 接口类型对象 * 该转换是区分进程的，如果客户端和服务端在同一个进程中，该方法就返回服务器的 Stub 对象本身 * 否则返回的是系统封装后的 Stub.proxy 对象 */ public static org.lovedev.chapter_2.IBookManager asInterface(android.os.IBinder obj) { if ((obj == null)) { return null; } android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof org.lovedev.chapter_2.IBookManager))) { return ((org.lovedev.chapter_2.IBookManager) iin); } return new org.lovedev.chapter_2.IBookManager.Stub.Proxy(obj); } /** * 返回当前 Binder 对象自身 */ @Override public android.os.IBinder asBinder() { return this; } /** * 该方法运行在 Binder 线程池中，当客户端对该 Binder 对象发起跨进程请求时，远程请求会通过系统底层封装后交由该方法进行处理 * 服务端可以通过 code 参数判断所请求的方法是那个，然后从 data 中取出该方法所需参数，然后执行目标方法 * 当目标方法执行完毕之后，就向 reply 中写入返回值（如果该方法有返回值的话） * 注意：如果该方法返回的 false，客户端的请求就会失败，可以利用该特性来做权限验证 */ @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException { switch (code) { case INTERFACE_TRANSACTION: { reply.writeString(DESCRIPTOR); return true; } case TRANSACTION_getBookList: { data.enforceInterface(DESCRIPTOR); java.util.List&lt;org.lovedev.chapter_2.Book&gt; _result = this.getBookList(); reply.writeNoException(); reply.writeTypedList(_result); return true; } case TRANSACTION_addBook: { data.enforceInterface(DESCRIPTOR); org.lovedev.chapter_2.Book _arg0; if ((0 != data.readInt())) { _arg0 = org.lovedev.chapter_2.Book.CREATOR.createFromParcel(data); } else { _arg0 = null; } this.addBook(_arg0); reply.writeNoException(); return true; } } return super.onTransact(code, data, reply, flags); } private static class Proxy implements org.lovedev.chapter_2.IBookManager { private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) { mRemote = remote; } @Override public android.os.IBinder asBinder() { return mRemote; } public java.lang.String getInterfaceDescriptor() { return DESCRIPTOR; } /** * 当客户端调用该方法时，首先创建该方法所需的 _data 和 _reply，然后把该方法的参数写入到 _data 中 * 接着调用 transact 方法发起 RPC（远程调用）请求，同时当前线程挂起 * 然后服务端的 onTransact 方法会被调用，直到 RPC 过程返回后，当前线程继续执行，从 _reply 中取出 RPC 过程的返回结果 * 最后返回 _reply 中的数据 */ @Override public java.util.List&lt;org.lovedev.chapter_2.Book&gt; getBookList() throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.util.List&lt;org.lovedev.chapter_2.Book&gt; _result; try { _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0); _reply.readException(); _result = _reply.createTypedArrayList(org.lovedev.chapter_2.Book.CREATOR); } finally { _reply.recycle(); _data.recycle(); } return _result; } @Override public void addBook(org.lovedev.chapter_2.Book book) throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try { _data.writeInterfaceToken(DESCRIPTOR); if ((book != null)) { _data.writeInt(1); book.writeToParcel(_data, 0); } else { _data.writeInt(0); } mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0); _reply.readException(); } finally { _reply.recycle(); _data.recycle(); } } } // 为两个方法声明整型 ID 标识，用于区分客户端所请求的到底是那个方法 static final int TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); static final int TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); } public java.util.List&lt;org.lovedev.chapter_2.Book&gt; getBookList() throws android.os.RemoteException; public void addBook(org.lovedev.chapter_2.Book book) throws android.os.RemoteException;} 通过上面的分析已经了解了 Binder 的工作机制，但还有两点需要注意一下： 客户端发起请求时，由于当前线程会被挂起，直至服务端进程返回数据，所以如果一个远程方法很耗时，就不能在 UI 线程中发起此远程请求 由于服务端的 Binder 方法运行在 Binder 线程池中，所以 Binder 方法不管是否耗时都应该采用同步方式去实现，因为它已经运行在一个线程中了。 进程间通讯文件共享对于数据同步要求不高的进程间通讯可以通过文件共享的方式完成。 Windows 中对文件加了排斥锁将会导致其他线程无法访问，包括读写，但是 Android 是基于 Linux 系统，所以对文件的并发读写完全没有限制。在使用文件共享这种方式的时候，记得处理好并发读写的情况 Android 中的 SharedPreferences 是一个轻量级的储存方案，它通过键值对来存储数据，其实底层实现上是采用 XML 文件来存储键值对，应用的 SharedPreferences 文件路径是 /data/data/package_name/shared_prefs，其中 package_name 是应用的包名。本质上讲 SharedPreferences 也是文件的一种，但是 Android 系统对于它的读写都有一定的缓存策略，即在内存中有一份 SharedPreferences 文件的缓存。因此在多进程环境下，系统对它的读写就变得不可靠，面对高并发的读写时，SharedPreferences 有很大几率会丢失数据。不建议在进程间通讯使用 SharedPreferences。 Messager可以使用 Messenger 在进程间传递 Message 对象消息，它的底层实现是 AIDL。 服务端进程需要创建一个 Service 处理客户端的连接请求，同时创建 Handler 对象，并作为参数创建一个 Messenger 对象，同时在 onBind 函数中返回该 Messenger 对象底层的 Binder ： 1234567891011121314151617181920212223public class MessengerService extends Service { private static final String TAG = &quot;MessengerService&quot;; public MessengerService() { } // 2. 自定义 Handler 对象接收并处理消息 private static final class MessengerHandler extends Handler { @Override public void handleMessage(Message msg) { Log.i(TAG, &quot;MessengerService received message: &quot; + msg.getData()); } } // 1. 创建 Messenger 对象 private final Messenger mMessenger = new Messenger(new MessengerHandler()); @Override public IBinder onBind(Intent intent) { return mMessenger.getBinder(); }} 同时在 AndroidManifest.xml 中注册该 Service： 12345678910&lt;service android:name=&quot;.MessengerService&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot; android:process=&quot;:remote&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;org.lovedev.messenger&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;/intent-filter&gt;&lt;/service&gt; 客户端需要根据服务端绑定 Service 时的 action 进行绑定： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MessengerActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_messenger); Intent service = new Intent(); service.setAction(&quot;org.lovedev.messenger&quot;); // Android 5.0 以上必须执行该函数，否则会报 Service Intent must be explicit 错误 service.setPackage(getPackageName()); bindService(service, mConnection, Context.BIND_AUTO_CREATE); } private Messenger mMessenger; private ServiceConnection mConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { mMessenger = new Messenger(service); } @Override public void onServiceDisconnected(ComponentName name) { } }; public void send(View view) { Message message = Message.obtain(null, 1); Bundle data = new Bundle(); data.putString(&quot;data&quot;, &quot;MessengerActivity&apos;s data&quot;); message.setData(data); try { mMessenger.send(message); } catch (RemoteException e) { e.printStackTrace(); } } @Override protected void onDestroy() { super.onDestroy(); unbindService(mConnection); }} 在 Messenger 中传递数据时，必须将数据放入 Message 中传递，Messenger 和 Message 对象都实现了 Parcelable 接口，因此可以跨进程传输。Message 参数中有一个 object 字段在同一进程间通信非常实用，但是进程间通信，只有系统提供的实现了 Parcelable 接口的对象才可以通过它进行通信。 AIDLAIDL 文件支持的数据类型： 基本数据类型 String 和 CharSequence List：只支持 ArrayList，且内部元素必须是被 AIDL 所支持 Map：只支持 HashMap，key 和 value 必须被 AIDL 所支持 实现 Parcelable 接口的对象 AIDL 自定义的 Parcelable 对象和 AIDL 对象必须显示 import 进来，在使用自定义 Parcelable 对象时，必须新建一个与该对象同名的 AIDL 文件，并且声明它为 Parcelable 类型，例如 Book.aidl 文件： 12package org.lovedev.chapter_2;parcelable Book; 为了方便 AIDL 开发，一般情况下都把所有 AIDL 相关文件放入同一个包中，客户端和服务端需要保证 AIDL 文件包结构的一致性，否则会运行报错，因为客户端需要反序列化服务端中和 AIDL 接口相关的类，如果类的完整路径不一致，就无法反序列化成功，客户端在使用的时候也需要把实现 Parcelable 接口的对象拷贝到项目中，保持和服务端包名一致。 如果需要在服务端注册 listener，不能使用普通的 List 对象保存 listener，因为 AIDL 在传递对象的时候是通过反序列化获取对象的，所以前后两个对象不相等。此时就需要用 RemoteCallbackList 来保存客户端的 listener，RemoteCallbackList 内部维护一个 Map 对象，以 IBinder 对象作为 Key，listener 被封装为一个 Callback 对象。在需要删除 listener 的时候，遍历并找出该对象具有的 IBinder 所有 listener 中与之相同的进行删除。 RemoteCallbackList 在使用的时候需要注意 beginBroadcast() 和 finishBroadcast() 成对出现，RemoteCallbackList 内部实现了线程同步，使用的时候无须关心线程同步问题，而且当客户端进程终止的时候 RemoteCallbackList 会自动解除该客户端的所有监听。 处理 Binder 对象意外死亡有两种方式： 创建一个 IBinder.DeathRecipient 对象，并在 binderDied 函数中处理意外死亡后的逻辑，该函数在 Binder 线程被回调 在 ServiceConnection 的 onServiceDisconnected 函数中处理意外死亡，该函数在 UI 线程被回调 客户端调用服务端的远程函数时，客户端的调用线程会被挂起，onServiceConnected 和 onServiceDisconnected 都执行在 UI 线程，如果远程方法是耗时操作，客户端调用的时候又在 UI 线程，避免在这两个函数中调用远程函数。很有可能会导致 ANR。被调用的远程方法运行在 Binder 线程池中，服务端的函数本身可以执行耗时操作，没有必要再创建线程执行。 ContentProviderSocket上面两种使用方式比较常规多见，不再记录 Binder 连接池如果服务端程序存在很多个服务给客户端调用，如果用常规创建服务的方式的话，在应用详情中查看服务端程序就会存在很多服务，这是很不友好的。此时需要使用 Binder 连接池，创建 Binder 连接池和创建一般的服务流程是一样的，只不过提供了根据 Flag 查询并返回对应服务的接口 IPC 方式总结 方式 优点 缺点 适用场景 Bundle 简单易用 只能传输 bundle 支持的类型 四大组件间的通讯 文件 简单易用 不适合高并发通讯，不能做到即时通讯 无并发，不需要即时通讯 AIDL 一对多并发通讯 即时通讯 需要自行处理线程同步 一对多通讯且有 RPC 需求 Messenger 一对多串行通讯 实时通讯 不支持高并发，不支持 RPC， 利用 bundle 传输， 低并发一对多即时通讯， 无 RPC 需求，或者不需要返回值的 RPC 需求 ContentProvider 一对多并发数据共享 理解为受约束的 AIDL，提供数据源的 CRUD 操作 一对多进程间的数据共享 Socket 功能强大，通过网络传输字节流，支持一对多实时通讯 实现复杂，不支持直接的 RPC 使用网络交换数据 服务启动方式 方式 区别 startService 执行后台任务，不进行通信。停止服务使用stopService bindService 进行通信。停止服务使用unbindService startService&amp;bindService 使用stopService与unbindService 注意事项 如果 onBind 返回的是 null，则不会调用 onServiceConnected 和 onServiceDisconnected 函数 调用unBinder接口时，service先调用onUnBind，然后调用onDestroy，但是最后没有调用 onServiceDisconnected 接口，这个接口只有异常出错才会调用","link":"/2018/01/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AAndroid-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"},{"title":"《Android 开发艺术探索》- 第十章内容总结","text":"Android 的消息机制主要就是 Handler 机制，Handler 的主要应用场景就是在子线程中更新 UI，在 ViewRootImpl 中有一个检测当前线程的函数： 123456void checkThread() { if (mThread != Thread.currentThread()) { throw new CalledFromWrongThreadException( &quot;Only the original thread that created a view hierarchy can touch its views.&quot;); }}其中 mThread 就是主线程，只要更新 UI 的线程不是主线程就会抛出这个让人熟悉的异常 有时候还有用到 Activity#runOnUiThread 这个函数在子线程更新 UI，看一下该函数源码可以发现其内部实现同样采用了 Handler，如果当前线程是主线程就直接执行，如果不是的话需要 post 到消息池中： 1234567public final void runOnUiThread(Runnable action) { if (Thread.currentThread() != mUiThread) { mHandler.post(action); } else { action.run(); }} Handler 还包含了其他两部分内容，分别是：MessageQueue 和 Looper MessageQueueMessageQueue 通常也叫做消息池，其中有两个关键函数，enqueueMessage 处理插入数据的操作，next 函数处理获取以及移除消息的操作，先看一下 enqueueMessage 的源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) { if (msg.target == null) { throw new IllegalArgumentException(&quot;Message must have a target.&quot;); } if (msg.isInUse()) { throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); } synchronized (this) { if (mQuitting) { IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; } msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) { // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; } else { // Inserted within the middle of the queue. Usually we don&apos;t have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) { prev = p; p = p.next; if (p == null || when &lt; p.when) { break; } if (needWake &amp;&amp; p.isAsynchronous()) { needWake = false; } } msg.next = p; // invariant: p == prev.next prev.next = msg; } // We can assume mPtr != 0 because mQuitting is false. if (needWake) { nativeWake(mPtr); } } return true;}相比其他类的源码，还算比较简单的了，只从该函数的源码中就可以看得出来 MessageQueue 的数据结构是一个单链表，MessageQueue 主要作用是用来存取数据的，链表对于存取操作性能优于其他数据结构，再来看一下 next 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106Message next() { // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) { return null; } int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; // 从这里可以看出这是一个无限循环 for (;;) { if (nextPollTimeoutMillis != 0) { Binder.flushPendingCommands(); } nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) { // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) { // Stalled by a barrier. Find the next asynchronous message in the queue. do { prevMsg = msg; msg = msg.next; } while (msg != null &amp;&amp; !msg.isAsynchronous()); } if (msg != null) { if (now &lt; msg.when) { // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); } else { // Got a message. mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; } } else { // No more messages. nextPollTimeoutMillis = -1; } // Process the quit message now that all pending messages have been handled. if (mQuitting) { dispose(); return null; } // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) { pendingIdleHandlerCount = mIdleHandlers.size(); } if (pendingIdleHandlerCount &lt;= 0) { // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; } if (mPendingIdleHandlers == null) { mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; } mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); } // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) { final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try { keep = idler.queueIdle(); } catch (Throwable t) { Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t); } if (!keep) { synchronized (this) { mIdleHandlers.remove(idler); } } } // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; }}从源码中可以看出 next 函数中有一个无限循环，如果消息池中不存在消息了，next 函数就会一直阻塞 Looper分析 Looper 前需要了解另外一个类 ThreaLocal，这个类为线程提供了存储局部变量的能力，每个线程都有自己独立初始化的变量副本，下面一个例子能帮助理解： 1234567891011val threadLocal: ThreadLocal&lt;String&gt; = ThreadLocal()threadLocal.set(&quot;main&quot;)println(Thread.currentThread().name + &quot; threadLocal: &quot; + threadLocal.get())thread(name = &quot;thread_001&quot;) { threadLocal.set(&quot;thread_001&quot;) println(Thread.currentThread().name + &quot; threadLocal: &quot; + threadLocal.get())}thread(name = &quot;thread_002&quot;) { println(Thread.currentThread().name + &quot; threadLocal: &quot; + threadLocal.get())}执行结果： 123main threadLocal: mainthread_001 threadLocal: thread_001thread_002 threadLocal: null在理解了 ThreadLocal 之后再来分析 Looper，首先看一下 Looper 的创建过程： 123456789101112131415public static void prepare() { prepare(true);}private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); } sThreadLocal.set(new Looper(quitAllowed));}private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();}其中 sThreadLocal 就是 ThreadLocal 类的实例，在构造函数中又会初始化一个 MessageQueue 实例，让 Looper 运行的关键是 loop 函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public static void loop() { final Looper me = myLooper(); if (me == null) { throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); } final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) { Message msg = queue.next(); // might block if (msg == null) { // No message indicates that the message queue is quitting. return; } // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) { logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); } final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) { Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); } final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); final long end; try { msg.target.dispatchMessage(msg); end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); } finally { if (traceTag != 0) { Trace.traceEnd(traceTag); } } if (slowDispatchThresholdMs &gt; 0) { final long time = end - start; if (time &gt; slowDispatchThresholdMs) { Slog.w(TAG, &quot;Dispatch took &quot; + time + &quot;ms on &quot; + Thread.currentThread().getName() + &quot;, h=&quot; + msg.target + &quot; cb=&quot; + msg.callback + &quot; msg=&quot; + msg.what); } } if (logging != null) { logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); } // Make sure that during the course of dispatching the // identity of the thread wasn&apos;t corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) { Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); } msg.recycleUnchecked(); }}可以看出该函数和 MessageQueue#next 一样，内部也是一个无限循环，当 next 返回 null 时才会退出该循环，当调用了 quit 函数后 next 函数返回 null，其中 Looper 中有两个函数 quit、quitSafely 都调用了 MessageQueue#quit，其中 quitSafely 是等消息池中所有消息执行完之后才退出，而 quit 则是立即退出 在 loop 中有这么一行代码 msg.target.dispatchMessage(msg)，这行代码是处理消息的关键。其中 msg.target 就是当前的 Handler 对象，且该操作是在 Looper 中执行，所以不管 Handler 在任何地方发送消息，最终消息都会在创建 Handler 的线程中执行","link":"/2018/07/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AAndroid-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B-%E7%AC%AC%E5%8D%81%E7%AB%A0%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"},{"title":"《Java 并发编程实战》","text":"第一章一个非线程安全类的例子： 1234567class Test { private var value: Int = 0 fun add(): Int { return ++value }}这个例子非线程安全类的原因是因为 ++value 是一个非原子性操作，下面是 ++value 的在多线程中的分解步骤： 活跃性问题安全性目标 - 永远不要发生糟糕的事情活跃性目标 - 某件正确的事情最终会发生 当某个操作无法继续执行下去时，就会发生活跃性问题 在单线程中，活跃性问题的形式之一就是无意中造成无限循环，从而使得循环之后的代码无法得到执行 在多线程中的活跃性问题，比如如果线程A在等待线程B释放其持有的资源，而线程B永远不会释放该资源。那么线程A就会永远等待下去，无法执行 性能问题无论如何，线程总会带来某种程度的运行时开销，在多线程程序中，当线程调度器临时挂起活跃线程并转而运行另一个线程时，就会频繁地出现上下文切换操作。这种操作将带来极大的开销:保存和恢复执行上下文。丢失局部性，并且CPU时间将更多地花在线程调度，而不是线程运行上。当线程共享数据时，必须使用同步机制，而这些机制往往会抑制某些编译器优化，使内存缓冲区中的数据无效，以及增加共享内存总线的同步流量 第二章线程安全性同步机制关键字是synchronized，它提供了一种独占的解锁方式，但同步这个术语还包括volatile类型的变量，显示锁以及原子变量。 一个可变状态变量没有使用合适的同步程序就会出现问题。有三种解决方式: 不在线程之间共享该状态变量 将状态变量修改为不可变变量 在访问状态变量时使用同步 并发代码编写的原则：首先代码要正确运行，之后再提高代码的速度，即便如此，最好也只是当性能测试和应用需求告诉你必须提高性能，以及测量结果表明这种优化在实际环境中确实能带来性能提升时，才进行优化 当多个线程访问某个类时，不管运行时环境采用何种调度方式，或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步和协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的 在线程安全类的内部已经封装了必要的同步机制，客户端无需进一步采取同步措施 不包含过任何变量，也不包括任何对其他类种变量的引用，这样的对象就叫做无状态对象。无状态对象一定是线程安全的 原子性++value 操作并非线程安全的，因为这个操作并非原子性的。它并不会作为一个不可分割的操作来执行。它包含了三个独立的操作： 读取value的值 将值加1 将计算后的值写入value这是一个读取 - 修改 - 写入的操作序列，并且其结果状态依赖于之前的状态 竞态条件由于不恰当的执行时序而出现不正确的结果 基于一种可能失效的观察结果来做出判断，或者执行某个操作这种类型的竞态条件称为先“检查后执行”：首先观察到某个条件为真，然后根据这个观察结果执行相应的动作。但事实上，在你观察到这个结果以及开始相应的动作之间，观察结果可能变得无效，从而导致各种问题 1234567891011class LazySingleton { private static LazySingleton instance; private LazySingleton (){} public static LazySingleton getInstance() { if (instance == null) { instance = new LazySingleton(); } return instance; }} 懒汉式单例类就是就是一个坏例子，在获取实例前会检查这个实例是否存在。如果不存在，则创建这个实例。在创建这个实例之前很有可能其他线程也已经检测到该实例不存在也创建了该实例对象 加锁机制如果在不变性条件中涉及多个变量，各个变量之间并不是彼此独立存在的。而是某个变量的值会对其他变量的值产生约束。在更新某一变量时，就需要在同一个原子操作中对其他变量同时进行更新 要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量 内置锁同步代码块包括两部分： 锁的对象引用 由这个锁保护的代码块关键字synchronized修饰的方法就是横跨整个方法体的时候同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的synchronized方法，以class对象作为锁 每个java对象都可以用作一个实现同步的锁，这些锁被称为内置锁或监视器锁 内置锁相当于一种互斥体或叫做互斥锁。这意味着最多只有一个线程能持有这种锁 重入某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然而由于内置锁是可重入的。因此，如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会变成功 重入的实现方法：为每个锁关联一个计数器和一个所者线程。当计数器为零时，这个锁就被认为没有被任何线程持有。当线程请求一个未被持有的锁匙。记下锁的持有者，并且将计数器置为1。如果同一个线程再次获取这个锁，计数器将递增，而当线程退出同步代码块时，计数器会相应递减。计数器数值为零时，这个锁将被释放 下面的代码子类重写了父类的同步方法，并且调用了父类的同步方法： 12345678910111213141516171819202122232425class SynchronizedTest { @Test fun test() { val child:Parent = Child() child.syaHello() } open class Parent { @Synchronized open fun syaHello() { println(this.javaClass.name) println(&quot;parent say hello&quot;) } } class Child : Parent() { @Synchronized override fun syaHello() { println(this.javaClass.name) println(&quot;child say hello&quot;) super.syaHello() } }} 输出结果： 1234org.lovedev.concurrent.SynchronizedTest$Childchild say helloorg.lovedev.concurrent.SynchronizedTest$Childparent say hello可以看出两个锁对象是同一个，如果没有重入机制，在获取锁的情况下调用 super.syaHello() 就会因为该锁没有被释放无法获取，导致线程一直阻塞 用锁保护状态被多线程同时访问的可变数据和可变变量都应该有一个锁来保护 对于每个包含多个变量的不变性条件，其中涉及的所有变量都应该由同一个锁来保护 即便是每个方法上都加上synchronized关键字。对于多个同步方法的复合操作，程序还会出现同步问题，这是因为多个同步方法的调用不属于原子操作 活跃性与性能通常在简单性与性能之间存在着相互制约因素，当实现某个同步策略时，一定不要盲目的为了性能而牺牲简单性。这很可能会破坏安全性 当执行时间较长的计算或者无法快速完成的I/O操作时一定不要持有锁","link":"/2018/07/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AJava-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B/"},{"title":"《深入理解 JVM 虚拟机》- 笔记二","text":"","link":"/2017/06/29/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B-%E7%AC%94%E8%AE%B0%E4%BA%8C/"},{"title":"《深入理解 Java 虚拟机》- 笔记一","text":"Java 虚拟机（英语：Java Virtual Machine，缩写为JVM）屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行，通过对中央处理器（CPU）所执行的软件实现，实现能执行编译过的Java程序码 程序计数器程序计数器是一块较小内存空间，可以看作是当前线程所执行的字节码的行号指示器，在虚拟机的概念模型中，字节码解释器就是通过改变计数器的值选取下一条需要执行的字节码执行，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖该计数器完成 多线程是通过线程轮流切换并分配处理器执行时间的方式实现的，同一时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令，为了保证线程切换后，能够恢复到正确的执行位置，每条线程都有一个独立的程序计数器，这类内存区域为线程私有的内存。 线程如果执行的是 Java 方法，该计数器记录的是正在执行的虚拟机字节码指令地址，如果是 Native 方法计数器值则为空（Undefined），该内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域 Java 虚拟机栈Java Virtual Machine Stacks，该栈也是线程私有的，生命周期和线程相同。虚拟机栈描述的是 Java 方法执行的内存模式：每个方法都会在执行的同时创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息，方法从调用直至执行完成的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程，经常提到的栈内存就是说的虚拟机栈，或者说是虚拟机栈中的局部变量表部分 局部变量表存放了编译期可知的各种基础数据类型、reference类型和 returnAddress类型，其中64位长度的 long 和 double 类型的数据会占用2个局部变量空间，其余只占用1个，局部变量表所需内存空间在编译期间分配完成，进入一个方法时，该方法需要在帧中分配多大局部变量空间已经确定，在方法运行期间不会改变局部变量表的大小 在 Java 虚拟机规范中，对该区域规定了两种异常状况： 线程请求的栈深度大于虚拟机允许的深度，将抛出 StackOverFlowError 异常 如果虚拟机栈支持动态扩展，扩展时无法申请到足够内存，将抛出 OutOfMemoryError 异常 本地方法栈Native method stack，虚拟机栈为虚拟机执行的 Java 方法服务，本地方法栈为 Native 方法服务，sun hotspot虚拟机就把这两个栈区域合二为一，该栈同样会抛出虚拟机栈的两个异常 Java堆Java heap，Java虚拟机管理的最大的一个区域，用来存放对象实例，被所有线程共享。 Java虚拟机规范规定:所有对象实例和数组都要在堆上分配。随着栈上分配和标量替换等虚拟机优化技术的出现，堆上分配的说法也不是那么绝对了 Java堆是GC管理的最主要区域之一，堆又分为新生代和老年代，在GC使用Copying算法时，新生代又分为Edan space，From survivor space，To survivor space Java堆可以处于物理上不连续，但逻辑上连续的内存空间，就像电脑磁盘空间一样 可以通过以下参数扩展虚拟机内存: Xms-初始化堆大小 Xmx-java heap最大值 Xmn-年轻代堆大小 Xss-每个线程的栈大小 如果堆中没有足够的内存空间分配给实例，并且无法扩展时将会抛出 OutOfMemoryError 异常 方法区Method area，为了和 Java 堆区分，它还可以叫做Non-Heap（非堆）。各个线程共享的内存区域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译出的代码等 该区域还有一个常叫的名字：永久代（Permanent Generation），这种叫法不太准确，本质上两者并不等价，在HotSpot虚拟机为了可以像管理 Java 堆一样管理该区域，使用GC分代收集中永久代实现方法区，省去了编写内存管理代码的工作。 -XX:MaxPermSize 可以指定永久代的内存上限，在JDK8之前的HotSpot虚拟机中，32位机器默认的永久代的大小为64M，64位的机器则为85M。永久代的垃圾回收和老年代的垃圾回收是绑定的，一旦其中一个区域被占满，这两个区都要进行垃圾回收。但是有一个明显的问题，由于我们可以设置永久代的大小，一旦类的元数据超过了设定的大小，程序就会耗尽内存，并出现内存溢出错误 从 JDK1.7 开始已经逐步移除永久代，在 JDK1.7 中存储在永久代的部分数据就已经转移到了Java Heap 或者是 Native Heap。但永久代仍存在于JDK1.7中，并没完全移除，譬如符号引用(Symbols)转移到了native heap，字面量(interned strings)转移到了java heap，类的静态变量(class statics)转移到了java heap 在 JDK1.8 中，HotSpot 虚拟机已经没有 PermGen space 这个区域了，取而代之的是 Metaspace（元空间） 元空间元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小： -XX:MetaspaceSize：初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值 -XX:MaxMetaspaceSize：最大空间，默认是没有限制的 除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性： -XX:MinMetaspaceFreeRatio：在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集 -XX:MaxMetaspaceFreeRatio：在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集 运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分，Class 文件除了有类的版本、字段、方法、接口等描述信息，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 运行时常量池相对于 Class 文件常量池的一个重要特征就是具备动态性，Java 语言并非只有预置到 Class 文件常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量加到池中，这种特性被利用的比较多是 String 类的 intern() 方法（想要了解该方法的同学请戳这里） 运行时常量池是方法区内的一部分，自然也收到了方法区大小的限制，无法申请到内存时同样也会抛出 OutOfMemoryError 异常 直接内存直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域，这块区域也被频繁使用，也可能抛出 OutOfMemoryError 异常 JDK 1.4之后加入了NIO（new Input/Output）类，引入一种基于通道（channel）和缓冲区（Buffer）的 I/O 方式（想要了解 NIO 更加形象的介绍请戳这里），它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作，因为避免了在Java 堆和 Native 堆中来回复制数据，在一些情况下能够显著的提升性能 直接内存不会受到 Java 堆大小限制，但是会受到本机总内存大小以及处理器寻址空间的限制，在配置虚拟机参数时，如果忽略了直接内存，使各个内存区域总和物理内存限制，在动态扩展时就会出现 OutOfMemoryError 异常 基础数据类型 基础数据类型包括boolean、byte、char、short、int、float、long、double reference类型 1A a = new A();该类型就是常见的引用类型，它并不等同于a对象本身， 可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或与此对象相关的位置 在程序设计中，句柄（handle）是一种特殊的智能指针。 当一个应用程序要引用其他系统（如数据库、操作系统）所管理的内存块或对象时，就要使用句柄 returnAddress类型 该类型指向一条虚拟机指令的操作码地址，与其他类型不同的是，该类型没有对应的 Java 语言类型 栈深度 可以简单的理解栈为数组，栈的深度，理解为数组的长度 字面量 字面量是指由文字所表示的取值 123final int i = 100;String s = &quot;hello world&quot;;// 100 和 &quot;hello world&quot; 都可以叫做字面量，i 是常量，s 是变量 符号引用 在JVM中，类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段 而解析阶段即是虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用以一组符号描述所引用的对象，符号可以是任何形式的字面量，只要该组符号使用时具有唯一性并且能够无歧义定位到目标即可，符号引用与虚拟机的内存布局无关，引用的目标并不一定要加载到内存中，当一个 Java 类编译成 Class 文件时，Java 类中并不知道自己类中所引用的那些类或者接口的实际地址，因此只能使用符号引用代替，各种虚拟机内存布局可能不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式已经明确定义在 Java 虚拟机规范的 Class 文件格式中 举个例子，更直观的理解符号引用： 123456789public interface K { public static String str = &quot;abc&quot;; public static int i = new Random().nextInt();}public class Test { public static String i = K.str; public static int i = K.i;} 使用 javac 命令把上面两个 Java 文件编译成 Class 文件，然后使用 javap 命令反编译和查看编译器编译后的字节码，加上 -verbose 参数可以输出栈大小，方法参数个数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# 进入文件所在目录$ javac Test.java$ javap -verbose TestClassfile /Users/Kevin/IDEAProjects/Test/src/Test.class Last modified 2017-6-27; size 348 bytes MD5 checksum 740d6b24ac085239bccf8ed09980b232 Compiled from &quot;Test.java&quot;public class Test minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #8.#20 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Class #21 // K #3 = String #22 // abc #4 = Fieldref #7.#23 // Test.ss:Ljava/lang/String; #5 = Fieldref #2.#24 // K.i:I #6 = Fieldref #7.#25 // Test.ii:I #7 = Class #26 // Test #8 = Class #27 // java/lang/Object #9 = Utf8 ss #10 = Utf8 Ljava/lang/String; #11 = Utf8 ii #12 = Utf8 I #13 = Utf8 &lt;init&gt; #14 = Utf8 ()V #15 = Utf8 Code #16 = Utf8 LineNumberTable #17 = Utf8 &lt;clinit&gt; #18 = Utf8 SourceFile #19 = Utf8 Test.java #20 = NameAndType #13:#14 // &quot;&lt;init&gt;&quot;:()V #21 = Utf8 K #22 = Utf8 abc #23 = NameAndType #9:#10 // ss:Ljava/lang/String; #24 = NameAndType #28:#12 // i:I #25 = NameAndType #11:#12 // ii:I #26 = Utf8 Test #27 = Utf8 java/lang/Object #28 = Utf8 i{ public static java.lang.String ss; descriptor: Ljava/lang/String; flags: ACC_PUBLIC, ACC_STATIC public static int ii; descriptor: I flags: ACC_PUBLIC, ACC_STATIC public Test(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 6: 0 static {}; descriptor: ()V flags: ACC_STATIC Code: stack=1, locals=0, args_size=0 0: ldc #3 // String abc 2: putstatic #4 // Field ss:Ljava/lang/String; 5: getstatic #5 // Field K.i:I 8: putstatic #6 // Field ii:I 11: return LineNumberTable: line 7: 0 line 8: 5}SourceFile: &quot;Test.java&quot;可以看到有很多信息，其中有一个 Constant pool 就是Class 文件常量池，下表列出了所有常量池标志的名字和值： Entry Type Description ONSTANT_Utf8 UTF-8 编码的 Unicode 字符串 CONSTANT_Integer int 字面量 CONSTANT_Float float 字面量 CONSTANT_Long long 字面量 CONSTANT_Double double 字面量 CONSTANT_Class class 或者 interface 符号引用 CONSTANT_String String 字面量 CONSTANT_Fieldref field 符号引用 CONSTANT_Methodref method 符号引用 CONSTANT_InterfaceMethodref interface 中 method 的符号引用 CONSTANT_NameAndType 方法和字段的一部分符号引用 每一个标志都有一个相对应的表，表名通过在标志后加上“_info”后缀来产生。例如，对应于CONSTANT_Class标志的表名为CONSTANT_Class_info，表名为CONSTANT_Utf8_info的表中存储着Unicode字符串的压缩形式 对应着此表再来看 javap -verbose Test.class 中的信息，看到在初始化 Test 中的 ii 和 ss 的过程： 12345678910111213static {}; descriptor: ()V flags: ACC_STATIC Code: stack=1, locals=0, args_size=0 0: ldc #3 // String abc 2: putstatic #4 // Field ss:Ljava/lang/String; 5: getstatic #5 // Field K.i:I 8: putstatic #6 // Field ii:I 11: return LineNumberTable: line 7: 0 line 8: 5 因为 K 接口中的 str 字段是在编译期就可以确定的常量值，所有当 Test 引用该常量的时候，虚拟机直接把 str 的 “abc” 直接复制了一份到到 Test 的常量池中，#3就是该值得位置，但是当初始化 Test 的 ii 变量时，从常量池#5项中取值，常量池的第5项是一个符号引用，指向K的i字段。i的值只能在运行的时候才能确定，在运行的时候会将符号引用解析为指向i内存地址的直接引用 处理器寻址空间 数据在存储器（RAM）中存放的数据是有规律的，CPU 取数据时需要知道数据的位置，此时需要一个个数据的挨个寻找，这种行为叫做寻址，但是 CPU 的能力始终有限，超出 CPU 能力范围的数据就取不到了，CPU 寻址最大范围就是寻址空间，单位是字节","link":"/2017/06/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B-%E7%AC%94%E8%AE%B0%E4%B8%80/"},{"title":"《Android 开发艺术探索》- 第三章内容总结","text":"View基础 TouchSlop系统所能识别的最小滑动距离，ViewConfiguration#getScaledTouchSlop() 可以获取到该值，frameworks/base/core/res/res/values/config.xml 中的 config_viewConfigurationTouchSlop 对应的就是该值 VelocityTracker速度追踪，用于追踪手机横向竖向滑动的速度 GestureDetector手势识别 Scroller弹性滑动对象，实现 View 的弹性滑动 滑动 scrollTo/scrollBy 动画 改变布局参数 事件传递boolean dispatchTouchEvent (MotionEvent ev)如果事件传递到当前的 View，该方法一定会调用，返回值受到当前 View 的 onTouchEvent() 和子 View 的 dispatchTouchEvent() 的影响，表示是否消耗当前事件 boolean onInterceptTouchEvent (MotionEvent ev)dispatchTouchEvent() 中调用该函数，表示是否拦截当前事件，如果当前 ViewGroup 拦截了该事件，那么同一事件序列中，不会再调用该函数 boolean onTouchEvent (MotionEvent ev)dispatchTouchEvent() 中调用该函数，表示是否消费当前事件，默认为 true，返回 true 表示消耗，false 表示消耗。如果不消耗，该 View 将不会接受同一事件序列中任何事件 123456789public boolean dispatchTouchEvent(MotionEvent event){ boolean consume = false; if (onInterceptTouchEvent(event)){ consume = onTouchEvent(event); } else { consume = child.dispatchTouchEvent(event); } return consume;} 如果 View 设置了 onTouchEventListener()，只有 onTouchEventListener() 的返回值是 false 才执行 view 的 onTouchEvent()， onTouchEventListener() 的优先级比 onTouchEvent() 优先级要高，onClickListener() 优先级最低 ViewGroup 的 onInterceptTouchEvent() 方法任何事件返回 true 拦截之后，同一事件序列中后续的事件将都交给该 ViewGroup 处理，且不会调用 onInterceptTouchEvent()。这个行为很好理解，因为已经拦截了该事件，所以后续事件自然就不会再调用该函数询问是否拦截 同一事件序列中，如果 View 不消耗 ACTION_DOWN 事件，那么该事件序列中其他事件都将不会交给该 View 处理。这个行为可以这样理解：领导想让你做点前端的工作，如果你说你不感兴趣，那么如果再有前端的工作，肯定不会再找你 如果 onTouchEvent() 只消耗了 ACTION_DOWN 事件，那么其他事件不会上传到父 View 的 onTouchEvent() 中，并且该 View 还会接收到其余事件。最终这些事件都会由 Activity 处理 ViewGroup 默认不拦截任何事件，源码中 ViewGroup 的 onInterceptTouchEvent() 默认返回 false View 没有 onInterceptTouchEvent() 函数，所以事件传递到 View 直接就调用 onTouchEvent() View 的 onTouchEvent() 函数默认消耗事件，除非该 View 是不可点击的 View 的 enable 和 disable 属性不影响 onTouchEvent() 的返回值，只要该 View 的 clickable 或者 longClickable 有一个为 true，那么 onTouchEvent() 的返回值就为 true View 的 clickable 和 longClickable 都为 false 时，onTouchEvent() 返回 false，dispatchTouchEvent() 也返回 false，View 就不会再接收后续的事件 onClick() 发生的前提是 View 可点击，并且收到了 ACTION_DOWN 和 ACTION_UP 两个事件 事件的传递总是由外向内的，所有事件都会先传递给父元素，由父元素分发给子元素。在子元素里面可以调用 requestDisallowInterceptTouchEvent() 干预父元素的分发，调用该函数可以阻止父元素使用onInterceptTouchEvent() 函数拦截事件，但是 ACTION_DOWN 除外 源码分析一个事件首先会传递的 Activity#dispatchKeyEvent 中，内部调用 Window#superDispatchKeyEvent 进行事件分发，而 Window 是抽象类，而且只有一个实现类 PhoneWindow，此时就会执行 PhoneWindow#superDispatchKeyEvent 进行事件的分发，在 PhoneWindow#superDispatchKeyEvent 中调用了 DecorView#superDispatchTouchEvent，而 DecorView#superDispatchTouchEvent 又调用了 super.dispatchTouchEvent，由于DecorView 继承了 FrameLayout，所以这个时候执行的是 ViewGroup#dispatchTouchEvent 其中 DecorView 是当前 Activity 的底层容器，也就是 setContentView 所设置 View 的父容器，可以通过 Activity.getWindow().getDecorView() 获取，通过 DecorView.findViewById(R.id.content).getChildAt(0) 可以获取当前 Activity 通过 setContentView 所设置的那个 View 对象 从 ViewGroup#dispatchTouchEvent 开始，事件已经传递到了通过 setContentView 所设置的那个 View 对象的 dispatchTouchEvent() 中 ViewGroup1234567891011121314151617181920212223242526272829303132// Handle an initial down.// 这里的代码就解析了为什么子 View 调用 requestDisallowInterceptTouchEvent 后对 ACTION_DOWN 不生效// 因为如果是 ACTION_DOWN 的话，会重新复制 mGroupFlagsif (actionMasked == MotionEvent.ACTION_DOWN) { // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState();}// Check for interception.final boolean intercepted;// 如果 action 为 ACTION_DOWN 或者 mFirstTouchTarget 不为空的时候调用 ViewGroup#onInterceptTouchEvent// 当 ViewGroup 的子 View 消费了事件，那么就把该 View 赋值给 mFirstTouchTarget// 如果是 ViewGroup 消费了事件，mFirstTouchTarget 则不会被赋值// 所以当 ViewGroup 的 onInterceptTouchEvent 返回值为 true 时，后续事件就不会再调用 onInterceptTouchEventif (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { // 这里的 mGroupFlags 就是被子 View 调用 requestDisallowInterceptTouchEvent 设置的 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { intercepted = false; }} else { // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102 // 找到获取焦点的 ViewView childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null;// 处理事件if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. // 移除上一个消费事件的 View removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) { final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. // 获取能收到事件的子 View final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) { final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) { if (childWithAccessibilityFocus != child) { continue; } childWithAccessibilityFocus = null; i = childrenCount - 1; } // 判断元素是否可以接受事件以及事件坐标是否在元素内 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; } resetCancelNextUpFlag(child); // 这里就事件交给了子 View 进行处理，否则就继续下个循环 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) { // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); // 如果子 View 的 dispatchTouchEvent 返回了 true，就在 addTouchTarget 中重新设置 mFirstTouchTarget 的值 newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; } // The accessibility focus didn&apos;t handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); } if (preorderedList != null) preorderedList.clear(); } if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) { // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) { newTouchTarget = newTouchTarget.next; } newTouchTarget.pointerIdBits |= idBitsToAssign; }} View#dispatchTouchEvent1234567891011121314151617if (onFilterTouchEventForSecurity(event)) { if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) { result = true; } //noinspection SimplifiableIfStatement // 如果设置了 onToucheListener，并且 onTouch 返回了 true，就不会调用 onTouchEvent ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } if (!result &amp;&amp; onTouchEvent(event)) { result = true; }} View#onTouchEvent123456789101112131415final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;if ((viewFlags &amp; ENABLED_MASK) == DISABLED) { if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) { setPressed(false); } mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; // A disabled view that is clickable still consumes the touch // events, it just doesn&apos;t respond to them. // 禁用状态下的 View，依然会消费事件，但是不会做出响应 // 如果 CLICKABLE 和 LONG_CLICKABLE 有一个为 true，onTouchEvent 的返回值就是 true return clickable;} 12345678910111213if (!focusTaken) { // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. // 创建一个 Runnable 放入到消息池中，如果添加失败就直接执行 performClick() // performClick() 内部会调用 onClickListener.onClick() if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { performClick(); }} 滑动冲突滑动冲突需要根据实际的业务需求以及不同的场景进行针对性解决，没有一套标准的解决方案，列举一下常见的解决方案。 外部拦截所有事件都会先交给外部元素，然后根据实际的业务判断是由外部元素处理还是交给内部元素处理 123456789101112131415161718192021222324@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) { Log.d(TAG, &quot;onInterceptTouchEvent&quot;); // 此处根据业务以及场景判断是否需要拦截事件 boolean needIntercept = true; boolean intercept = false; switch (ev.getAction()) { case MotionEvent.ACTION_DOWN: // 因为如果 ACTION_DOWN 事件拦截之后，同一事件序列中的其他事件只会交给该 ViewGroup 处理，这里只能返回 false intercept = false; break; case MotionEvent.ACTION_UP: // 这里必须要返回 false，因为ViewGroup 只要拦截了任何事件，剩下的事件也只会交给他处理 // 如果在没有拦截 ACTION_MOVE 的情况下，返回了 true，子 View 的 click 事件将不会执行 intercept = false; break; case MotionEvent.ACTION_MOVE: intercept = needIntercept; break; default: break; } return intercept;} 内部拦截外部元素默认拦截除了 ACTION_DOWN 外的所有事件，由内部元素调用requestDisallowInterceptTouchEvent 来控制外部元素是否拦截事件 12345678910111213141516171819202122@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) { Log.d(TAG, &quot;dispatchTouchEvent&quot;); // 此处根据业务以及场景判断外部元素是否要拦截事件 boolean parentNeedIntercept = true; switch (ev.getAction()) { case MotionEvent.ACTION_DOWN: // 不允许父元素拦截 ACTION_DOWN this.requestDisallowInterceptTouchEvent(true); break; case MotionEvent.ACTION_UP: // ACTION_UP 事件不用处理，系统会自动交给拦截 ACTION_MOVE 事件的元素处理 break; case MotionEvent.ACTION_MOVE: // 不允许父元素拦截 ACTION_MOVE this.requestDisallowInterceptTouchEvent(parentNeedIntercept); break; default: break; } return super.dispatchTouchEvent(ev);} MeasureSpecViewRoot 对应 ViewRootImpl 类，是连接 WindowManager 和 DecorView，View 的三大流程都由 ViewRoot 完成，当 Activity 对象被创建完毕后调用 setContentView() 时，会将 DecorView 添加到 Window 中，同时会创建 ViewRootImpl 对象，并将 ViewRootImpl 对象和 DecorView 建立关联 View 的绘制流程从 ViewRoot 的 performTraversals 开始，依次调用 performMeasure、performLayout、performDraw 。 调用 performMeasure 时会调用 measure，measure 中又会调用 onMeasure，如果有子 View 存在，在 onMeasure 中会遍历子 View 并调用其 measure，这就完成了一次 Measure 过程，Layout 和 Draw 过程和 Measure 类似，没有本质上的区别 MeasureSpec 很大程度上决定 View 的测量过程，之所以是很大程度上影响是因为这个过程还受到父容器的影响，在测量过程中，View 的 LayoutParams 以及父容器所施加的规则决定了 MeasureSpec，利用 MeasureSpec 测量出 View 的宽高 对于顶级 DecorView，其 MeasureSpec 由手机屏幕大小和自身的 LayoutParams 决定，其他的 View 都是由父容器的 MeasureSpec 和自身的 LayoutParams 决定 MeasureSpec 代表一个32位的 int 值，高2位代表 SpecMode，低30位代表 SpecSize，SpecMode 代表测量模式，SpecSize 代表某种测量模式下的规格大小 SpecMode 有三类： UNSPECIFIED：未指定模式，一般用于系统内部，表示一种测量状态 EXACTLY：精确模式，对于 match_parent 和具体的宽高数值 AT_MOST：最大模式，父容器指定一个可用大小，View 的大小不能大于这个值，具体值要看不同 View 的具体实现，对应 wrap_content 查看源码可知，子 View 的 MeasureSpec 受到父容器的 MeasureSpec 和自身的 LayoutParams 影响： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public static int getChildMeasureSpec(int spec, int padding, int childDimension) { int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) { // Parent has imposed an exact size on us case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) { resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // Child wants to determine its own size. It can&apos;t be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) { // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // Child wants to determine its own size. It can&apos;t be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) { // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } break; } //noinspection ResourceType return MeasureSpec.makeMeasureSpec(resultSize, resultMode);} measure下图就是根据源码绘制的 measure 流程： 其实需要注意直接继承 View 的自定义组件，当 MeasureSpec 为 AT_MOST 时，此时该自定义 View 的wrap_content 和 match_parent 的效果其实是一致的。所以需要重写 onMeasure 避免该问题： 123456789101112131415@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); if (MeasureSpec.AT_MOST == widthMode &amp;&amp; MeasureSpec.AT_MOST == heightMode) { setMeasuredDimension(mWidth, mHeight); } else if (MeasureSpec.AT_MOST == widthMode) { setMeasuredDimension(mWidth, heightSize); } else if (MeasureSpec.AT_MOST == heightMode) { setMeasuredDimension(widthSize, mHeight); }} 测量宽高View 的测量宽高在某些情况下可能需要系统多次调用 measure 后才能获取，且 measure 的执行和 Activity 的生命周期不是同步执行，所以无法保障在 Activity 的某个生命周期函数中获取 View 的准去测量宽高，下面提供四种获取宽高的方式： Activity#onWindowFocusChanged在 Activity 获取（onResume）或失去焦点（onPause）的时候都会调用该函数，此时 Activity 中的 View 已经初始化完毕，可以放心大胆的获取其宽高了 View.post(Runnable)放一个消息到消息队列中，当执行到该消息的时候，此时 View 已经初始化完成 ViewTreeObserver#onGlobalLayout使用 ViewTreeObserver，当 View 状态发生改变的时候都会调用 onGlobalLayout 函数，由于 View 的状态可能会改变多次，所以 onGlobalLayout 也会被调用多次 手动 measure这种方式不是所有的情况下都能使用： match_parent：直接放弃，这种情况下的 measureSpec，需要知道父容器剩余空间大小，此时并不能获取到父容器剩余空间大小 warp_content： 1234// View 的尺寸用30位的二进制表示，最大化模式下，使用 View 的最大值 (1 &lt;&lt; 30) - 1 构建 measureSpecint width = View.MeasureSpec.makeMeasureSpec((1 &lt;&lt; 30) - 1, View.MeasureSpec.AT_MOST);int height = View.MeasureSpec.makeMeasureSpec((1 &lt;&lt; 30) - 1, View.MeasureSpec.AT_MOST);mView.measure(width, height); 具体数值： 1234// 100 为具体数值int width = View.MeasureSpec.makeMeasureSpec(100, View.MeasureSpec.EXACTLY);int height = View.MeasureSpec.makeMeasureSpec(100,View.MeasureSpec.EXACTLY);mView.measure(width, height); layout相对于 measure，layout 流程就简单多了，首先使用 setFrame 来设置 View 四个顶点的位置，顶点一旦确定，View 的位置也就确定了。接着就会调用 onLayout 确定子 View 的位置，和 onMeasure 类似，onLayout 的具体实现和具体的 View 有关 draw通过 View#draw 的源码，可以很清晰的看出来 draw 的绘制流程： drawBackground：绘制背景 onDraw：绘制内容 dispatchDraw：绘制子 View onDrawForeground：绘制前景，包括 onDrawScrollIndicators、onDrawScrollBars View#setWillNotDraw 函数表示如果一个 View 自身不处理 onDraw，就可以设置这个标识为 true，系统如果发现这个标识为 true，系统会进行相应的优化。View 默认没有开启，ViewGroup 默认开启。在开发过程中，如果自定义的 ViewGroup 并没有处理 onDraw 就可以开启这个标识，反之则需要显示的关闭该标识 LinearLayout 和 RelativeLayout 性能对比首先看一下 LinearLayout#onMeasure： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { if (mOrientation == VERTICAL) { measureVertical(widthMeasureSpec, heightMeasureSpec); } else { measureHorizontal(widthMeasureSpec, heightMeasureSpec); } View[] views = mSortedHorizontalChildren; int count = views.length; for (int i = 0; i &lt; count; i++) { View child = views[i]; if (child.getVisibility() != GONE) { LayoutParams params = (LayoutParams) child.getLayoutParams(); int[] rules = params.getRules(layoutDirection); applyHorizontalSizeRules(params, myWidth, rules); measureChildHorizontal(child, params, myWidth, myHeight); if (positionChildHorizontal(child, params, myWidth, isWrapContentWidth)) { offsetHorizontalAxis = true; } } } views = mSortedVerticalChildren; count = views.length; final int targetSdkVersion = getContext().getApplicationInfo().targetSdkVersion; for (int i = 0; i &lt; count; i++) { final View child = views[i]; if (child.getVisibility() != GONE) { final LayoutParams params = (LayoutParams) child.getLayoutParams(); applyVerticalSizeRules(params, myHeight, child.getBaseline()); measureChild(child, params, myWidth, myHeight); if (positionChildVertical(child, params, myHeight, isWrapContentHeight)) { offsetVerticalAxis = true; } if (isWrapContentWidth) { if (isLayoutRtl()) { if (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) { width = Math.max(width, myWidth - params.mLeft); } else { width = Math.max(width, myWidth - params.mLeft + params.leftMargin); } } else { if (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) { width = Math.max(width, params.mRight); } else { width = Math.max(width, params.mRight + params.rightMargin); } } } if (isWrapContentHeight) { if (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) { height = Math.max(height, params.mBottom); } else { height = Math.max(height, params.mBottom + params.bottomMargin); } } if (child != ignore || verticalGravity) { left = Math.min(left, params.mLeft - params.leftMargin); top = Math.min(top, params.mTop - params.topMargin); } if (child != ignore || horizontalGravity) { right = Math.max(right, params.mRight + params.rightMargin); bottom = Math.max(bottom, params.mBottom + params.bottomMargin); } } }} 再来看一下 RelativeLayout#onMeasure： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {... View[] views = mSortedHorizontalChildren; int count = views.length; for (int i = 0; i &lt; count; i++) { View child = views[i]; if (child.getVisibility() != GONE) { LayoutParams params = (LayoutParams) child.getLayoutParams(); int[] rules = params.getRules(layoutDirection); applyHorizontalSizeRules(params, myWidth, rules); measureChildHorizontal(child, params, myWidth, myHeight); if (positionChildHorizontal(child, params, myWidth, isWrapContentWidth)) { offsetHorizontalAxis = true; } } } views = mSortedVerticalChildren; count = views.length; final int targetSdkVersion = getContext().getApplicationInfo().targetSdkVersion; for (int i = 0; i &lt; count; i++) { final View child = views[i]; if (child.getVisibility() != GONE) { final LayoutParams params = (LayoutParams) child.getLayoutParams(); applyVerticalSizeRules(params, myHeight, child.getBaseline()); measureChild(child, params, myWidth, myHeight); if (positionChildVertical(child, params, myHeight, isWrapContentHeight)) { offsetVerticalAxis = true; } if (isWrapContentWidth) { if (isLayoutRtl()) { if (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) { width = Math.max(width, myWidth - params.mLeft); } else { width = Math.max(width, myWidth - params.mLeft + params.leftMargin); } } else { if (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) { width = Math.max(width, params.mRight); } else { width = Math.max(width, params.mRight + params.rightMargin); } } } if (isWrapContentHeight) { if (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) { height = Math.max(height, params.mBottom); } else { height = Math.max(height, params.mBottom + params.bottomMargin); } } if (child != ignore || verticalGravity) { left = Math.min(left, params.mLeft - params.leftMargin); top = Math.min(top, params.mTop - params.topMargin); } if (child != ignore || horizontalGravity) { right = Math.max(right, params.mRight + params.rightMargin); bottom = Math.max(bottom, params.mBottom + params.bottomMargin); } } }... final boolean useExcessSpace = lp.height == 0 &amp;&amp; lp.weight &gt; 0; if (heightMode == MeasureSpec.EXACTLY &amp;&amp; useExcessSpace) { // 如果是设置了 weight 且 height 是0的时候就跳过测绘，只把 margin 值添加到总高中 final int totalLength = mTotalLength; mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin); skippedMeasure = true; } else { if (useExcessSpace) { lp.height = LayoutParams.WRAP_CONTENT; } final int usedHeight = totalWeight == 0 ? mTotalLength : 0; measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, usedHeight); final int childHeight = child.getMeasuredHeight(); if (useExcessSpace) { lp.height = 0; consumedExcessSpace += childHeight; } final int totalLength = mTotalLength; mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child)); if (useLargestChild) { largestChildHeight = Math.max(childHeight, largestChildHeight); } }} 可以很明显的看出来 RelativeLayout 进行了两次 onMeasure，原因是因为 RelativeLayout 中的子 View 之间有相互依赖的关系。需要先进行一次横向测量，再进行一次纵向测量才能确定子 View 的位置 而 LinearLayout 只测量了一次，但是如果设置了 weight，这个时候就会跳过测量这个 View，等剩余所有的 View 都测量完之后，把剩余空间按照 weight 的值分配给对应的 View，这个时候该 View 会测量一次。由此可见 weight 对性能还是有影响的 但是实际开发过程中为了优化布局嵌套和层级深度，很多情况下还是需要使用 RelativeLayout，因为使用 LinearLayout 布局很容易造成太多布局嵌套，在布局层级不深的情况下还是要优先使用 LinearLayout 自定义 View实现方式 继承 View 重写 onDraw 函数 继承 ViewGroup 自定义特殊的 Layout 继承现有的 View 子类（例如 Button） 继承现有的 ViewGroup 子类（例如 LinearLayout） 注意事项 尽量让自定义 View 支持 wrap_content 尽量让自定义 View 支持 padding 和 margin 属性 尽量不要在自定义 View 内部使用 Handler，因为 View 自身就提供有 post 如果有滑动，考虑到滑动冲突的情况 如果 View 中有线程或者动画，需要及时停止。当 View 所依赖的 Activity 销毁或者该 View 被 Remove 时，View#onDatachedFromWindow 会被调用，此时应当停止 View 中的线程和动画；与该函数对应的函数是 View#onAttachedToWindow，当 View 所在的 Activity 启动的时候会调用该函数 继承 View首先需要重写 View 的构造函数，根据不同的引用方式会触发不同的构造函数： 1234567891011121314151617181920212223public class CustomView extends View { /** * 从代码创建 View 时调用该构造函数 */ public CustomView(Context context) { this(context, null); } /** * 在 XML 中引用该 View 时调用该构造函数 */ public CustomView(Context context, @Nullable AttributeSet attrs) { this(context, attrs, 0); } /** * 在 XML 中引用该 View，并且有一个 style 样式 */ public CustomView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); }} 接着需要重写 onDraw() 函数画一个圆： 12345678protected void onDraw(Canvas canvas) { super.onDraw(canvas); int width = getWidth(); int height = getHeight(); int radius = Math.min(width, height) / 2; // 一参是圆心的 X 轴坐标，二参是圆心 Y 轴坐标，三参是圆半径，四参是用来画圆的画笔 canvas.drawCircle(width / 2, height / 2, radius, mPaint);} 还需要考虑设置了 padding 以及 warp_content 的情况，这个时候就需要重写 onMeasure() 和 onDraw() 函数： 123456789101112131415161718192021222324252627282930// warp_content 需要重写 onMeasure()protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); // mWidth mHeight 为默认值 if (MeasureSpec.AT_MOST == widthMode &amp;&amp; MeasureSpec.AT_MOST == heightMode) { setMeasuredDimension(mWidth, mHeight); } else if (MeasureSpec.AT_MOST == widthMode) { setMeasuredDimension(mWidth, heightSize); } else if (MeasureSpec.AT_MOST == heightMode) { setMeasuredDimension(widthSize, mHeight); }}// padding 需要重写 onDraw()，在绘制的时候把 padding 去掉即可protected void onDraw(Canvas canvas) { super.onDraw(canvas); int paddingTop = getPaddingTop(); int paddingBottom = getPaddingBottom(); int paddingLeft = getPaddingLeft(); int paddingRight = getPaddingRight(); int width = getWidth() - paddingLeft - paddingRight; int height = getHeight() - paddingTop - paddingBottom; int radius = Math.min(width, height) / 2; // 一参是圆心的 X 轴坐标，二参是圆心 Y 轴坐标，三参是圆半径，四参是用来画圆的画笔 canvas.drawCircle(paddingLeft + width / 2,paddingTop + height / 2, radius, mPaint);} 也许还需要设置一些自定义的样式属性，这个时候就需要在 values 文件夹中创建一个 attrs.xml 文件（可以是任意文件名）存放声明的样式，下面是 attrs_circle_view.xml： 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;CustomView&quot;&gt; &lt;attr name=&quot;circle_color&quot; format=&quot;color&quot;/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 在 xml 文件中的引用需要声明一个 schemas 声明：xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; ： 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;org.lovedev.chapter_4.CustomView android:id=&quot;@+id/view&quot; android:layout_width=&quot;100dp&quot; android:padding=&quot;10dp&quot; app:circle_color=&quot;@color/colorPrimary&quot; android:layout_height=&quot;100dp&quot;/&gt;&lt;/LinearLayout&gt; 在自定义 View 中需要引用并解析这个自定义的样式属性： 12345678910111213public CustomView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.CustomView); // mColor 就是通过 app:circle_color 属性设置的颜色属性，如果没有设置就默认是 Color.RED mColor = typedArray.getColor(R.styleable.CustomView_circle_color, Color.RED); typedArray.recycle(); init();}private void init() { mPaint = new Paint(); mPaint.setColor(mColor);} 布局优化可以使用 Android Device Monitor 以及 layout inspector 工具查看页面布局，不过 Android Device Monitor 已经从 Andorid Studio 中废弃了，可以查看官方解释 include该标签可以实现重用布局，比如多个页面相同的头布局，但是这种方式除了位置和布局大小以外，不能做任何改变 mergesetContentView() 时会调用 Window#setContentView()，前面已经说过 PhoneWindow 是 Window 的唯一实现类，在 PhoneWindow 中能看到这么一行代码： 12// This is the top-level view of the window, containing the window decor.private DecorView mDecor; 可以发现 DecorView 是 PhoneWindow 的根 View，而 DecorView 继承了 FrameLayout，到此就能知道为什么布局的最外层是 FrameLayout 了 先创建两个布局文件，然后 include 到布局当中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!--button.xml--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:text=&quot;Merge&quot; android:layout_height=&quot;60dp&quot;/&gt;&lt;/LinearLayout&gt;&lt;!--button_merge.xml--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:text=&quot;With Merge&quot; android:layout_height=&quot;60dp&quot;/&gt;&lt;/merge&gt;&lt;!--activity.xml--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.SecondActivity&quot;&gt; &lt;include layout=&quot;@layout/button&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt; &lt;include layout=&quot;@layout/button_merge&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt; 使用 Andorid Studio 自带的 Layout inspector 查看 View Tree： 从 View Tree 中可以很清晰的看出，用了 merge 标签的布局自动把布局中的元素插入到了 include 引用的地方，而没有使用 merge 标签的那个布局还会有一层 LinearLayout 布局 ViewStub首先需要注意的是 ViewStub 不能应用含有 merge 标签的布局，否则会抛出异常： android.view.InflateException: can be used only with a valid ViewGroup root and attachToRoot=true ViewStub 常用的场景是引用那些不常用的布局，比如用户注册的时候，经常会有一些必选项和一些可选项，这些可选项可能需要手动点击某个按钮才能显示出来，如果开始用 GONE 或者 INVISIBLE，然后再用 VISIBLE 显示也能实现这样的功能，但是用这种处理方式时，这个布局初始化的时候已经把所有的元素加载了，这个时候使用 ViewStub 就能优化这点 看一下官网对于 ViewStub 的介绍： A ViewStub is an invisible, zero-sized View that can be used to lazily inflate layout resources at runtime. When a ViewStub is made visible, or when inflate() is invoked, the layout resource is inflated. 简单翻译：ViewStub 是一个可以用来在运行时懒加载布局且是无形的，0大小的 View，当 ViewStub 是可见的，或者 inflate() 函数被调用，布局就会加载出来。 所以当使用 ViewStub 的时候，就可以调用 ViewStub.setVisibility(View.VISIBLE) 或者 ViewStub.inflate() 就可以显示引用的布局。 RecyclerView &amp; ListViewListView 缓存分析查看源码可知 ListView 的缓存逻辑是在其父类 AbsListView 中的一个内部类 RecycleBin实现的： 1234567891011121314151617181920212223242526272829303132 /** * The RecycleBin facilitates reuse of views across layouts. The RecycleBin has two levels of * storage: ActiveViews and ScrapViews. ActiveViews are those views which were onscreen at the * start of a layout. By construction, they are displaying current information. At the end of * layout, all views in ActiveViews are demoted to ScrapViews. ScrapViews are old views that * could potentially be used by the adapter to avoid allocating views unnecessarily. * * @see android.widget.AbsListView#setRecyclerListener(android.widget.AbsListView.RecyclerListener) * @see android.widget.AbsListView.RecyclerListener */class RecycleBin { private RecyclerListener mRecyclerListener; /** * The position of the first view stored in mActiveViews. */ private int mFirstActivePosition; /** * Views that were on screen at the start of layout. This array is populated at the start of * layout, and at the end of layout all view in mActiveViews are moved to mScrapViews. * Views in mActiveViews represent a contiguous range of Views, with position of the first * view store in mFirstActivePosition. */ private View[] mActiveViews = new View[0]; /** * Unsorted views that can be used by the adapter as a convert view. */ private ArrayList&lt;View&gt;[] mScrapViews; ...}这个类有两个缓存级别： ActiveViews - 一级缓存，布局开始 layout 时显示的 View ScrapViews - 二级缓存，当 layout 结束后 ActiveView 降级为 ScrapView 首次 onLayout首先分析 ListView 的首次 onLayout，查看源码发现 ListView 中没有 onLayout，但是在父类 AbsListView 中存在： 12345678910111213141516171819202122232425262728 /** * Subclasses should NOT override this method but * {@link #layoutChildren()} instead. */@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) { super.onLayout(changed, l, t, r, b); mInLayout = true; final int childCount = getChildCount(); if (changed) { for (int i = 0; i &lt; childCount; i++) { getChildAt(i).forceLayout(); } mRecycler.markChildrenDirty(); } layoutChildren(); mOverscrollMax = (b - t) / OVERSCROLL_LIMIT_DIVISOR; // TODO: Move somewhere sane. This doesn&apos;t belong in onLayout(). if (mFastScroll != null) { mFastScroll.onItemCountChanged(getChildCount(), mItemCount); } mInLayout = false;} 可以看到执行了 layoutChildren 函数，layoutChildren 函数由子类实现，首先看首次 onLayout 时的关键步骤： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687protected void layoutChildren() { ... // 由于数据都在 adapter 中存在，所以首次 layout 的时候还没有数据，dataChanged 肯定是 false，而且此时 childCount 肯定是 0，此时执行 recycleBin#fillActiveViews 没有实际意义 if (dataChanged) { for (int i = 0; i &lt; childCount; i++) { recycleBin.addScrapView(getChildAt(i), firstPosition+i); } } else { recycleBin.fillActiveViews(childCount, firstPosition); } // Clear out old views detachAllViewsFromParent(); recycleBin.removeSkippedScrap(); // mLayoutMode 默认值为 LAYOUT_NORMAL，所以代码会执行到 default 中 switch (mLayoutMode) { case LAYOUT_SET_SELECTION: if (newSel != null) { sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom); } else { sel = fillFromMiddle(childrenTop, childrenBottom); } break; case LAYOUT_SYNC: sel = fillSpecific(mSyncPosition, mSpecificTop); break; case LAYOUT_FORCE_BOTTOM: sel = fillUp(mItemCount - 1, childrenBottom); adjustViewsUpOrDown(); break; case LAYOUT_FORCE_TOP: mFirstPosition = 0; sel = fillFromTop(childrenTop); adjustViewsUpOrDown(); break; case LAYOUT_SPECIFIC: final int selectedPosition = reconcileSelectedPosition(); sel = fillSpecific(selectedPosition, mSpecificTop); /** * When ListView is resized, FocusSelector requests an async selection for the * previously focused item to make sure it is still visible. If the item is not * selectable, it won&apos;t regain focus so instead we call FocusSelector * to directly request focus on the view after it is visible. */ if (sel == null &amp;&amp; mFocusSelector != null) { final Runnable focusRunnable = mFocusSelector .setupFocusIfValid(selectedPosition); if (focusRunnable != null) { post(focusRunnable); } } break; case LAYOUT_MOVE_SELECTION: sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom); break; default: // 由于没有数据的原因，所以 childCount 也是 0 if (childCount == 0) { // 由于布局默认的排列顺序是自上而下的，会往下执行 fillFromTop // 注意传入 fillFromTop 的参数 childrenTop 实际为第一个子元素距离 ListView 的像素值，如果 ListView 没有设置 Padding，该值为 0 if (!mStackFromBottom) { final int position = lookForSelectablePosition(0, true); setSelectedPositionInt(position); sel = fillFromTop(childrenTop); } else { final int position = lookForSelectablePosition(mItemCount - 1, false); setSelectedPositionInt(position); sel = fillUp(mItemCount - 1, childrenBottom); } } else { if (mSelectedPosition &gt;= 0 &amp;&amp; mSelectedPosition &lt; mItemCount) { sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop()); } else if (mFirstPosition &lt; mItemCount) { sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop()); } else { sel = fillSpecific(0, childrenTop); } } break; } ...} 接着分析 fillFromTop 函数： 12345678private View fillFromTop(int nextTop) { mFirstPosition = Math.min(mFirstPosition, mSelectedPosition); mFirstPosition = Math.min(mFirstPosition, mItemCount - 1); if (mFirstPosition &lt; 0) { mFirstPosition = 0; } return fillDown(mFirstPosition, nextTop);} 对 mFirstPosition 进行一番校验后，最终执行了 fillDown ： 1234567891011121314151617181920212223private View fillDown(int pos, int nextTop) { View selectedView = null; // end 为 ListView 的总高度 int end = (mBottom - mTop); if ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) { end -= mListPadding.bottom; } while (nextTop &lt; end &amp;&amp; pos &lt; mItemCount) { // is this the selected item? boolean selected = pos == mSelectedPosition; View child = makeAndAddView(pos, nextTop, true, mListPadding.left, selected); nextTop = child.getBottom() + mDividerHeight; if (selected) { selectedView = child; } pos++; } setVisibleRangeHint(mFirstPosition, mFirstPosition + getChildCount() - 1); return selectedView;} 在 fillDown 中会有一个 while 循环，end 为 ListView 的总高度，在循环开始时 nextTop 必定小于 end，mItemCount 是通过 BaseAdapter#getCount，所以 pos 也是小于 mItemCount，通过执行 makeAndAddView 函数获取当前位置的 View，然后把该 View 距离 ListView 顶部高度与分割线高度和重新赋值给 nextTop，同时将 pos 加上 1 继续下一个循环，此时需要查看一下 makeAndAddView 函数的源码： 12345678910111213141516171819202122private View makeAndAddView(int position, int y, boolean flow, int childrenLeft, boolean selected) { if (!mDataChanged) { // Try to use an existing view for this position. final View activeView = mRecycler.getActiveView(position); if (activeView != null) { // Found it. We&apos;re reusing an existing child, so it just needs // to be positioned like a scrap view. setupChild(activeView, position, y, flow, childrenLeft, selected, true); return activeView; } } // Make a new view for this position, or convert an unused view if // possible. final View child = obtainView(position, mIsScrap); // This needs to be positioned and measured. setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]); return child;} 由于执行到该函数时，mDataChanged 的值一直为 false，所以会执行 mRecycler.getActiveView 来获取 View 对象，此时获取到的 View 对象肯定是 null；所以还会往下执行，通过 obtainView 获取 View 对象，该函数的实现在 AbsListView 类中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667View obtainView(int position, boolean[] outMetadata) { Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;obtainView&quot;); outMetadata[0] = false; // Check whether we have a transient state view. Attempt to re-bind the // data and discard the view if we fail. final View transientView = mRecycler.getTransientStateView(position); if (transientView != null) { final LayoutParams params = (LayoutParams) transientView.getLayoutParams(); // If the view type hasn&apos;t changed, attempt to re-bind the data. if (params.viewType == mAdapter.getItemViewType(position)) { final View updatedView = mAdapter.getView(position, transientView, this); // If we failed to re-bind the data, scrap the obtained view. if (updatedView != transientView) { setItemViewLayoutParams(updatedView, position); mRecycler.addScrapView(updatedView, position); } } outMetadata[0] = true; // Finish the temporary detach started in addScrapView(). transientView.dispatchFinishTemporaryDetach(); return transientView; } // 特别注意这两行代码 final View scrapView = mRecycler.getScrapView(position); final View child = mAdapter.getView(position, scrapView, this); if (scrapView != null) { if (child != scrapView) { // Failed to re-bind the data, return scrap to the heap. mRecycler.addScrapView(scrapView, position); } else if (child.isTemporarilyDetached()) { outMetadata[0] = true; // Finish the temporary detach started in addScrapView(). child.dispatchFinishTemporaryDetach(); } } if (mCacheColorHint != 0) { child.setDrawingCacheBackgroundColor(mCacheColorHint); } if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) { child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES); } setItemViewLayoutParams(child, position); if (AccessibilityManager.getInstance(mContext).isEnabled()) { if (mAccessibilityDelegate == null) { mAccessibilityDelegate = new ListItemAccessibilityDelegate(); } if (child.getAccessibilityDelegate() == null) { child.setAccessibilityDelegate(mAccessibilityDelegate); } } Trace.traceEnd(Trace.TRACE_TAG_VIEW); return child;}首先会执行 mRecycler.getScrapView() 从废弃缓存中的获取 View 对象，此时该 View 对象必然是 null，然后把该对象传递给 mAdapter.getView()；至此就到了非常熟悉的 Adapter 了，其中有一种常见的 ListView 优化方法就是通过 ViewHolder 减少创建 View 对象的次数： 1234567891011121314151617181920override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View? { val holder: TestViewHolder val v: View // 如果没有从废弃缓存中获取到 View 对象，则创建一个，把 ViewHolder 对象绑定到该 View 的 tag 属性上，同时 ViewHolder 持有该 View 的引用 // 如果获取到了，就直接从该 View 中获取 ViewHolder，不必重新创建新的 View 对象 if (convertView == null) { v = View.inflate(context, R.layout.my_text_view, null) holder = TestViewHolder(v) v.tag = holder } else { v = convertView holder = v.tag as TestViewHolder } holder.str.text = data[position] return v}class TestViewHolder(viewItem: View) { var str: TextView = viewItem.findViewById(R.id.tv) as TextView} 第二次 onLayout至此就获取到了需要显示的 View 对象，并通过 setupChild 填充到 ListView 中，不要忘记此时还在 fillDown 函数中的 while 循环当中，当 ListView 加载完首屏数据后就会跳出该循环，所以不会因为数据过多导致 OOM，不过这仅仅是首次 onLayout 的流程，接下来还有第二次 onLayout，过程和首次还是有些不同的，首先还是先从 layoutChild 来看： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113protected void layoutChildren() { ... // 由于此前已经填充了 ListView，此时 childCount 不为 0，把当前所有子 View 都缓存到了活跃缓存区中 if (dataChanged) { for (int i = 0; i &lt; childCount; i++) { recycleBin.addScrapView(getChildAt(i), firstPosition+i); } } else { recycleBin.fillActiveViews(childCount, firstPosition); } // Clear out old views // 该函数会清空 ListView 中所有的 View 对象，但是不用担心，这些 View 对象已经被缓存了 detachAllViewsFromParent(); recycleBin.removeSkippedScrap(); // mLayoutMode 默认值为 LAYOUT_NORMAL，所以代码会执行到 default 中 switch (mLayoutMode) { case LAYOUT_SET_SELECTION: if (newSel != null) { sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom); } else { sel = fillFromMiddle(childrenTop, childrenBottom); } break; case LAYOUT_SYNC: sel = fillSpecific(mSyncPosition, mSpecificTop); break; case LAYOUT_FORCE_BOTTOM: sel = fillUp(mItemCount - 1, childrenBottom); adjustViewsUpOrDown(); break; case LAYOUT_FORCE_TOP: mFirstPosition = 0; sel = fillFromTop(childrenTop); adjustViewsUpOrDown(); break; case LAYOUT_SPECIFIC: final int selectedPosition = reconcileSelectedPosition(); sel = fillSpecific(selectedPosition, mSpecificTop); /** * When ListView is resized, FocusSelector requests an async selection for the * previously focused item to make sure it is still visible. If the item is not * selectable, it won&apos;t regain focus so instead we call FocusSelector * to directly request focus on the view after it is visible. */ if (sel == null &amp;&amp; mFocusSelector != null) { final Runnable focusRunnable = mFocusSelector .setupFocusIfValid(selectedPosition); if (focusRunnable != null) { post(focusRunnable); } } break; case LAYOUT_MOVE_SELECTION: sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom); break; default: // 此时 childCount 非 0，所以这次会执行 fillSpecific if (childCount == 0) { if (!mStackFromBottom) { final int position = lookForSelectablePosition(0, true); setSelectedPositionInt(position); sel = fillFromTop(childrenTop); } else { final int position = lookForSelectablePosition(mItemCount - 1, false); setSelectedPositionInt(position); sel = fillUp(mItemCount - 1, childrenBottom); } } else { if (mSelectedPosition &gt;= 0 &amp;&amp; mSelectedPosition &lt; mItemCount) { sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop()); } else if (mFirstPosition &lt; mItemCount) { sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop()); } else { sel = fillSpecific(0, childrenTop); } } break; } ...}``` `fillSpecific` 函数的作用和 `fillDown` 大相径庭，暂时不用关心它的内部细节，`fillSpecific` 内部最终也会执行 `makeAndAddView`，这个时候再次执行 `mRecycler.getActiveView` 就可以获取到之前已经缓存过的 View 对象了，接着执行 `setupChild`，这时需要注意该函数的最后一个参数，该参数表示当前的 View 对象是否被添加到 Window 过，看源码获取该参数的主要用途：```Javaprivate void setupChild(View child, int position, int y, boolean flowDown, int childrenLeft, boolean selected, boolean isAttachedToWindow) { ... if ((isAttachedToWindow &amp;&amp; !p.forceAdd) || (p.recycledHeaderFooter &amp;&amp; p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER)) { attachViewToParent(child, flowDown ? -1 : 0, p); // If the view was previously attached for a different position, // then manually jump the drawables. if (isAttachedToWindow &amp;&amp; (((AbsListView.LayoutParams) child.getLayoutParams()).scrappedFromPosition) != position) { child.jumpDrawablesToCurrentState(); } } else { p.forceAdd = false; if (p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER) { p.recycledHeaderFooter = true; } addViewInLayout(child, flowDown ? -1 : 0, p, true); // add view in layout will reset the RTL properties. We have to re-resolve them child.resolveRtlPropertiesIfNeeded(); } ...}可以看出如果之前没有添加过执行 addViewInLayout，否则就执行 attachViewToParent，这两个函数的关键区别在于 addViewInLayout 是往 ViewGroup 中添加一个新的子 View，会重新渲染。而 attachViewToParent 则是将之前通过 detachViewFromParent 移出 ViewGroup 的子 View 重新显示出来，不会重新渲染，至此两次 onLayout 已经执行结束 滑动在 ListView 滑动过程中，会执行以下函数： 最终还是会执行 makeAndAddView() 函数： 123456789101112131415161718192021private View makeAndAddView(int position, int y, boolean flow, int childrenLeft, boolean selected) { if (!mDataChanged) { final View activeView = mRecycler.getActiveView(position); if (activeView != null) { // Found it. We&apos;re reusing an existing child, so it just needs // to be positioned like a scrap view. setupChild(activeView, position, y, flow, childrenLeft, selected, true); return activeView; } } // Make a new view for this position, or convert an unused view if // possible. final View child = obtainView(position, mIsScrap); // This needs to be positioned and measured. setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]); return child;}由于此时 mRecycler.getActiveView 已经获取不到 activeView，所以还是会往下执行到 obtainView()，在 obtainView() 中可以通过 mRecycler.getScrapView 从废弃缓存中获取到 View 进行复用，之后的流程和 onLayout 时相同，到此 ListView 的缓存分析已经结束 RecyclerView 分析在刚开始使用 RecyclerView 的时候，经常会发生由于忘记设置 LayoutManager 导致布局渲染不出来，来看一下 RecyclerView#LayoutManager 的部分官方解释： A LayoutManager is responsible for measuring and positioning item views within a RecyclerView as well as determining the policy for when to recycle item views that are no longer visible to the user LayoutManager 负责测量和定位 RecyclerView 中的 item，并且负责确定何时回收这些不可见 item 的策略，在 RecyclerView 中有一个函数 onLayoutChildren()： 123public void onLayoutChildren(Recycler recycler, State state) { Log.e(TAG, &quot;You must override onLayoutChildren(Recycler recycler, State state) &quot;);}这个函数的作用是列出 adapter 中所有的 view，而且每个不同的 LayoutManager 都需要重写该函数，就从 LinearLayoutManager#onLayoutChildren 开始分析，在 onLayoutChildren 中也有调用了和 fillActiveViews() 功能相似的一个函数 detachAndScrapAttachedViews() 来缓存之前所有的 View，接着执行 fill() 对 RecyclerView 进行填充： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int fill(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.State state, boolean stopOnFocusable) { // max offset we should set is mFastScroll + available final int start = layoutState.mAvailable; if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) { // TODO ugly bug fix. should not happen if (layoutState.mAvailable &lt; 0) { layoutState.mScrollingOffset += layoutState.mAvailable; } recycleByLayoutState(recycler, layoutState); } int remainingSpace = layoutState.mAvailable + layoutState.mExtra; LayoutChunkResult layoutChunkResult = mLayoutChunkResult; while ((layoutState.mInfinite || remainingSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) { layoutChunkResult.resetInternal(); if (VERBOSE_TRACING) { TraceCompat.beginSection(&quot;LLM LayoutChunk&quot;); } layoutChunk(recycler, state, layoutState, layoutChunkResult); if (VERBOSE_TRACING) { TraceCompat.endSection(); } if (layoutChunkResult.mFinished) { break; } layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection; /** * Consume the available space if: * * layoutChunk did not request to be ignored * * OR we are laying out scrap children * * OR we are not doing pre-layout */ if (!layoutChunkResult.mIgnoreConsumed || mLayoutState.mScrapList != null || !state.isPreLayout()) { layoutState.mAvailable -= layoutChunkResult.mConsumed; // we keep a separate remaining space because mAvailable is important for recycling remainingSpace -= layoutChunkResult.mConsumed; } if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) { layoutState.mScrollingOffset += layoutChunkResult.mConsumed; if (layoutState.mAvailable &lt; 0) { layoutState.mScrollingOffset += layoutState.mAvailable; } recycleByLayoutState(recycler, layoutState); } if (stopOnFocusable &amp;&amp; layoutChunkResult.mFocusable) { break; } } if (DEBUG) { validateChildOrder(); } return start - layoutState.mAvailable;}在 fill() 中不停判断剩余空间和是否有更多的 item，并且执行 layoutChunk() 填充布局，在 layoutChunk() 中又执行了 layoutState.next() 获取下一个需要显示的 View： 12345678 View next(RecyclerView.Recycler recycler) { if (mScrapList != null) { return nextViewFromScrapList(); } final View view = recycler.getViewForPosition(mCurrentPosition); mCurrentPosition += mItemDirection; return view;}此时就能看到 RecyclerView 回收机制的关键函数 getViewForPosition()，Recycler 是 RecyclerView 实现回收机制的关键类，和 ListView 缓存机制不同的是，RecyclerView 缓存的是 ViewHolder，它实现了四级缓存： mAttachedScrap - 缓存屏幕上的 ViewHolder mChangedScrap - 已经分离的 ViewHolder mCachedViews - 缓存屏幕外的 ViewHolder，默认为2个，ListView 对于屏幕外的缓存都会调用getView() mRecyclerPool - 用于多个 RecyclerView 的缓存池 mViewCacheExtension - 用户定制，默认不实现 getViewForPosition() 最终会执行 tryGetViewHolderForPositionByDeadline() 获取 ViewHolder 对象，具体流程图： RecyclerView 的优势在于 mCacheViews 的使用，可以做到屏幕外的列表项 ItemView 进入屏幕内时也无须 bindView 快速重用；mRecyclerPool 可以供多个 RecyclerView 共同使用","link":"/2018/04/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AAndroid-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/"},{"title":"《Effective Java》- 对于所有对象都通用的方法","text":"覆盖 equals 时遵守通用约定 自反性：对于任何非 null 的引用值 x，x.equals(x) 总是 true 对称性：对于任何非 null 的引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 必须返回 true 传递性：x.equals(y) 以及 y.equals(z) 返回 true 时，x.equals(z) 也必须是 true 一致性：只要 equals 的操作对象中所用的信息没有被修改，多次调用 equals 就必须返回一致结果 对于非 null 的引用值 x，x.equals(null) 必须返回 false 覆盖 equals 时总要覆盖 hashCode始终覆盖 toString()toString() 通用约定指出，被返回的字符串应该是一个简洁、信息丰富、易于阅读的 谨慎覆盖 clone() 超出语言之外的对象创建机制，对象的创建需要通过构造函数 如果一个类的子类覆盖了 clone() 函数，就应该调用 super.clone() 返回该子类对象。如果此时父类中的 clone() 函数中没有通过调用 super.clone() 返回对象，而是通过构造器，此时子类执行 clone() 函数返回的对象类型就和子类类型不一致 如果要 clone 一个对象中的引用类型对象，那么该引用类型对象最好是唯一的不可变的，否则该对象中变量不能用 final 修饰，需要对该引用类型对象进行深拷贝 考虑实现 Comparable 接口当对象小于、等于或大于指定对象时，分别返回一个负整数，0或正整数需要遵循以下规则： 12A.compareTo(B) == 0;A.equals(B) = true;","link":"/2018/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/%E3%80%8AEffective-java%E3%80%8B-%E5%AF%B9%E4%BA%8E%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%83%BD%E9%80%9A%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/"},{"title":"《Effective Java》- 泛型","text":"不要在新代码中使用原生态类型 首先看一个反例，如何往 String 类型的集中中添加 int 类型的数据： 12345678List&lt;String&gt; str = new ArrayList&lt;&gt;();str.add(&quot;1&quot;);str.add(&quot;2&quot;);add(str, 3);private void add(List list, Object o) { list.add(o);}上面的代码在编译器并不会抛出异常，而是会有个一个 Unchecked 的警告。但是当获取到 int 类型的时就会抛出 ClassCastException 异常 如果使用像 List这样的原生态类型，就会失掉类型安全性，但是如果使用List这样的参数化类型， 则不会 不确定或者不在乎集合中元素类型的情况下，可以使用无限制的通配符类型:Set&lt;?&gt; 通配符类型是安全的，也可以限制了添加到集合中元素类型 List 参数化类型，可以包含任何对象类型的一个集合 List&lt;?&gt; 通配符类型，只能包含某种未知对象类型的集合 List 原生态类型，不安全 术语 示例 参数化的类型 List 实际类型参数 String 泛型 List 形式类型参数 E 无限制通配符类型 List&lt;?&gt; 原生态类型 List 有限制类型参数 递归类型限制 &lt;T extends Comparable&gt; 有限制通配符类型 List&lt;? extends Number&gt; 泛型方法 static List asList(E[] a) 类型令牌 String.class 消除非受检警告 Unchecked Cast Warning Unchecked Conversion Warning 非受检方法调用警告 非受检普通数组创建警告 非受检转换警告尽可能消除每一个非受检警告，如果无法消除警告，同时可以证明引起警告的代码是类型安全的，可以用一个注解来禁止这条警告。由于这个注解可以用在任何粒度的级别中，比如说类，方法以及一个变量。所以应该注意尽可能的缩小注解的范围。 永远不要在类上用这个注解。尽量用注释把禁止这个警告的原因记录下来 列表优先于数组数组与泛型相比，有两个不同点： 数组是协变的，如果A是B的子类型，那么数组类型A[]就是B[]的子类型。泛型是不可变的，List不是List的子类，也不是它的父类 数组是具体化的，数组在运行时检查它的元素类型约束;相对来说，泛型是不可具体化的，因为泛型是通过在编译期擦除类型来实现的 1234567// 由于数组是协变的，所以这种写法在编译期并不能检测出来问题Object[] objectArray = new Long[1]; objectArray[0] = &quot;I don&apos;t fit in&quot;; // 由于泛型是不可变的，所以在编译期就会报错List&lt;Object&gt; ol = new ArrayList&lt;Long&gt;(); // Incompatible types ol.add(&quot;I don&apos;t fit in&quot;);相对于运行期报错，最好是在编译期就能检测出来 数组和泛型不能很好的混合使用，如果在混合使用的过程中。发现了编译期错误或者警告。应该在第一时间用列表代替数组 优先使用泛型使用泛型比使用需要在客户端代码中进行转换的类型来得更加安全，也更加容易。在设计新类型的时候，要确保它们不需要这种转换就可以使用。这通常意味着要把类做成是泛型的。只要时间允许，就把现有的类型都泛型化。这对于这些类型的新用户来说会变得更加轻松，又不会破坏现有的客户端 优先考虑泛型方法下面是一个带有返回值的泛型方法： 123456789101112public &lt;E extends Comparable&lt;E&gt;&gt; E max(List&lt;E&gt; list) { Iterator&lt;E&gt; iterator = list.iterator(); E max = iterator.next(); while (iterator.hasNext()) { E next = iterator.next(); if (next.compareTo(max) &gt; 0) { max = next; } } return max;} 泛型方法使用起来比让客户端自行装换输入参数和返回值要安全 利用有限通配符来提升 API 的灵活性关键思想就是怎么使用有限通配符，使用有限通配符的原则：Producer-Extends，Consumer-Super 如果只从 List&lt;String&gt; producer 中读取数据，那么这个 List 就叫做 Producer如果只从 List&lt;String&gt; consumer 中添加数据，那么这个 List 就交错 Consumer 生产者使用 extends，消费者使用 super 的意思是，当使用 ? 定义一个通用类型的通配符时，如果该类是 Producer，那么应该使用 extends 关键字为此类型指定一个最高父类，如果该类是 Consumer，那么应该使用 super 关键字为此类型指定一个最低子类 extends 用法首先看一下 extends 的用法： 123List&lt;? extends Number&gt; producer1 = new ArrayList&lt;Integer&gt;();List&lt;? extends Number&gt; producer2 = new ArrayList&lt;Float&gt;();List&lt;? extends Number&gt; producer3 = new ArrayList&lt;Double&gt;(); &lt;? extends Number&gt; 指定 Number 为最高父类，所以所有的 Number 子类包括它自身都可以实例化这样的 List，但是不能用跟 Number 没有继承关系或者父类进行初始化： 12List&lt;? extends Number&gt; producer4 = new ArrayList&lt;String&gt;();List&lt;? extends Number&gt; producer5 = new ArrayList&lt;Object&gt;(); List&lt;? extends Number&gt; 的写操作是不允许的，如果允许向 List&lt;? extends Number&gt; 中写入数据，那么所有 Number 的子类都可以写入到该 List 中去，此时从该 List 中取数据时就不能保障拿出数据的具体类型 super 用法super 的用法刚好和 extends 的用法相反： 12List&lt;? super Number&gt; consumer1 = new ArrayList&lt;Object&gt;();List&lt;? super Number&gt; consumer2 = new ArrayList&lt;Number&gt;(); &lt;? super Number&gt; 指定 Number 为最低子类，所以所有的 Number 的父类包括自身都可以实例化这样的 List，但是不能用 Number 的子类进行实例化： 1List&lt;? super Number&gt; consumer3 = new ArrayList&lt;Integer&gt;(); List&lt;? super Number&gt; 允许写操作，但是写入的对象必须是 Number 的子类对象，但是对于读操作，由于没有限制最大父类，所以从 List&lt;? super Number&gt; 中读出来的对象只能是 Object，确定不了数据的类型 关于 PECS 的作用，下面是 Collections#copy 的源码： 123456789101112131415161718public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) { int srcSize = src.size(); if (srcSize &gt; dest.size()) throw new IndexOutOfBoundsException(&quot;Source does not fit in dest&quot;); if (srcSize &lt; COPY_THRESHOLD || (src instanceof RandomAccess &amp;&amp; dest instanceof RandomAccess)) { for (int i=0; i&lt;srcSize; i++) dest.set(i, src.get(i)); } else { ListIterator&lt;? super T&gt; di=dest.listIterator(); ListIterator&lt;? extends T&gt; si=src.listIterator(); for (int i=0; i&lt;srcSize; i++) { di.next(); di.set(si.next()); } }} Collections#copy 的用法： 123List&lt;Number&gt; numberList = new ArrayList&lt;Number&gt;();List&lt;Integer&gt; integerList = new ArrayList&lt;Integer&gt;();Collections.copy(numberList, integerList); 利用 PECS，该函数对集合的 copy 操作通用性非常强 优先考虑类型安全的异构容器Set、Map 的原生类型就是一个类型不安全的异构容器，想要做到类型安全的异构容器，需要将键（key）进行参数化而不是将容器（container）参数化，然后将参数化的键提交给容器，来插入或者获取值。用泛型系统来确保值的类型与它的键相符： 1234567891011121314public class Favorites { private Map&lt;Class&lt;?&gt;, Object&gt; favorites = new HashMap&lt;Class&lt;?&gt;, Object&gt;(); public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance) { if (type == null) throw new NullPointerException(&quot;Type is null&quot;); favorites.put(type, type.cast(instance)); } public &lt;T&gt; getFavorite(Class&lt;T&gt; type) { return type.cast(favorites.get(type)); }}其中 Class#cast 保证键和值之间的类型关系，每个值的类型都与键的类型相同，Favorites 类有一个局限性，它不能用在不可具体化的（non-reifiable）类型中：如果试图保存最喜爱的 List&lt;String&gt;，程序就不能进行编译.原因在于你无法为 List&lt;String&gt; 获得一个 Class 对象：List&lt;String&gt;.class 是个语法错误，这也是件好事。 List&lt;String&gt; 和 List&lt;Integer&gt; 共用一个 Class 对象，即 List.class。如果从“字面（type literal）”上来看，List&lt;String&gt;.class 和 List&lt;Integer&gt;.class 是合法的，并返回了相同的对象引用，就会破坏 Favorites 对象的内部结构 至今还没有完全令人满意的解决办法。有一种方法称作 super type token，它在解决这一局限性方面做了很多努力，但是这种方法仍然有它自身的局限性。集合API说明了泛型的一般用法，限制你每个容器只能有固定数目的类型参数。你可以通过将类型参数放在键上而不是容器上类避开这一限制","link":"/2018/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/%E3%80%8AEffective-java%E3%80%8B-%E6%B3%9B%E5%9E%8B/"},{"title":"《Effective Java》- 枚举和注解","text":"用 enum 代替 int 常量 Q：为什么要用 enum 代替 int 常量？ 首先看一下 int 枚举模式的定义方式： 12345678public static final int A_ONE = 1;public static final int A_TWO = 2;public static final int A_THREE = 3; public static final int B_ONE = 1;public static final int B_TWO = 2;public static final int B_THREE = 3; 这样的定义具有两个问题： 如果输出这些常量值，不会看出来有任何意义 很难获取到一共定义了多少这样的常量 接着看一下这样一个函数： 123public void add(int x, int y) { System.out.println(x + y);}这个函数期望传入两个都是 B 开头的常量值，但是此时传入任意 int 值编译并不会报错，且运行时也不会抛出异常，但是会造成一些莫名其妙的问题 还有一种 String 枚举模式，也许这种模式提供了可打印的常量值，但是它依赖于字符串的比较操作，这会有性能方面的问题。与此同时，如果项目中的其他成员不知道有这样的常量存在时，可能会用一些硬编码的字符串，一旦这些字符串出现拼写错误，程序并不会检测出有任何问题，只有在程序运行过程才会一些不可预测的问题 这种情况下，就需要用到枚举类来代替这种模式了，通过反编译枚举的字节码文件来看一下枚举是怎么实现的，先看一下 Java 文件： 123456789public enum IntEnum { ONE(1), TWO(2), THREE(3); IntEnum(int i) { }}接下来是编译后的内容： 12345678910111213141516171819202122232425262728public final class IntEnum extends Enum { public static IntEnum[] values() { return (IntEnum[]) $VALUES.clone(); } public static IntEnum valueOf(String s) { return (IntEnum) Enum.valueOf(org / lovedev / effectivejava / _30 / IntEnum, s); } private IntEnum(String s, int i, int j) { super(s, i); } public static final IntEnum ONE; public static final IntEnum TWO; public static final IntEnum THREE; private static final IntEnum $VALUES[]; static { ONE = new IntEnum(&quot;ONE&quot;, 0, 1); TWO = new IntEnum(&quot;TWO&quot;, 1, 2); THREE = new IntEnum(&quot;THREE&quot;, 2, 3); $VALUES = (new IntEnum[]{ ONE, TWO, THREE }); }}可以看出枚举是一个继承了 enum 抽象对象的 final 类，并且它的构造函数还是不可访问的，所以既不能实例化也不能扩展该类，只能访问类初始化时定义的几个 static final 实例对象 枚举还有还有一种将不同常量和行为关联起来方式，这种使用方式叫做特定于常量的方法实现 1234567891011121314151617181920212223242526public enum IntEnum { ONE(1) { @Override void test() { System.out.println(&quot;1&quot;); } }, TWO(2) { @Override void test() { System.out.println(&quot;2&quot;); } }, THREE(3) { @Override void test() { System.out.println(&quot;3&quot;); } }; IntEnum(int i) { } abstract void test();} 这种方式的优点在于，每当添加一个新的枚举类型时，就必须提供一个对应的方法实现，不会因为忘记添加实现导致程序出现异常 如果每个枚举常量都对应不同的行为，这种方式显然是没有任何问题的，但是在某些情况下只需要将这些枚举常量分为两种行为，比如工作日和休息日的起床时间，此时特定于常量的方法实现就不能很好的共享代码，先看一下解决这个问题的实现： 123456789101112131415161718192021222324252627282930313233343536373839enum WeekEnum { MONDAY(WAKEUPTIME.WEEKDAY), WEDNESDAY(WAKEUPTIME.WEEKDAY), TUESDAY(WAKEUPTIME.WEEKDAY), THURSDAY(WAKEUPTIME.WEEKDAY), FRIDAY(WAKEUPTIME.WEEKDAY), SATURDAY(WAKEUPTIME.WEEKEND), SUNDAY(WAKEUPTIME.WEEKEND); private WAKEUPTIME mWeekday; WeekEnum(WAKEUPTIME weekday) { mWeekday = weekday; } public int wakeUp() { return mWeekday.wakeUp(); } private enum WAKEUPTIME { WEEKDAY { @Override int wakeUp() { System.out.println(&quot;七点起床&quot;); return 7; } }, WEEKEND { @Override int wakeUp() { System.out.println(&quot;八点起床&quot;); return 8; } }; abstract int wakeUp(); }}把起床时间的定义放到一个嵌套的枚举类中，将这个策略枚举类传入到 WeekEnum 类中，把获取每天的起床时间交给策略枚举实现 枚举具有以下几个优势： 如果定义函数的参数是一个枚举类型，那么传入的参数必须是声明的枚举常量 可以实现接口，定义函数以及变量 由于枚举是通过实例化对象实现的，所以对比 Int 常量，性能上会有一点缺点，不过大多数情况下不用担心这个问题","link":"/2018/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/%E3%80%8AEffective-java%E3%80%8B-%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/"},{"title":"《Effective Java》- 类和接口","text":"使类成员的可访问性最小化 模块设计可以从该模块对于外部模块是否隐藏了内部数据以及实现细节来区别好坏，模块之间隐藏内部细节以及数据，通过 API 来互相通信。这个概念叫做信息隐藏，这也是高内聚，低耦合的基础。这样做有一下几点好处： 模块可以独立的开发，测试，优化，使用 修改一个模块时，由于内部细节是隐藏的，所有使用了该模块的其他模块不需要修改，也不用关心该模块是否修改过，提高了系统的可维护性 由于模块足够独立，不需要依赖其他模块，所有也提高了模块的可用性，把该模块放到其他运行环境中依旧可以正常使用 一个创建类的原则：尽可能地使每个类或者成员不被外界访问 如果类或者接口能做成包级私有的，就应该做成包级私有的，这样它实际是包的一部分，而不是该包导出 API的一部分，以后对该类或接口进行增删改也不会影响到调用者。如果做成公有的，开发者就有责任一直维护它，保持它的兼容性 如果一个类或者接口只在一个类中被用到，应该考虑把它做成那个类的私用内部类，这样就可以把该类的访问范围限制到了使用它的那个类中 Java 中的继承和实现限制了降低函数可访问性的能力，因为接口中声明的函数都是公有的，而继承了超类的子类在覆盖超类函数时，访问级别必须要高于超类中声明的，这是因为要保证在使用超类的地方都能用子类 可变的引用类型的类变量绝对不能是公有的 由于长度非零的数组总是可变的，所以类不能包含公有静态的数组变量，或者提供返回这类数组的函数 类中能够对外部暴露的变量类型只有静态 final 常量，这些常量要么是基本类型，要么是不可变类型 在公有类中使用访问方法而非公有域其实这就是我们经常为 JavaBean 提供的 get、set 函数组合 Q：为什么不把类的变量声明为公有的呢？A：首先为每个变量提供访问方法这种做法保留了将来改变该类内部表示法的可能性，在外部调用不做任何改变的情况下，可以通过修改内部表示法来满足需求 如果是内部嵌套类的变量，可以声明为公有的，因为内部嵌套类的变化范围被限制到了外围类中 使可变性最小化为了让类变成不可变，需要遵循以下原则： 不提供任何会修改对象状态的方法 保证类不会被扩展 - 为了防止子类化，常见做法是使这个类变成 final，或者私有化所有构造函数，添加公有的静态工厂 保证所有的属性都是 final 的 保证所有的属性都是 private 的 保证所有引用了可变对象的属性的互斥访问 - 需要确保使用该类的客户端无法从该类中获取到该可变对象的引用，进而破坏类的不可变性；并且永远不要用客户端提供的可变对象初始这样的属性，也不要提供任何的访问函数；构造器、访问函数以及 readObject 方法中使用 保护性拷贝 技术 由于不可变对象的特征，它本质上就是线程安全的，可以被自由分享，同时它也具有一个唯一的缺点就是对于不同的值都需要一个单独的对象，如果这个对象占用内存很低则影响不会太大，但是对于有大型对象频繁使用的项目，这个缺点是灾难性的。 在这种情况下如果能够精确预测出客户端想要在不可变类上做哪些复杂的多阶段操作，就需要提供一个 包级私有可变配套类，如果不可预测，最后的办法就是提供一个 公有可变配套类，就如同 String 和 StringBuilder 以及特定环境下的 BigInteger 和 BitSet 如果类实在不能做成不可变，就尽量限制它的可变性，除非有特别的理由要使属性变成非 final，否则一律都是 final 不可变对象可以提供一些静态工厂函数，对象内部缓存频繁被请求的实例，如果有请求满足该实例，则不用创建对象直接返回即可，降低内存占用和不必要的回收，典型例子就是 Boolean#valueOf 复合优于继承首先需要知道的一点是继承打破了封装性：如果子类依赖父类的某个功能的实现，在不停的版本迭代中，如果父类的该功能发生变化，那么子类同时也会遭到破坏，既然它没有任何变化，同样的如果父类在某个版本中增加了一个和子类某个函数签名相同但是返回类型不同的函数，这样程序就无法通过编译 解决此类问题有一个很好的方法 - 复合，不用扩展现有的类，只用在新的类中增加一个属性引用现有类的一个实例即可，这样的类也叫做包装类。此时被包装的类增加函数，不会影响到包装类；包装类也隐藏了被包装类的细节，并且可以基于被包装类随意扩展 要么为继承而设计，并提供文档说明，要么就禁止继承如果想要设计一个可被继承的类，必须要满足以下几点： 完善的文档 - 对于公有的或者受保护的函数或者构造器，文档必须指明该函数或者构造器调用了那些可覆盖函数 接口优于抽象类由于 Java 中只允许单继承，抽象类作为类型定义就受到了极大的限制。使用接口的好处： 现有的类可以很容易被更新 - 因为可以实现多个接口，所以当有一个新的接口时，只需要增加几个该接口定义的函数即可。如果是继承的话，现有的类很难扩展抽象类，而且如果有两个类需要扩展同一抽象类，就必须把该抽象类放到类层次的高处，这样做又间接的伤害到了类层次，迫使所有子类都要扩展这个抽象类 接口是定义 mixin（混合类型）的理想选择 - mixin 是指：类除了实现它的基本类型之外，还可以实现这个 mixin 类型，表明该类具有哪些可供选择的行为。例如 comparable 就是一个 mixin 接口，它允许类表明它的实例可以与其他可对比的类进行比较排序，由于抽象类不能被更新到现有的类中，所有抽象类不用由于定义 minin 接口允许我们构建非层次结构的类型框架 1234567public interface Singer{ void sing();}public interface Songwriter{ Song compose();} 对一个既是歌唱家又是作曲家的对象，让该对象同时实现这两个接口即可，甚至可以再定义一个接口： 1234public interface SingerSongwriter extends Singer， Songwriter{ void sing(); Song compose();} 如果是继承的话，这种情况就不太好处理 接口只能定义函数，不能包含函数的实现，但是这并不影响接口作为定义类型并提供实现上的帮助，这个时候就可以通过对导出的每个重要接口提供一个抽象的骨架实现类，把接口和抽象类的优点结合起来，接口还是用于定义类型，骨架实现类接管了所有与接口实现相关的工作 按照惯例，骨架实现类都被称为 AbstractInterface，其中 Interface 是指接口的名字，例如 AbstractSet、AbstractList 等 使用骨架实现类有一个明显的优势就是：抽象类的演变比接口的演变要容易的多，如果后期在抽象类中添加新的函数，始终可以有默认实现，不用子类做任何改变。如果是接口，则所有实现该接口的子类就必须实现该函数，有了骨架实现类，只需要在骨架实现类中增加该函数即可，一定程度上减少了对结构的破坏 当演变的容易性比灵活性和功能更加重要的时候，这种情况下使用抽象类定义类型，前提是必须理解并且可以接受这些局限性。如果导出了一个重要的接口，就应该坚决考虑同时提供骨架实现类 接口只用于定义类型有很多情况下都会定义一个常量接口这样的类，这种模式是对接口的不良使用。实现常量接口，对于客户端来说没有任何意义，而且在以后版本迭代中如果不需要这些常量时，依然必须实现这个接口，以确保兼容性 如果需要导出常量，推荐使用 枚举类型 或者不可实例化的 工具类 来导出 类层次优于标签类12345678910111213141516171819202122232425262728293031323334353637class Figure { enum Shape { RECTANGLE, CIRCLE }; // Tag field - the shape of this figure final Shape shape; // These fields are used only if shape is RECTANGLE double length; double width; // This field is used only if shape is CIRCLE double radius; // Constructor for circle Figure(double radius) { shape = Shape.CIRCLE; this.radius = radius; } // Constructor for rectangle Figure(double length, double width) { shape = Shape.RECTANGLE; this.length = length; this.width = width; } double area() { switch(shape) { case RECTANGLE: return length * width; case CIRCLE: return Math.PI * (radius * radius); default: throw new AssertionError(shape); } }} 这样一个标签类，即表示圆形也表示矩形，如果想要另外增加一个形状，就必须要修改源代码，而且多种形状的实现都混合在一个类中，极大破坏了可读性；实例所占用的内存也随之提高，因为它承担着属于其他形状的属性字段；而且实例本身也没有提供任何的关于形状的线索；标签类过于冗长，容易出错，效率低下 将标签类转化为类层次是一个很好的方式，首先需要定义一个包含抽象方法的抽象类，然后为每种标签类定义具体子类，并且每个子类中只包含该类型的数据： 123456789101112131415161718192021abstract class Figure { abstract double area();}class Circle extends Figure { final double radius; Circle(double radius) { this.radius = radius; } @Override double area() { return Math.PI * (radius * radius); }}class Rectangle extends Figure { final double length; final double width; Rectangle(double length, double width) { this.length = length; this.width = width; } @Override double area() { return length * width; }}这样做有几个好处： 具有较强的可读性，代码简单清晰 每个子类不受到其他不相关数据的拖累 所有属性都可以是 final 每种类型都是相互独立的，具有独立的数据，允许程序员指明变量类型，限制变量 可以用来反映类型之间本质上的层次关系，有助于增强灵活性，并进行更好的编译时类型检测 12345class Square extends Rectangle { Square(double side) { super(side, side); }} 这样就可以反映出来正方形也是一种特殊的矩形这一事实，尽量不使用标签类，用类层次代替 用函数对象表示策略声明一个接口表示该策略，具体策略实现该接口，如何一个具体策略只被使用一次，通常使用匿名类来实例化。如果需要多次复用，通常要被实现为私有的静态成员类，并通过公有的静态 final 属性导出，导出类型为策略接口 优先考虑静态成员类 非静态成员类默认持有外部类的引用，如果静态成员类生命周期比外部类长，就会造成内存泄漏 嵌套类需要独立于外部类存在，必须是静态内部类 如果嵌套类不访问外部类实例，需要把它变成静态内部类，否则每一个内部类实例都持有一个外部类的引用，浪费时间空间","link":"/2018/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/%E3%80%8AEffective-java%E3%80%8B-%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"},{"title":"《Effective Java》- 创建和销毁对象","text":"使用静态工厂方法替代构造器 优势 该静态工厂方式只是一个返回类实例的静态方法，不同于设计模式中的工厂方法 静态工厂方法有名称，见名知意，如果一个类需要多个构造函数，采用静态工厂方法，可以根据不同的函数名得以理解和区分 不必在每次调用静态工厂方法的时候都创建一个新对象，这种方法类似享元（Flyweight）模式以及单例（Singleton）模式，这些类都能成为实例受控的类，这些类的可以使用 == 代替 equals ，因为 == 对比的是对象的内存地址，equals 是对比对象每个字段的内容，所以 == 效率要高于 equals 静态工厂方法可以返回原对象类型的任意子类对象，可以根据参数的不同返回不同子类对象，同时也可以随着版本的迭代返回不同的子类对象。提高的程序的扩展性和可维护性。 创建泛型实例时，可以使代码变得更简单 1234567Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;();// 使用静态工厂方法public static &lt;K, V&gt; HashMap&lt;K, V&gt; newInstance() { return new HashMap&lt;K, v&gt;();}// 改造后使用方法Map&lt;String, List&lt;String&gt;&gt; map = HashMap.newInstance(); 缺点 类不含有公有或者受保护的构造器，就不能被子类化 在文档上面并不能和其他静态方法有任何区别 惯用名称 valueOf：类型转换，返回实例和参数具有相同的值 of：valueOf 更为简洁的写法 getInstance：返回的实例通过方法参数来描述，在 Singleton 中该函数没有参数，并返回全局唯一的实例 newInstance：每次返回一个新的实例 getType：同 getInstance ，Tpye 表示返回对象的类型 newType：同 newInstance 构造函数多个参数时使用构造器建造者（Builder） 模式 用私用构造器或者枚举类型创建 Singleton单例（Singleton） 模式 序列化问题 通过私有构造函数强化不可实例化能力有时候需要只包含了静态方法和静态变量这样的工具类，实例化这样的类没有任何意义。不能通过把这样的类设置成抽象类来解决该问题，因为这样该类就可以子类化，误导调用者。此时可以通过把构造函数设置成私有的来解决该问题，不过这样做会有副作用，因为子类访问不到父类的构造函数，所以这样的类不能被子类化 避免创建不必要的对象 如果有类初始化时就确定不变的内容，可以在静态代码块中对这些内容进行初始化 没能重用对象影响程序的风格和性能，但是没能创建重复对象或者保护性拷贝所带来的影响是安全漏洞和错误，当重用对象的代价大于创建重复对象时，应该重新创建对象或者保护性拷贝 消除过期的对象引用 过期引用：永远不会解除的引用 手动清空对象引用应该是一种例外，而不是一种规范行为。消除过期引用的最好方式是让包含改引用的变量结束生命周期 只要类自己管理内存，就应该警惕内存泄漏问题，一点实例被释放掉，该实例中包含的引用对象都应该被消除 借助 Heap 剖析工具发现内存泄漏问题 内存泄漏 避免使用终结方法finalize() 会导致行为不稳定、降低性能、以及可移植性问题 不能保证及时执行，JVM 的不同导致 finalize() 执行效果的不同 不能保证可以执行，当对象变成不可达时，对象的 finalize() 没有执行 System.gc()、System.finalization() 只能增加 finalize() 被执行的几率 在 finalize() 中，抛出异常时会导致 finalize() 过程结束，使对象处于被破坏状态 添加了 finalize() 后的对象的创建和销毁执行过程比没有添加的用时更长 需要提供显式的终止对象的方式，比如 FileInputStream、FileOutputStream、Timer、Connection","link":"/2018/08/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/%E3%80%8AEffective-java%E3%80%8B-%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"杂货铺","slug":"杂货铺","link":"/tags/%E6%9D%82%E8%B4%A7%E9%93%BA/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Http","slug":"Http","link":"/tags/Http/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"[object Object]","slug":"object-Object","link":"/tags/object-Object/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Translation","slug":"Translation","link":"/tags/Translation/"},{"name":"读书笔记","slug":"读书笔记","link":"/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"categories":[]}